## 3. Nesne Yönelimli Programlama (OOP)

### 3.1. Nesne Yönelimli Programlama (OOP) Giriş

#### **Neden OOP Öğrenmeliyiz?**

Programlama dünyasında **Nesne Yönelimli Programlama (OOP)**, en güçlü ve yaygın kullanılan yaklaşımlardan biridir. Neden bu kadar önemli? Çünkü gerçek hayatta her şey bir "nesne"dir: Bir araba, bir telefon, bir insan... Hepsi belirli özelliklere ve davranışlara sahiptir. İşte OOP, bu tür gerçek hayat modellerini programlamaya uyarlar.

Örneğin, bir otomobil fabrikası düşünelim. Fabrikada her arabanın özellikleri (marka, model, renk) ve davranışları (hareket etme, fren yapma) vardır. Eğer her arabayı tek tek kodlarsanız, işler karmaşıklaşır. Ancak OOP ile bir "Araba" şablonu oluşturup, bu şablondan yüzlerce araba üretebilirsiniz. Bu, hem zaman kazandırır hem de kodunuzu daha düzenli hale getirir.

OOP'nin temel amacı, programlama sürecini daha anlaşılır, yeniden kullanılabilir ve bakımı kolay hale getirmektir. Özellikle büyük projelerde OOP olmadan ilerlemek, bir labirentte yolunu bulmaya çalışmak gibidir.

---

#### **OOP'nin Mantığı ve Felsefesi**

OOP, gerçek hayattaki nesneleri ve ilişkilerini programlama dünyasına taşımak için tasarlanmıştır. Temel prensipleri şu şekildedir:

1. **Gerçek Hayat Modelleme:**  
   Her şey bir nesnedir ve bu nesnelerin özellikleriyle (örneğin, bir arabanın rengi) ve davranışlarıyla (örneğin, bir arabanın hareket etmesi) ilgileniriz.

2. **Modülerlik:**  
   Kodlarınızı küçük parçalara ayırarak yönetirsiniz. Örneğin, bir oyun geliştirdiğinizde, oyuncu karakteri, düşmanlar, envanter gibi farklı bileşenleri ayrı sınıflar olarak tanımlayabilirsiniz.

3. **Yeniden Kullanılabilirlik:**  
   Bir kez yazdığınız kodu tekrar tekrar kullanabilirsiniz. Örneğin, bir "Kullanıcı" sınıfı oluşturduktan sonra, ondan yüzlerce kullanıcı nesnesi üretebilirsiniz.

4. **Bakımı Kolaylaştırma:**  
   Büyük projelerde değişiklik yapmak zor olabilir. Ancak OOP ile kodunuzu düzenli tutarsanız, değişiklikleri daha kolay uygulayabilirsiniz.

---

#### **OOP'nin Avantajları ve Dezavantajları**

##### **Avantajları:**
1. **Düzenli Kod Yapısı:**  
   Kodlarınız daha düzenli ve okunabilir hale gelir.
2. **Yeniden Kullanılabilirlik:**  
   Tekrar tekrar aynı kodu yazmak yerine, sınıfları yeniden kullanabilirsiniz.
3. **Bakımı Kolaylaştırma:**  
   Büyük projelerde değişiklik yapmak daha kolay olur.
4. **Güvenlik:**  
   Erişim belirleyiciler sayesinde, hassas verilere izinsiz erişimi engelleyebilirsiniz.

##### **Dezavantajları:**
1. **Öğrenme Eğrisi:**  
   OOP, başlangıçta biraz karmaşık gelebilir.
2. **Performans Maliyeti:**  
   Bazı durumlarda, OOP yaklaşımı performans açısından daha fazla kaynak tüketebilir.
3. **Aşırı Tasarım Riski:**  
   Basit projelerde OOP kullanmak, gereksiz karmaşıklığa yol açabilir.

---

### 3.2. Sınıf ve Nesne Kavramları

#### **Sınıf Nedir?**

Sınıf, bir nesnenin şablonudur veya maviyor diyebiliriz. Gerçek hayattaki bir nesneyi programlama dünyasına aktarmak için sınıf tanımlarız. Sınıflar, nesnelerin özelliklerini (**properties**) ve davranışlarını (**methods**) içerir. Örneğin, bir pastane düşünelim. Pastanede her pasta için bir tarif vardır. Bu tarif, pastanın malzemelerini (özellikler) ve nasıl yapılacağını (davranışlar) belirtir. İşte bu tarif, bir "sınıf"a benzer. Tarif sabittir, ama yapılan her pasta farklı olabilir.

Teknik açıdan, bir sınıf şu şekilde tanımlanır:

```csharp
class Araba
{
    // Özellikler (Properties)
    public string Marka { get; set; }
    public string Model { get; set; }
    public int Hiz { get; set; }

    // Davranışlar (Methods)
    public void Calistir()
    {
        Console.WriteLine("Araba çalışıyor.");
    }

    public void Hizlan(int artis)
    {
        Hiz += artis;
        Console.WriteLine($"Yeni hız: {Hiz}");
    }
}
```

Bu örnekte:
- `Marka`, `Model` ve `Hiz` özellikleri (properties), arabanın durumunu tanımlar.
- `Calistir` ve `Hizlan` metotları (methods), arabanın davranışlarını tanımlar.

#### **Nesne Nedir?**

Nesne, bir sınıfın somut bir örneğidir. Yani, sınıf bir şablonsa, nesne bu şablonun uygulanmış halidir. Örneğin, "Araba" sınıfından bir "Toyota Corolla" nesnesi oluşturabilirsiniz. Pastanede tarife göre yapılan bir pasta, bir "nesne"dir. Tarif (sınıf) sabittir, ama yapılan her pasta (nesne) farklı olabilir. Her pasta aynı tarifle yapılsa da, malzemelerin miktarı veya süslemesi farklılık gösterebilir.

Teknik açıdan, bir nesne şu şekilde oluşturulur:

```csharp
Araba toyota = new Araba();
toyota.Marka = "Toyota";
toyota.Model = "Corolla";
toyota.Hiz = 0;

toyota.Calistir(); // Çıktı: Araba çalışıyor.
toyota.Hizlan(50); // Çıktı: Yeni hız: 50
```

Burada:
- `toyota` adlı bir nesne oluşturduk.
- Bu nesneye `Marka`, `Model` ve `Hiz` gibi özellikler atadık.
- Ardından, `Calistir` ve `Hizlan` metotlarını çağırarak arabanın davranışlarını gerçekleştirdik.

---

#### OOP'nin Temel Prensipleri (Yüzeysel Anlatım)

##### **1. Encapsulation (Kapsülleme)**

Kapsülleme, bir nesnenin iç yapısını gizlemek ve dışarıdan erişimi kontrol etmek için kullanılır. Örneğin, bir televizyonun düğmeleri ve bağlantıları dışarıya açık olsa da, devreleri ve elektronik bileşenleri kapalıdır. İşte kapsülleme, bu tür hassas bilgileri korumak için kullanılır. Daha detaylı açıklamasını ileriki bölümlerde yapacağız.

---

##### **2. Inheritance (Miras Alma)**

Miras alma, bir sınıfın başka bir sınıftan özelliklerini ve davranışlarını devralmasını sağlar. Örneğin, bir "Hayvan" sınıfından miras alan "Kedi" sınıfı, hayvanın genel özelliklerini alır ve kendi özelliklerini ekler. Bir ailenin üyeleri düşünelim. Babanın soyadı "Yılmaz" ise, çocuklarının da soyadı "Yılmaz" olur. Ancak çocuklar, kendi isimlerini ve özellikleri eklerler. Daha detaylı açıklamasını ileriki bölümlerde yapacağız.

---

##### **3. Polymorphism (Çok Biçimlilik)**

Polymorphism, bir nesnenin birden fazla şekilde davranabilmesini sağlar. Örneğin, bir "SesCikar" metodu, farklı hayvanlar için farklı sesler üretebilir. Bir müzik aleti düşünelim. Gitar, piyano ve davul hepsi "çal" komutunu alır, ancak farklı sesler çıkarırlar. Daha detaylı açıklamasını ileriki bölümlerde yapacağız.

---

##### **4. Abstraction (Soyutlama)**

Soyutlama, bir nesnenin yalnızca gerekli özellikleri ve davranışlarını göstermek, geri kalanını gizlemek demektir. Örneğin, bir arabanın nasıl çalıştığını bilmek zorunda değilsiniz, sadece direksiyonu çevirmeniz yeterlidir. Bir kahve makinesi düşünelim. Makinenin içinde neler olduğunu bilmek zorunda değilsiniz, sadece butona basarak kahve alırsınız. Daha detaylı açıklamasını ileriki bölümlerde yapacağız.

---

#### **Erişim Belirleyiciler**

Erişim belirleyiciler, bir sınıfın veya üyenin ne kadar "erişilebilir" olduğunu belirler. Günlük hayatta, evinizdeki odaları düşünebilirsiniz. Kimse mutfakta yemek yiyebilir (`public`), ancak özel bir odanız varsa sadece siz girebilirsiniz (`private`). İşte erişim belirleyiciler de aynı mantıkla çalışır.

1. **`public`:**  
   Her yerden erişilebilir. Genellikle, tüm program tarafından erişilmesi gereken özellikler ve metotlar için kullanılır. Örneğin, bir arabanın markası herkes tarafından bilinebilir, bu yüzden `public` olarak tanımlanabilir.

   ```csharp
   public string Marka { get; set; }
   ```

2. **`private`:**  
   Sadece sınıf içinden erişilebilir. Dışarıdan erişilmesini istemediğiniz hassas veriler için kullanılır. Örneğin, bir banka hesabı uygulamasında bakiye bilgisi `private` olmalıdır. Böylece, kullanıcılar doğrudan bakiyeyi değiştiremez, sadece belirlenen metotlar üzerinden işlem yapabilir.

   ```csharp
   private int bakiye;
   ```

3. **`protected`:**  
   Sadece sınıf ve alt sınıflardan erişilebilir. Miras alınan sınıflarda ortak özellikleri korumak için kullanılır. Örneğin, bir "Hayvan" sınıfından miras alan "Kedi" sınıfının bazı özelliklerini korumak için `protected` kullanabilirsiniz.

   ```csharp
   protected string Tur { get; set; }
   ```

4. **`internal`:**  
   Aynı proje içinde erişilebilir. Proje içindeki sınıflar arasında paylaşılması gereken özellikler için kullanılır. Farklı projelerden erişilmesini istemediğiniz durumlarda idealdir.

   ```csharp
   internal string Renk { get; set; }
   ```

5. **`protected internal`:**  
   Aynı proje içinde veya alt sınıflardan erişilebilir. Hem proje içi hem de miras alınan sınıflar için uygun olan özellikler için kullanılır.

   ```csharp
   protected internal string Model { get; set; }
   ```

---

##### **Constructor (Yapıcı Metotlar)**

Constructor, bir nesne oluşturulduğunda çalışan özel bir metottur. Örneğin, bir araba nesnesi oluşturduğunuzda, arabanın başlangıç özelliklerini ayarlamak için constructor kullanabilirsiniz.

```csharp
class Araba
{
    public string Marka { get; set; }
    public string Model { get; set; }

    // Constructor
    public Araba(string marka, string model)
    {
        Marka = marka;
        Model = model;
    }
}

// Kullanım
Araba toyota = new Araba("Toyota", "Corolla");
Console.WriteLine(toyota.Marka); // Çıktı: Toyota
```

Burada:
- `Araba` sınıfının constructor'ı, nesne oluşturulduğunda `Marka` ve `Model` özelliklerini ayarlar.

---

##### **Static Üyeler**

`static` anahtar kelimesi, bir üye veya metodun sınıfın kendisine ait olduğunu belirtir. Yani, nesne oluşturmadan da kullanılabilir. Örneğin, bir matematik sınıfı düşünelim. `PI` değerini saklamak için `static` bir değişken kullanabiliriz.

```csharp
class Matematik
{
    public static double PI = 3.14;

    public static double AlanHesapla(double yariCap)
    {
        return PI * yariCap * yariCap;
    }
}

// Kullanım
double alan = Matematik.AlanHesapla(5);
Console.WriteLine(alan); // Çıktı: 78.5
```

Burada:
- `PI` ve `AlanHesapla` metodu `static` olduğu için, sınıfın bir nesnesi oluşturulmadan kullanılabilir.

---


### 3.3. Constructor ve Destructor

#### **Constructor Kavramı ve Kullanımı**

**Constructor**, bir nesne oluşturulduğunda çalışan özel bir metottur. Bir makinenin ilk çalıştırılması gibi düşünebilirsiniz. Örneğin, bir kahve makinesi açıldığında otomatik olarak hazır hale gelir. Programlamada da constructor, nesneyi kullanıma hazırlar.

##### **1. Default Constructor (Varsayılan Constructor)**

Default constructor, parametre almayan ve nesnenin temel özelliklerini ayarlayan bir constructor'dır. Eğer bir sınıf için constructor tanımlamazsanız, C# otomatik olarak varsayılan bir constructor oluşturur. Bir cep telefonu fabrikadan çıktığında önceden belirlenmiş bir dille (örneğin İngilizce) ve varsayılan ayarlarla gelir. İşte bu, default constructor gibidir.


```csharp
class Araba
{
    public string Marka { get; set; }
    public string Model { get; set; }

    // Default constructor
    public Araba()
    {
        Marka = "Bilinmiyor";
        Model = "Bilinmiyor";
    }
}

// Kullanım
Araba araba = new Araba();
Console.WriteLine($"Marka: {araba.Marka}, Model: {araba.Model}");
// Çıktı: Marka: Bilinmiyor, Model: Bilinmiyor
```

Burada:
- `Araba` sınıfının default constructor'ı, nesne oluşturulduğunda `Marka` ve `Model` özelliklerini "Bilinmiyor" olarak ayarlar.

##### **2. Parametreli Constructor**

Parametreli constructor, nesne oluşturulurken belirli değerleri alır ve bu değerleri özelliklere atar. Böylece, nesneyi daha özelleştirilmiş bir şekilde kullanabilirsiniz. Bir pastane düşünelim. Müşteri sipariş verdiğinde, pastanın boyutunu, rengini ve süslemesini belirleyebilir. İşte bu, parametreli constructor gibi çalışır.


```csharp
class Araba
{
    public string Marka { get; set; }
    public string Model { get; set; }

    // Parametreli constructor
    public Araba(string marka, string model)
    {
        Marka = marka;
        Model = model;
    }
}

// Kullanım
Araba toyota = new Araba("Toyota", "Corolla");
Console.WriteLine($"Marka: {toyota.Marka}, Model: {toyota.Model}");
// Çıktı: Marka: Toyota, Model: Corolla
```

Burada:
- `Araba` sınıfının parametreli constructor'ı, nesne oluşturulurken `Marka` ve `Model` değerlerini alır ve özelliklere atar.

##### **3. Constructor Overloading**

Constructor overloading, bir sınıfta birden fazla constructor tanımlamak anlamına gelir. Her constructor farklı parametreler alır ve farklı senaryolar için kullanılabilir. Bir restoran düşünün. Müşterilerden bazıları sadece menüden sipariş verirken, bazıları özel taleplerde bulunabilir. İşte bu, constructor overloading gibi çalışır.


```csharp
class Araba
{
    public string Marka { get; set; }
    public string Model { get; set; }
    public int Hiz { get; set; }

    // Default constructor
    public Araba()
    {
        Marka = "Bilinmiyor";
        Model = "Bilinmiyor";
        Hiz = 0;
    }

    // Parametreli constructor
    public Araba(string marka, string model)
    {
        Marka = marka;
        Model = model;
        Hiz = 0;
    }

    // Üç parametreli constructor
    public Araba(string marka, string model, int hiz)
    {
        Marka = marka;
        Model = model;
        Hiz = hiz;
    }
}

// Kullanım
Araba araba1 = new Araba();
Araba araba2 = new Araba("Toyota", "Corolla");
Araba araba3 = new Araba("Honda", "Civic", 120);

Console.WriteLine($"Araba 1: {araba1.Marka}, {araba1.Model}, Hız: {araba1.Hiz}");
Console.WriteLine($"Araba 2: {araba2.Marka}, {araba2.Model}, Hız: {araba2.Hiz}");
Console.WriteLine($"Araba 3: {araba3.Marka}, {araba3.Model}, Hız: {araba3.Hiz}");
```

Burada:
- `Araba` sınıfında üç farklı constructor tanımlandı. Her biri farklı senaryolar için kullanılır.

---

#### **Destructor Kavramı ve Kullanımı**

**Destructor**, bir nesne bellekten kaldırılmadan önce çalışan özel bir metottur. Bir cihazın kapatılması gibi düşünebilirsiniz. Örneğin, bir bilgisayar kapatıldığında tüm açık dosyalar kaydedilir ve sistem temizlenir. Programlamada da destructor, nesne yok edilmeden önce son işlemlerin yapılmasını sağlar.

##### **Destructor Yapısı ve Kullanımı**

Destructor, `~` işaretiyle tanımlanır ve hiçbir parametre alamaz. Ayrıca, manuel olarak çağrılmasına gerek yoktur; C# tarafından otomatik olarak çağrılır. Bir evden taşınırken, eşyaları topladıktan sonra son kez temizlik yaparsınız. İşte bu, destructor gibi çalışır.


```csharp
class Araba
{
    public string Marka { get; set; }

    // Constructor
    public Araba(string marka)
    {
        Marka = marka;
        Console.WriteLine($"{Marka} oluşturuldu.");
    }

    // Destructor
    ~Araba()
    {
        Console.WriteLine($"{Marka} bellekten kaldırıldı.");
    }
}

// Kullanım
Araba araba = new Araba("Toyota");
araba = null; // Nesneyi null yaparak bellekten kaldırılmasını sağlıyoruz
GC.Collect(); // Garbage Collector'u manuel olarak tetikliyoruz
```

Burada:
- `Araba` sınıfının destructor'ı, nesne bellekten kaldırılmadan önce çalışır.
- `GC.Collect()` ile garbage collector'u manuel olarak tetikleyebilirsiniz, ancak genellikle bu işlem otomatik olarak gerçekleşir.

##### **Garbage Collection ve Bellek Yönetimi**

C#, bellek yönetimi için **Garbage Collector (Çöp Toplayıcı)** adlı bir mekanizma kullanır. Bu mekanizma, artık kullanılmayan nesneleri otomatik olarak bellekten kaldırır. Bir evi düzenli olarak temizlemek gibi düşünebilirsiniz. Artık kullanılmayan eşyaları çöpe atarsınız ve eviniz temiz kalır.

- Garbage Collector, programın performansını etkileyebileceği için manuel olarak tetiklemek önerilmez.
- Destructor'lar, garbage collector tarafından çağrıldığı için kesin bir zamanlama garantisi vermez.

---


### 3.4. Encapsulation (Kapsülleme)

**Kapsülleme**, bir nesnenin iç yapısını gizlemek ve dışarıdan erişimi kontrol etmek için kullanılan bir prensiptir. Bir televizyonu düşünelim. Televizyonun düğmeleri ve bağlantıları dışarıya açık olsa da, devreleri ve elektronik bileşenleri kapalıdır. İşte kapsülleme, bu tür hassas bilgileri korumak için kullanılır.

Kapsülleme sayesinde:
- Verileri doğrudan değiştirmek yerine kontrollü bir şekilde yönetebilirsiniz.
- Kodunuzu daha güvenli ve düzenli hale getirebilirsiniz.
- İleride değişiklik yapmak daha kolay olur.

Şimdi kapsüllemenin temel bileşenlerini inceleyelim: **Getter ve Setter Metotları** ile **Properties**.

---

#### **Getter ve Setter Metotları**

**Getter ve Setter metotları**, bir sınıfın özelliklerine erişim ve düzenleme için kullanılır. Bu metotlar, veriye doğrudan erişimi engelleyerek kontrol sağlar. Örneğin, bir banka hesabı düşünelim. Bakiyeyi doğrudan değiştirmek yerine, para yatırma ve çekme işlemlerini belirli kurallarla sınırlayabilirsiniz.

##### **1. Getter Metotları**

Getter metotları, bir özelliğin değerini okumak için kullanılır. Örneğin, bir arabanın hızını öğrenmek için bir getter metodu çağırabilirsiniz. Bir kahve makinesinin içindeki su seviyesini kontrol etmek gibi düşünebilirsiniz.

Teknik açıdan:

```csharp
class Araba
{
    private int hiz; // Private değişken

    // Getter metodu
    public int HiziAl()
    {
        return hiz;
    }
}

// Kullanım
Araba araba = new Araba();
Console.WriteLine($"Hız: {araba.HiziAl()}");
```

Burada:
- `hiz` özelliği `private` olduğu için doğrudan erişilemez.
- `HiziAl` metodu, `hiz` değerini okumak için kullanılır.

##### **2. Setter Metotları**

Setter metotları, bir özelliğe değer atamak için kullanılır. Örneğin, bir arabanın hızını artırmak için bir setter metodu çağırabilirsiniz. Bir kahve makinesine su eklemek gibi düşünebilirsiniz.

Teknik açıdan:

```csharp
class Araba
{
    private int hiz; // Private değişken

    // Setter metodu
    public void HiziAyarla(int yeniHiz)
    {
        if (yeniHiz >= 0) // Kontrol ekleyebilirsiniz
        {
            hiz = yeniHiz;
        }
        else
        {
            Console.WriteLine("Hız negatif olamaz.");
        }
    }

    // Getter metodu
    public int HiziAl()
    {
        return hiz;
    }
}

// Kullanım
Araba araba = new Araba();
araba.HiziAyarla(100);
Console.WriteLine($"Hız: {araba.HiziAl()}"); // Çıktı: Hız: 100
```

Burada:
- `HiziAyarla` metodu, `hiz` değerini güvenli bir şekilde değiştirir.
- Negatif hız girişi yapılmaması için bir kontrol eklenmiştir.

---

#### **Properties (Özellikler)**

**Properties**, getter ve setter metotlarının daha kısa ve okunabilir bir alternatifidir. C#'ta özellikleri (`properties`) kullanarak, veri erişimini daha düzenli hale getirebilirsiniz.

##### **1. Property Tanımlama ve Kullanımı**

Bir property, bir özelliğe hem okuma hem de yazma izni verebilir. Örneğin, bir arabanın markasını okumak veya değiştirmek için bir property tanımlayabilirsiniz. Bir cep telefonunun model adını ayarlamak gibi düşünebilirsiniz.

Teknik açıdan:

```csharp
class Araba
{
    private string marka; // Private değişken

    // Property tanımlama
    public string Marka
    {
        get { return marka; } // Getter kısmı
        set { marka = value; } // Setter kısmı
    }
}

// Kullanım
Araba araba = new Araba();
araba.Marka = "Toyota"; // Setter çalışır
Console.WriteLine($"Marka: {araba.Marka}"); // Getter çalışır
```

Burada:
- `Marka` özelliği, `get` ve `set` bloklarıyla tanımlanmıştır.
- `value` anahtar kelimesi, property'e atanacak değeri temsil eder.

##### **2. Auto-Implemented Properties**

Eğer bir özelliğin özel bir mantığı yoksa, auto-implemented properties kullanabilirsiniz. Bu, kodu daha kısa ve temiz hale getirir. Örneğin, bir arabanın rengini saklamak için basit bir property tanımlayabilirsiniz. Bir cep telefonunun rengini kaydetmek gibi düşünebilirsiniz.

Teknik açıdan:

```csharp
class Araba
{
    // Auto-implemented property
    public string Renk { get; set; }
}

// Kullanım
Araba araba = new Araba();
araba.Renk = "Kırmızı";
Console.WriteLine($"Renk: {araba.Renk}");
```

Burada:
- `Renk` özelliği, auto-implemented property olarak tanımlanmıştır.
- Özel bir mantık içermediği için, direkt olarak kullanılabilir.

##### **3. Read-Only ve Write-Only Properties**

Bazı durumlarda bir özelliğe sadece okuma veya sadece yazma izni vermek isteyebilirsiniz. Örneğin, bir arabanın üretim yılı sadece okunabilir olabilir. Bir cep telefonunun seri numarası gibi düşünebilirsiniz.

Teknik açıdan:

```csharp
class Araba
{
    private int uretimYili = 2020;

    // Read-only property
    public int UretimYili
    {
        get { return uretimYili; }
    }

    private string sifre;

    // Write-only property
    public string Sifre
    {
        set { sifre = value; }
    }
}

// Kullanım
Araba araba = new Araba();
Console.WriteLine($"Üretim Yılı: {araba.UretimYili}"); // Okunabilir
araba.Sifre = "12345"; // Yazılabilir
```

Burada:
- `UretimYili` özelliği, sadece okunabilir (`read-only`).
- `Sifre` özelliği, sadece yazılabilir (`write-only`).

---


### 3.5. Inheritance (Kalıtım)

**Kalıtım**, bir sınıfın başka bir sınıftan özelliklerini ve davranışlarını devralmasını sağlar. Günlük hayatta aileleri düşünelim. Babanın soyadı "Yılmaz" ise, çocuklarının da soyadı "Yılmaz" olur. Ancak çocuklar, kendi isimlerini ve özellikleri eklerler. Programlamada da bu mantık geçerlidir: Bir temel sınıf oluşturup, ondan türetilen sınıflar bu temeli genişletebilir veya özelleştirebilir.

Kalıtım sayesinde:
- Kod tekrarını azaltabilirsiniz.
- Sınıflar arasında hiyerarşik bir ilişki kurabilirsiniz.
- Yeniden kullanılabilirlik artar.

Şimdi kalıtımın temel bileşenlerini inceleyelim: **Temel Sınıf ve Türetilmiş Sınıf**, **`base` anahtar kelimesi**, **Çoklu Kalıtım Sorunları** ve **Interface Kullanımı**.

---

#### **Temel Sınıf ve Türetilmiş Sınıf**

##### **1. Temel Sınıf (Base Class)**

Temel sınıf, diğer sınıfların miras alabileceği bir şablon görevi görür. Örneğin, bir "Hayvan" sınıfı düşünelim. Bu sınıf, tüm hayvanların ortak özelliklerini ve davranışlarını tanımlar. Bir pastane tarifini düşünün. Tarif, tüm pastalar için genel kuralları içerir. İşte bu, temel sınıf gibidir.

Teknik açıdan:

```csharp
class Hayvan
{
    public string Ad { get; set; }

    public void SesCikar()
    {
        Console.WriteLine("Hayvan ses çıkarıyor.");
    }
}
```

Burada:
- `Hayvan` sınıfı, tüm hayvanlar için ortak bir şablondur.

##### **2. Türetilmiş Sınıf (Derived Class)**

Türetilmiş sınıf, temel sınıftan özelliklerini ve davranışlarını devralır. Ayrıca, kendi özelliklerini ve davranışlarını da ekleyebilir. Örneğin, bir "Kedi" sınıfı, "Hayvan" sınıfından miras alır ve kendine özgü bir miyavlama davranışı ekler. Bir pastane tarifinden yapılan bir pasta, tarife ek olarak özel süslemeler de yapabilir. İşte bu, türetilmiş sınıf gibidir.

Teknik açıdan:

```csharp
class Kedi : Hayvan
{
    public void Miyavla()
    {
        Console.WriteLine("Miyav!");
    }
}

// Kullanım
Kedi kedi = new Kedi();
kedi.Ad = "Boncuk";
Console.WriteLine($"Ad: {kedi.Ad}");
kedi.SesCikar(); // Miras alınan metot
kedi.Miyavla();  // Kendi metodu
```

Burada:
- `Kedi` sınıfı, `Hayvan` sınıfından miras alır.
- `SesCikar` metodu, miras alınan bir metottur.
- `Miyavla` metodu, `Kedi` sınıfının kendi metodudur.

---

#### **`base` Anahtar Kelimesi**

`base` anahtar kelimesi, türetilmiş sınıftan temel sınıfın üyelerine erişmek için kullanılır. Özellikle constructor'lar arasında iletişim kurmak için faydalıdır. Bir çocuğun babasının adını kullanması gibi düşünebilirsiniz.

##### **1. Constructor'da `base` Kullanımı**

Türetilmiş sınıfın constructor'ı, temel sınıfın constructor'ını çağırabilir. Örneğin, bir araba fabrikası düşünelim. Her arabanın bir markası ve modeli vardır. Türetilmiş sınıf, temel sınıfın constructor'ını çağırarak bu bilgileri ayarlayabilir.

Teknik açıdan:

```csharp
class Araba
{
    public string Marka { get; set; }

    public Araba(string marka)
    {
        Marka = marka;
    }
}

class ElektrikliAraba : Araba
{
    public int PilKapasitesi { get; set; }

    public ElektrikliAraba(string marka, int pilKapasitesi) : base(marka)
    {
        PilKapasitesi = pilKapasitesi;
    }
}

// Kullanım
ElektrikliAraba tesla = new ElektrikliAraba("Tesla", 100);
Console.WriteLine($"Marka: {tesla.Marka}, Pil Kapasitesi: {tesla.PilKapasitesi}");
```

Burada:
- `ElektrikliAraba` sınıfı, `Araba` sınıfından miras alır.
- `base(marka)` ifadesi, temel sınıfın constructor'ını çağırır.

##### **2. Metotlarda `base` Kullanımı**

Türetilmiş sınıf, temel sınıfın metotlarını çağırabilir veya özelleştirebilir. Örneğin, bir hayvanın ses çıkarma davranışını değiştirebilirsiniz. Bir çocuk, babasının tarifini takip ederken bir adım ekleyebilir. İşte bu, `base` anahtar kelimesiyle sağlanır.

Teknik açıdan:

```csharp
class Hayvan
{
    public virtual void SesCikar()
    {
        Console.WriteLine("Hayvan ses çıkarıyor.");
    }
}

class Kedi : Hayvan
{
    public override void SesCikar()
    {
        base.SesCikar(); // Temel sınıfın metotunu çağırır
        Console.WriteLine("Miyav!"); // Kendi davranışı
    }
}

// Kullanım
Kedi kedi = new Kedi();
kedi.SesCikar();
```

Burada:
- `Kedi` sınıfı, `Hayvan` sınıfının `SesCikar` metodunu çağırır ve üzerine yeni bir davranış ekler.

---

#### **Çoklu Kalıtım ve Interface Kullanımı**

##### **1. Çoklu Kalıtım Sorunları**

C# dilinde bir sınıf sadece tek bir sınıftan miras alabilir. Bu, **çoklu kalıtım** sorununa yol açabilir. Örneğin, bir "Uçan Araba" sınıfı düşünelim. Bu sınıf, hem "Araba" hem de "Uçak" sınıflarından miras almak isteyebilir. Ancak C# bu durumu desteklemez. Çünkü, iki farklı sınıftan gelen aynı isimdeki metotlar çakışabilir.

##### **2. Çözüm: Interface Kullanımı**

Interface, bir sınıfın sahip olması gereken metotları tanımlar ancak bunların nasıl çalışacağını belirtmez. Böylece, bir sınıf birden fazla interface'i uygulayabilir. Örneğin, bir "Uçan Araba" sınıfı hem "IYolculuk" hem de "IUcus" interface'lerini uygulayabilir. Bir cep telefonu düşünelim. Aynı anda hem fotoğraf çekebilir hem de müzik çalabilir. İşte bu, interface kullanımı gibidir.

Teknik açıdan:

```csharp
interface IYolculuk
{
    void Sur();
}

interface IUcus
{
    void Uc();
}

class UcanAraba : IYolculuk, IUcus
{
    public void Sur()
    {
        Console.WriteLine("Araba sürülüyor.");
    }

    public void Uc()
    {
        Console.WriteLine("Araba uçuyor.");
    }
}

// Kullanım
UcanAraba ucabilirAraba = new UcanAraba();
ucabilirAraba.Sur();
ucabilirAraba.Uc();
```

Burada:
- `UcanAraba` sınıfı, hem `IYolculuk` hem de `IUcus` interface'lerini uygular.
- Her interface'in metodlarını kendi içinde tanımlar.

---


### 3.6. Polymorphism (Çok Biçimlilik)

**Polymorphism**, bir nesnenin birden fazla şekilde davranabilmesini sağlar. Bir müzik aleti düşünelim. Gitar, piyano ve davul hepsi "çal" komutunu alır, ancak farklı sesler çıkarırlar. Programlamada da polymorphism, bir metot veya sınıfın farklı senaryolarda farklı şekillerde çalışmasını sağlar.

Polymorphism sayesinde:
- Kodunuzu daha esnek hale getirebilirsiniz.
- Ortak bir arayüz kullanarak farklı davranışlar elde edebilirsiniz.
- Miras alma mekanizmasıyla birlikte daha güçlü tasarım desenleri oluşturabilirsiniz.

Şimdi polymorphism'in temel bileşenlerini inceleyelim: **Metot Overriding ve Overloading**, **Abstract Sınıflar ve Metotlar**.

---

#### **Metot Overriding ve Overloading**

##### **1. Metot Overriding (`virtual` ve `override` Anahtar Kelimeleri)**

Metot overriding, bir türetilmiş sınıfın temel sınıftaki bir metodun davranışını değiştirmesine olanak tanır. Örneğin, bir "Hayvan" sınıfının `SesCikar` metodu, türetilmiş "Kedi" sınıfında `Miyavla` olarak özelleştirilebilir. Bir çocuğun babasının tarifini takip ederken bir adım eklemesi gibi düşünebilirsiniz.

Teknik açıdan:

```csharp
class Hayvan
{
    public virtual void SesCikar()
    {
        Console.WriteLine("Hayvan ses çıkarıyor.");
    }
}

class Kedi : Hayvan
{
    public override void SesCikar()
    {
        Console.WriteLine("Miyav!");
    }
}

class Kopek : Hayvan
{
    public override void SesCikar()
    {
        Console.WriteLine("Hav hav!");
    }
}

// Kullanım
Hayvan hayvan1 = new Kedi();
Hayvan hayvan2 = new Kopek();

hayvan1.SesCikar(); // Çıktı: Miyav!
hayvan2.SesCikar(); // Çıktı: Hav hav!
```

Burada:
- `Hayvan` sınıfındaki `SesCikar` metodu, `virtual` anahtar kelimesiyle işaretlenmiştir.
- `Kedi` ve `Kopek` sınıfları, `override` anahtar kelimesiyle bu metodu özelleştirir.
- Polymorphism sayesinde, `Hayvan` türündeki değişkenler farklı sınıflara ait nesneleri tutabilir ve uygun metotlar çağrılabilir.

##### **2. Metot Overloading**

Metot overloading, aynı isme sahip ancak farklı parametrelere sahip metotlar tanımlamaktır. Örneğin, bir hesap makinesi düşünelim. Toplama işlemi için hem iki sayı hem de üç sayı toplayabilen metotlar tanımlayabiliriz. Bir restoran düşünün. Müşterilerden bazıları sadece menüden sipariş verirken, bazıları özel taleplerde bulunabilir. İşte bu, metot overloading gibidir.

Teknik açıdan:

```csharp
class HesapMakinesi
{
    public int Topla(int a, int b)
    {
        return a + b;
    }

    public int Topla(int a, int b, int c)
    {
        return a + b + c;
    }
}

// Kullanım
HesapMakinesi hesap = new HesapMakinesi();
Console.WriteLine(hesap.Topla(5, 10));       // Çıktı: 15
Console.WriteLine(hesap.Topla(5, 10, 15));   // Çıktı: 30
```

Burada:
- `Topla` metodu, farklı parametrelerle iki kez tanımlanmıştır.
- Derleyici, hangi metodun çağrılacağını parametrelerin sayısına ve türüne göre belirler.

---

#### **Abstract Sınıflar ve Metotlar**

##### **1. Abstract Sınıf Tanımlama ve Kullanımı**

Abstract sınıf, doğrudan nesne oluşturulamayan bir sınıftır. Ancak, diğer sınıflar tarafından miras alınabilir. Örneğin, bir "Şekil" sınıfı düşünelim. Bu sınıf, tüm şekiller için ortak bir şablon görevi görür. Ancak, bir "Şekil" nesnesi oluşturmak mümkün değildir. Türetilmiş sınıflar, bu şablonu genişletir. Bir pastane tarifini düşünün. Tarif, tüm pastalar için genel kuralları içerir, ancak bir "pastane tarifi" nesnesi yoktur.

Teknik açıdan:

```csharp
abstract class Sekil
{
    public abstract void Ciz(); // Abstract metot
}

class Daire : Sekil
{
    public override void Ciz()
    {
        Console.WriteLine("Daire çiziliyor.");
    }
}

class Kare : Sekil
{
    public override void Ciz()
    {
        Console.WriteLine("Kare çiziliyor.");
    }
}

// Kullanım
Sekil sekil1 = new Daire();
Sekil sekil2 = new Kare();

sekil1.Ciz(); // Çıktı: Daire çiziliyor.
sekil2.Ciz(); // Çıktı: Kare çiziliyor.
```

Burada:
- `Sekil` sınıfı, abstract bir sınıftır ve doğrudan nesne oluşturulamaz.
- `Ciz` metodu, abstract olarak tanımlanmıştır ve türetilmiş sınıflar tarafından uygulanmalıdır.

##### **2. Abstract Metotlar ve Implementasyon**

Abstract metotlar, içeriği olmayan metotlardır. Türetilmiş sınıflar, bu metotları zorunlu olarak uygulamalıdır. Örneğin, bir "Araba" sınıfı düşünelim. Tüm arabaların nasıl çalışacağını belirtmek yerine, her arabanın kendi çalışma şeklini tanımlamasını isteyebiliriz. Bir cep telefonu düşünün. Her modelin kendi fotoğraf çekme yöntemleri vardır. İşte bu, abstract metotlar gibidir.

Teknik açıdan:

```csharp
abstract class Araba
{
    public abstract void Calistir(); // Abstract metot
}

class Toyota : Araba
{
    public override void Calistir()
    {
        Console.WriteLine("Toyota çalışıyor.");
    }
}

class Honda : Araba
{
    public override void Calistir()
    {
        Console.WriteLine("Honda çalışıyor.");
    }
}

// Kullanım
Araba araba1 = new Toyota();
Araba araba2 = new Honda();

araba1.Calistir(); // Çıktı: Toyota çalışıyor.
araba2.Calistir(); // Çıktı: Honda çalışıyor.
```

Burada:
- `Calistir` metodu, abstract olarak tanımlanmıştır ve türetilmiş sınıflar tarafından uygulanmalıdır.

---


### 3.7. Abstraction (Soyutlama)

**Soyutlama**, bir nesnenin yalnızca gerekli özellikleri ve davranışlarını göstermek, geri kalanını gizlemek demektir. Örneğin, bir arabanın nasıl çalıştığını bilmek zorunda değilsiniz, sadece direksiyonu çevirmeniz yeterlidir. Bir kahve makinesi düşünelim. Makinenin içinde neler olduğunu bilmek zorunda değilsiniz, sadece butona basarak kahve alırsınız. İşte soyutlama, bu tür karmaşıklıkları gizleyerek kullanıcıya sadece gerekli olanları sunar.

Soyutlama sayesinde:
- Kodunuzu daha düzenli ve okunabilir hale getirebilirsiniz.
- Karmaşık sistemlerin işleyişini basitleştirebilirsiniz.
- Farklı sınıflar arasında ortak bir arayüz oluşturabilirsiniz.

Şimdi soyutlamanın en önemli bileşeni olan **Interface** kavramını inceleyelim: **Interface tanımlama ve implementasyon**, **Multiple interface implementasyonu**.

---

#### **Interface Kavramı ve Kullanımı**

##### **1. Interface Tanımlama ve Implementasyon**

**Interface**, bir sınıfın sahip olması gereken metotları tanımlar ancak bunların nasıl çalışacağını belirtmez. Bu, bir sözleşme gibidir. Örneğin, bir "IYazdir" interface'i düşünelim. Bu interface, bir sınıfın "Yazdir" metoduna sahip olmasını zorunlu kılar. Ancak, bu metodun nasıl çalışacağına interface karar vermez. Bir cep telefonu düşünün. Her modelin fotoğraf çekme yöntemleri farklıdır, ancak hepsi fotoğraflar çekebilir. İşte bu, interface kullanımı gibi çalışır.

Teknik açıdan:

```csharp
interface IYazdir
{
    void Yazdir();
}

class Rapor : IYazdir
{
    public void Yazdir()
    {
        Console.WriteLine("Rapor yazdırılıyor.");
    }
}

class Resim : IYazdir
{
    public void Yazdir()
    {
        Console.WriteLine("Resim yazdırılıyor.");
    }
}

// Kullanım
IYazdir rapor = new Rapor();
IYazdir resim = new Resim();

rapor.Yazdir(); // Çıktı: Rapor yazdırılıyor.
resim.Yazdir(); // Çıktı: Resim yazdırılıyor.
```

Burada:
- `IYazdir` interface'i, bir sınıfın `Yazdir` metoduna sahip olmasını zorunlu kılar.
- `Rapor` ve `Resim` sınıfları, `IYazdir` interface'ini uygular ve `Yazdir` metodunu kendi ihtiyaçlarına göre tanımlar.

##### **2. Multiple Interface Implementasyonu**

Bir sınıf, birden fazla interface'i uygulayabilir. Bu, bir sınıfın farklı rolleri üstlenmesine olanak tanır. Örneğin, bir "UcanAraba" sınıfı hem "IYolculuk" hem de "IUcus" interface'lerini uygulayabilir. Bir cep telefonu düşünelim. Aynı anda hem fotoğraf çekebilir hem de müzik çalabilir. İşte bu, multiple interface implementasyonu gibidir.

Teknik açıdan:

```csharp
interface IYolculuk
{
    void Sur();
}

interface IUcus
{
    void Uc();
}

class UcanAraba : IYolculuk, IUcus
{
    public void Sur()
    {
        Console.WriteLine("Araba sürülüyor.");
    }

    public void Uc()
    {
        Console.WriteLine("Araba uçuyor.");
    }
}

// Kullanım
UcanAraba ucabilirAraba = new UcanAraba();
ucabilirAraba.Sur(); // Çıktı: Araba sürülüyor.
ucabilirAraba.Uc();  // Çıktı: Araba uçuyor.
```

Burada:
- `UcanAraba` sınıfı, hem `IYolculuk` hem de `IUcus` interface'lerini uygular.
- Her interface'in metodlarını kendi içinde tanımlar.

---


### Püf Noktalar:

1. Sınıf ve ve nesne birbirinden farklı iki kavramdır. Sınıf bir şablondur, nesne ise bu şablonun somut bir örneğidir. Örneğin, "Araba" sınıfı bir şablondur, "Toyota Corolla" ise bir nesnedir. Yani, tarifi yazmakla pastayı yapmak arasındaki fark gibi düşünebilirsiniz.

2. Erişim belirleyicilerini dikkate alarak kullanın. Hassas verilere izinsiz erişimi önlemek için `private` veya `protected` kullanmayı unutmayın. Özellikle bir banka hesabı uygulaması yazıyorsanız, bakiyeyi herkese açık bırakmak istemezsiniz, değil mi?

3. Kodlarınızı modüler tutun. Büyük projelerde, her şeyi bir sınıfa sıkıştırmak yerine işlevleri farklı sınıflara bölün. Örneğin, bir oyun geliştirdiğinizde, oyuncu karakteri için bir sınıf, düşmanlar için başka bir sınıf oluşturabilirsiniz. Böylece hem kodunuzu daha kolay yönetirsiniz hem de bir sorun olduğunda nerede arayacağınızı bilirsiniz.

4. Bir kez yazdığınız kodu tekrar tekrar kullanabilirsiniz. Örneğin, bir "Kullanıcı" sınıfı oluşturduktan sonra, ondan yüzlerce kullanıcı nesnesi üretebilirsiniz. Bu, hem zaman kazandırır hem de kodunuzu daha temiz tutar.

5. Büyük projelerde değişiklik yapmak zor olabilir. Ancak OOP ile kodunuzu düzenli tutarsanız, değişiklikleri daha kolay uygulayabilirsiniz. Örneğin, bir e-ticaret sitesinde ürün eklemek için bir sınıf oluşturduysanız, ileride yeni bir özellik eklemek çok daha kolay olacaktır.

6. Eğer bir sınıf için constructor tanımlamazsanız, C# otomatik olarak varsayılan bir constructor oluşturur. Ancak, en az bir constructor tanımladığınızda bu otomatik davranış devre dışı kalır.

7. Parametreli constructor'lar, nesneleri daha özelleştirilmiş bir şekilde oluşturmanıza olanak tanır. Özellikle karmaşık projelerde bu, kodunuzu daha esnek hale getirir.

8. Birden fazla constructor tanımlayarak, farklı senaryolara uygun nesneler oluşturabilirsiniz. Ancak, her constructor'ın amacını net bir şekilde belirtmek önemlidir.

9. Destructor'lar, nesne yok edilmeden önce son işlemlerin yapılmasını sağlar. Ancak, modern programlamada garbage collector genellikle yeterlidir. Destructor'ları yalnızca özel durumlarda kullanın.

10. Bellek yönetimi için garbage collector'a güvenmek en iyisidir. Manuel müdahale, programın performansını olumsuz etkileyebilir.

11. Veriye doğrudan erişimi engellemek için getter ve setter metotlarını kullanın. Özellikle hassas verilerde (örneğin bakiye) bu yöntem çok önemlidir.

12. Properties, getter ve setter metotlarına göre daha kısa ve okunabilir bir alternatiftir. Ayrıca, auto-implemented properties ile kodunuzu daha temiz tutabilirsiniz.

13. Hassas verileri private olarak tanımlayın ve sadece kontrollü bir şekilde erişime izin verin. Bu, kodunuzu daha güvenli hale getirir.

14. Bazı durumlarda bir özelliğe sadece okuma veya sadece yazma izni vermek isteyebilirsiniz. Örneğin, üretim yılı gibi değişmemesi gereken veriler için read-only property kullanabilirsiniz.

15. Temel sınıf, genel özellikleri içerir. Türetilmiş sınıf, bu özellikleri genişletir veya özelleştirir. Örneğin, bir "Hayvan" sınıfından miras alan "Kedi" sınıfı, kendine özgü bir miyavlama davranışı ekleyebilir.

16. Türetilmiş sınıf, temel sınıfın constructor'ını veya metotlarını çağırabilir. Özellikle constructor'larda base kullanımı önemlidir.

17. C#, bir sınıfın sadece tek bir sınıftan miras almasına izin verir. Bu, çoklu kalıtım sorunlarına yol açabilir.

18. Interface, bir sınıfın sahip olması gereken metotları tanımlar. Birden fazla interface uygulanabilir. Örneğin, bir "Uçan Araba" sınıfı hem "IYolculuk" hem de "IUcus" interface'lerini uygulayabilir.

19. Temel sınıftaki bir metodun davranışını, türetilmiş sınıfta override anahtar kelimesiyle değiştirebilirsiniz. Özellikle virtual ve override kullanımı önemlidir.

20. Aynı isme sahip ancak farklı parametrelere sahip metotlar tanımlayabilirsiniz. Derleyici, hangi metodun çağrılacağını parametrelerin sayısına ve türüne göre belirler.

21. Abstract sınıflar, doğrudan nesne oluşturulamaz. Ancak, ortak bir şablon görevi görür ve türetilmiş sınıflar tarafından genişletilir.

22. Abstract metotlar, içeriği olmayan metotlardır. Türetilmiş sınıflar, bu metotları zorunlu olarak uygulamalıdır.

23. Interface, bir sınıfın sahip olması gereken metotları tanımlar. Ancak, bu metodların nasıl çalışacağına interface karar vermez.

24. Bir sınıf, birden fazla interface'i uygulayabilir. Bu, bir sınıfın farklı rolleri üstlenmesine olanak tanır.

25. Abstract sınıflar, kısmi bir uygulama sağlayabilir. Ancak interface'ler tamamen soyuttur ve hiçbir uygulama içermez.

26. Interface'ler, kodunuzu daha esnek hale getirir. Örneğin, bir sınıf birden fazla interface'i uygulayarak farklı senaryolarda farklı roller üstlenebilir.