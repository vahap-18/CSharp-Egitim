
## 5. Dosya ve Veri İşlemleri

### 5.1. Dosya İşlemleri

#### 1. Dosya ve Dizin Yönetimi

Dosya ve dizin yönetimi, bir bilgisayar sisteminde verileri düzenli bir şekilde saklamak ve işlemek için kritik öneme sahiptir. Günlük hayatta bir evi düşünelim. Evdeki odalar, dolaplar ve çekmeceler, dosyaları ve dizinleri temsil eder. İşte bu, `File` ve `Directory` sınıflarının çalışma mantığı gibidir.

###### **`File` ve `Directory` Sınıfları**

- **`File`:** Tek bir dosya üzerinde işlem yapmak için kullanılır.
- **`Directory`:** Bir dizin (klasör) üzerinde işlem yapmak için kullanılır.

Bu sınıflar, dosya ve dizin işlemleri için hazır metotlar sağlar. Örneğin:
- Dosya oluşturmak (`File.Create`),
- Dizin silmek (`Directory.Delete`),
- Dosya boyutunu okumak (`FileInfo.Length`) gibi işlemler yapılır.

---

##### 2. Dosya ve Dizin Oluşturma, Silme, Taşıma, Kopyalama

###### **Dosya Oluşturma**
Bir dosya oluşturmak için `File.Create` metodu kullanılır. Günlük hayatta bir not defteri açmak gibi düşünebilirsiniz.

```csharp
using System;
using System.IO;

class Program
{
    static void Main()
    {
        string dosyaYolu = @"C:\Ornek\ornek.txt";

        // Dosya oluştur
        File.Create(dosyaYolu).Close(); // Close() ile akışı kapat
        Console.WriteLine("Dosya oluşturuldu.");
    }
}
```

Burada:
- `File.Create`, belirtilen yolda yeni bir dosya oluşturur.
- `Close()` ile dosya akışı kapatılır.

---

###### **Dizin Oluşturma**
Bir dizin oluşturmak için `Directory.CreateDirectory` metodu kullanılır. Günlük hayatta bir çekmece açmak gibi düşünebilirsiniz.

```csharp
string dizinYolu = @"C:\Ornek\YeniKlasor";

// Dizin oluştur
Directory.CreateDirectory(dizinYolu);
Console.WriteLine("Dizin oluşturuldu.");
```

---

###### **Dosya ve Dizin Silme**
Bir dosya veya dizini silmek için `File.Delete` veya `Directory.Delete` metotları kullanılır. Günlük hayatta bir kağıdı çöpe atmak veya bir çekmeceyi boşaltmak gibi düşünebilirsiniz.

```csharp
// Dosya sil
File.Delete(@"C:\Ornek\ornek.txt");
Console.WriteLine("Dosya silindi.");

// Dizin sil
Directory.Delete(@"C:\Ornek\YeniKlasor");
Console.WriteLine("Dizin silindi.");
```

---

###### **Dosya ve Dizin Taşıma**
Bir dosya veya dizini taşımak için `File.Move` veya `Directory.Move` metotları kullanılır. Günlük hayatta bir kitabı başka bir rafta saklamak gibi düşünebilirsiniz.

```csharp
// Dosya taşı
File.Move(@"C:\Ornek\ornek.txt", @"C:\Ornek\Tasinan\ornek.txt");
Console.WriteLine("Dosya taşındı.");

// Dizin taşı
Directory.Move(@"C:\Ornek\EskiKlasor", @"C:\Ornek\YeniKlasor");
Console.WriteLine("Dizin taşındı.");
```

---

###### **Dosya ve Dizin Kopyalama**
Bir dosya veya dizini kopyalamak için `File.Copy` veya `DirectoryCopy` metotları kullanılır. Günlük hayatta bir belgenin fotokopisini çıkarmak gibi düşünebilirsiniz.

```csharp
// Dosya kopyala
File.Copy(@"C:\Ornek\ornek.txt", @"C:\Ornek\Kopya\ornek_kopya.txt");
Console.WriteLine("Dosya kopyalandı.");

// Dizin kopyala (manuel olarak yapılmalıdır)
void DizinKopyala(string kaynak, string hedef)
{
    Directory.CreateDirectory(hedef);
    foreach (var dosya in Directory.GetFiles(kaynak))
    {
        File.Copy(dosya, Path.Combine(hedef, Path.GetFileName(dosya)));
    }
}

DizinKopyala(@"C:\Ornek\EskiKlasor", @"C:\Ornek\YeniKlasor");
Console.WriteLine("Dizin kopyalandı.");
```

---

##### 3. Dosya ve Dizin Özelliklerini Okuma

Dosya ve dizinlerin özelliklerini okumak için `FileInfo` ve `DirectoryInfo` sınıfları kullanılır. Günlük hayatta bir kitabın sayfa sayısını veya baskı tarihini kontrol etmek gibi düşünebilirsiniz.

###### **Dosya Özellikleri**
```csharp
string dosyaYolu = @"C:\Ornek\ornek.txt";

// Dosya bilgilerini oku
FileInfo fileInfo = new FileInfo(dosyaYolu);

Console.WriteLine($"Dosya Adı: {fileInfo.Name}");
Console.WriteLine($"Oluşturulma Tarihi: {fileInfo.CreationTime}");
Console.WriteLine($"Boyut: {fileInfo.Length} byte");
```

---

###### **Dizin Özellikleri**
```csharp
string dizinYolu = @"C:\Ornek";

// Dizin bilgilerini oku
DirectoryInfo directoryInfo = new DirectoryInfo(dizinYolu);

Console.WriteLine($"Dizin Adı: {directoryInfo.Name}");
Console.WriteLine($"Oluşturulma Tarihi: {directoryInfo.CreationTime}");
Console.WriteLine($"Alt Dizin Sayısı: {directoryInfo.GetDirectories().Length}");
Console.WriteLine($"Dosya Sayısı: {directoryInfo.GetFiles().Length}");
```

---

#### 2. Dosya Okuma ve Yazma

##### **1. `StreamReader` ve `StreamWriter` Sınıfları**

`StreamReader` ve `StreamWriter`, metin tabanlı dosyalarla çalışmak için kullanılan sınıflardır. Günlük hayatta bir not defteri düşünelim. İçindeki metinleri okumak veya yeni notlar eklemek için bu sınıfları kullanabilirsiniz.

###### **Dosyadan Okuma (`StreamReader`)**
`StreamReader`, bir dosyadan metin okumak için kullanılır. Örneğin, bir log dosyasının içeriğini okuyabilirsiniz.

```csharp
using System;
using System.IO;

class Program
{
    static void Main()
    {
        string dosyaYolu = @"C:\Ornek\ornek.txt";

        // Dosyadan oku
        using (StreamReader reader = new StreamReader(dosyaYolu))
        {
            string satir;
            while ((satir = reader.ReadLine()) != null)
            {
                Console.WriteLine(satir);
            }
        }
    }
}
```

Burada:
- `StreamReader`, dosyadan satır satır okuma yapar.
- `ReadLine`, her seferinde bir satır okur ve sonuna kadar devam eder.

---

###### **Dosyaya Yazma (`StreamWriter`)**
`StreamWriter`, bir dosyaya metin yazmak için kullanılır. Örneğin, bir kullanıcıdan alınan verileri bir dosyaya kaydedebilirsiniz.

```csharp
using System;
using System.IO;

class Program
{
    static void Main()
    {
        string dosyaYolu = @"C:\Ornek\ornek.txt";

        // Dosyaya yaz
        using (StreamWriter writer = new StreamWriter(dosyaYolu))
        {
            writer.WriteLine("Merhaba, Dünya!");
            writer.WriteLine("Bu bir test yazısıdır.");
        }

        Console.WriteLine("Dosyaya yazıldı.");
    }
}
```

Burada:
- `StreamWriter`, dosyaya metin yazar.
- `WriteLine`, her seferinde bir satır ekler.

---

##### **2. Dosyadan Satır Satır Okuma ve Yazma**

Satır satır okuma ve yazma işlemleri, özellikle büyük dosyalarla çalışırken çok faydalıdır. Günlük hayatta bir kitap düşünün. Her sayfayı tek tek okuyup işlemek gibidir.

###### **Örnek: Bir Dosyayı Okuyup Başka Bir Dosyaya Kopyalama**

```csharp
string kaynakDosya = @"C:\Ornek\kaynak.txt";
string hedefDosya = @"C:\Ornek\hedef.txt";

// Kaynak dosyadan oku ve hedef dosyaya yaz
using (StreamReader reader = new StreamReader(kaynakDosya))
using (StreamWriter writer = new StreamWriter(hedefDosya))
{
    string satir;
    while ((satir = reader.ReadLine()) != null)
    {
        writer.WriteLine(satir); // Her satırı hedef dosyaya yaz
    }
}

Console.WriteLine("Dosya kopyalandı.");
```

Burada:
- `StreamReader`, kaynak dosyadan satır satır okur.
- `StreamWriter`, hedef dosyaya satır satır yazar.

---

##### **3. Binary Dosyalarla Çalışma (`BinaryReader` ve `BinaryWriter`)**

Metin tabanlı dosyalar yerine, binary (ikili) dosyalarla çalışmak için `BinaryReader` ve `BinaryWriter` sınıfları kullanılır. Günlük hayatta bir resim dosyasını veya bir videoyu düşünelim. Bu dosyaların içindeki veriler ikili formatta saklanır.

###### **Binary Dosyaya Yazma (`BinaryWriter`)**
`BinaryWriter`, binary dosyalara veri yazmak için kullanılır. Örneğin, bir oyunun kaydetme dosyasını oluşturabilirsiniz.

```csharp
using System;
using System.IO;

class Program
{
    static void Main()
    {
        string dosyaYolu = @"C:\Ornek\binary.dat";

        // Binary dosyaya yaz
        using (BinaryWriter writer = new BinaryWriter(File.Open(dosyaYolu, FileMode.Create)))
        {
            writer.Write(42);               // Tam sayı yaz
            writer.Write("Merhaba");        // Metin yaz
            writer.Write(3.14);             // Ondalık sayı yaz
        }

        Console.WriteLine("Binary dosyaya yazıldı.");
    }
}
```

Burada:
- `BinaryWriter`, farklı veri türlerini binary formatında yazar.

---

###### **Binary Dosyadan Okuma (`BinaryReader`)**
`BinaryReader`, binary dosyalardan veri okumak için kullanılır. Örneğin, bir oyunun kaydetme dosyasından veri alabilirsiniz.

```csharp
using System;
using System.IO;

class Program
{
    static void Main()
    {
        string dosyaYolu = @"C:\Ornek\binary.dat";

        // Binary dosyadan oku
        using (BinaryReader reader = new BinaryReader(File.Open(dosyaYolu, FileMode.Open)))
        {
            int sayi = reader.ReadInt32();          // Tam sayı oku
            string metin = reader.ReadString();     // Metin oku
            double ondalik = reader.ReadDouble();   // Ondalık sayı oku

            Console.WriteLine($"Okunan değerler: {sayi}, {metin}, {ondalik}");
        }
    }
}
```

Burada:
- `BinaryReader`, binary dosyadan farklı veri türlerini okur.

---


#### 3. Dosya Akışları (Streams)

##### **1. `FileStream` Kullanımı**

`FileStream`, dosyalarla düşük seviyeli işlemler yapmak için kullanılır. Örneğin, bir metin dosyasından veri okumak veya bir resim dosyasına veri yazmak için idealdir.

```csharp
using System;
using System.IO;

class Program
{
    static void Main()
    {
        string dosyaYolu = @"C:\Ornek\ornek.txt"; // Okunacak dosyanın yolu

        // FileStream ile dosyadan okuma işlemi yapılır
        using (FileStream fileStream = new FileStream(dosyaYolu, FileMode.Open, FileAccess.Read))
        {
            byte[] buffer = new byte[1024]; // 1 KB'lık bir tampon oluşturulur
            int bytesRead; // Okunan byte sayısını tutar

            // Dosyadan veri okuma döngüsü
            while ((bytesRead = fileStream.Read(buffer, 0, buffer.Length)) > 0)
            {
                // Okunan byte sayısı ekrana yazdırılır
                Console.WriteLine($"Okunan byte sayısı: {bytesRead}");

                // Byte dizisi metne dönüştürülür ve ekrana yazdırılır
                Console.WriteLine(System.Text.Encoding.UTF8.GetString(buffer, 0, bytesRead));
            }
        }
    }
}
```

Bu kod, bir dosyadan byte olarak veri okur. `FileStream` ile dosya açılır ve `buffer` adlı bir byte dizisiyle veriler okunur. Her seferinde en fazla 1 KB veri okunur ve bu veriler metne dönüştürülerek ekrana yazdırılır.

---

##### **Dosyaya Yazma**

`FileStream` ayrıca dosyalara veri yazmak için de kullanılabilir. Örneğin, bir metni dosyaya kaydetmek için aşağıdaki kodu kullanabilirsiniz.

```csharp
using System;
using System.IO;
using System.Text;

class Program
{
    static void Main()
    {
        string dosyaYolu = @"C:\Ornek\ornek.txt"; // Yazılacak dosyanın yolu
        string metin = "Merhaba, Dünya!"; // Yazılacak metin

        // FileStream ile dosyaya yazma işlemi yapılır
        using (FileStream fileStream = new FileStream(dosyaYolu, FileMode.Create, FileAccess.Write))
        {
            byte[] data = Encoding.UTF8.GetBytes(metin); // Metin byte dizisine dönüştürülür
            fileStream.Write(data, 0, data.Length); // Byte dizisi dosyaya yazılır
        }

        Console.WriteLine("Dosyaya yazıldı.");
    }
}
```

Burada, `FileMode.Create` ile dosya oluşturulur veya mevcut dosya üzerine yazılır. `Encoding.UTF8.GetBytes` ile metin byte dizisine dönüştürülür ve `fileStream.Write` ile dosyaya yazılır.

---

##### **2. `MemoryStream` ve `BufferedStream`**

###### **`MemoryStream`**

`MemoryStream`, bellekte bir akış oluşturur. Özellikle küçük verilerle çalışırken veya fiziksel bir dosya kullanmadan veri işleme yaparken faydalıdır.

```csharp
using System;
using System.IO;
using System.Text;

class Program
{
    static void Main()
    {
        string metin = "Merhaba, Dünya!"; // Belleğe yazılacak metin
        byte[] data = Encoding.UTF8.GetBytes(metin); // Metin byte dizisine dönüştürülür

        // MemoryStream ile bellekte işlem yapılır
        using (MemoryStream memoryStream = new MemoryStream())
        {
            memoryStream.Write(data, 0, data.Length); // Byte dizisi belleğe yazılır
            memoryStream.Position = 0; // Akışı başa sarar

            byte[] buffer = new byte[memoryStream.Length]; // Bellekten okuma için bir buffer oluşturulur
            memoryStream.Read(buffer, 0, buffer.Length); // Bellekten byte dizisi okunur

            Console.WriteLine(Encoding.UTF8.GetString(buffer)); // Byte dizisi metne dönüştürülür ve yazdırılır
        }
    }
}
```

Bu kod, bellekte bir akış oluşturur ve verileri belleğe yazar. Daha sonra akış başa sarılır ve bellekten okunan veriler ekrana yazdırılır. Fiziksel bir dosya kullanılmaz.

---

###### **`BufferedStream`**

`BufferedStream`, bir akışın performansını artırmak için kullanılır. Özellikle büyük dosyalarla çalışırken, veriler tamponlanarak dosya işlemleri hızlandırılır.

```csharp
using System;
using System.IO;

class Program
{
    static void Main()
    {
        string dosyaYolu = @"C:\Ornek\ornek.txt"; // İşlenecek dosyanın yolu

        // BufferedStream ile performans optimizasyonu yapılır
        using (FileStream fileStream = new FileStream(dosyaYolu, FileMode.OpenOrCreate, FileAccess.ReadWrite))
        using (BufferedStream bufferedStream = new BufferedStream(fileStream))
        {
            byte[] data = new byte[1024]; // 1 KB'lık bir tampon oluşturulur
            bufferedStream.Write(data, 0, data.Length); // Veriler tampona yazılır
            bufferedStream.Flush(); // Tampon boşaltılır ve veriler dosyaya yazılır
        }

        Console.WriteLine("Dosyaya yazıldı.");
    }
}
```

Bu kodda, `BufferedStream` ile veriler önce tampona yazılır ve daha sonra `Flush` ile dosyaya aktarılır. Bu, özellikle büyük dosyalarla çalışırken performansı artırır.

---

##### **3. Asenkron Dosya İşlemleri (`async` ve `await` ile)**

Asenkron işlemler, zaman alan dosya okuma veya yazma işlemlerini engellemeden gerçekleştirmek için kullanılır. Özellikle büyük dosyalarla çalışırken kullanıcı arayüzünün donmasını önler.

```csharp
using System;
using System.IO;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        string dosyaYolu = @"C:\Ornek\ornek.txt"; // Okunacak dosyanın yolu

        // StreamReader ile asenkron dosya okuma yapılır
        using (StreamReader reader = new StreamReader(dosyaYolu))
        {
            string satir;

            // Dosyadan satır satır asenkron okuma yapılır
            while ((satir = await reader.ReadLineAsync()) != null)
            {
                Console.WriteLine(satir); // Okunan satır ekrana yazdırılır
            }
        }
    }
}
```

Bu kod, bir dosyayı asenkron olarak okur. `await reader.ReadLineAsync` ile her satır asenkron olarak okunur ve ekrana yazdırılır. Programın diğer kısımları çalışmaya devam eder.

---

```csharp
using System;
using System.IO;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        string dosyaYolu = @"C:\Ornek\ornek.txt"; // Yazılacak dosyanın yolu

        // StreamWriter ile asenkron dosya yazma yapılır
        using (StreamWriter writer = new StreamWriter(dosyaYolu))
        {
            await writer.WriteLineAsync("Merhaba, Dünya!"); // Asenkron olarak bir satır yazılır
            await writer.WriteLineAsync("Bu bir test yazısıdır."); // Başka bir satır yazılır
        }

        Console.WriteLine("Dosyaya yazıldı.");
    }
}
```

Bu kod, bir dosyaya asenkron olarak veri yazar. `await writer.WriteLineAsync` ile her satır asenkron olarak yazılır ve programın diğer kısımları çalışmaya devam eder.

---

#### Püf Noktalar
1. `File` sınıfı, tek bir dosya üzerinde işlem yaparken `Directory` sınıfı, bir dizin üzerinde işlem yapar. Bu sınıfların statik metotları kullanımı kolaylaştırır.
2. `File.Create` gibi metotlar dosya akışlarını açabilir, bu nedenle işlem tamamlandıktan sonra akışları `Close()` ile mutlaka kapatmalısınız.
3. Dosya veya dizin işlemleri sırasında hatalar oluşabileceğinden (örneğin dosya mevcut değilse), `try-catch` bloklarını kullanarak bu hataları yakalayın ve kullanıcıya anlamlı geri bildirimler verin.
4. `Path` sınıfı, dosya yollarıyla ilgili işlemler için çok faydalıdır. Örneğin, `Path.Combine` ile yolları birleştirirken platformdan bağımsız bir şekilde çalışabilirsiniz.
5. Dosya işlemleri sırasında oluşan hataları loglama mekanizmalarıyla kaydederek, ileride sorunları analiz etmek için gerekli bilgilere ulaşabilirsiniz.
6. Büyük dosya veya dizin işlemleri sırasında performans düşebilir. Özellikle büyük verilerle çalışıyorsanız asenkron programlama tekniklerini (`async/await`) kullanmayı tercih edebilirsiniz.
7. Dosya ve dizin taşırken veya kopyalarken hedef yolun var olup olmadığını kontrol edin. Eğer hedefte aynı isimde bir dosya varsa üzerine yazma veya farklı bir isimle kaydetme seçeneği sunabilirsiniz.
8. Dizinleri kopyalarken içindeki tüm dosyaları ve alt dizinleri de içerecek şekilde manuel bir yöntem geliştirin, çünkü `Directory` sınıfı doğrudan bu özelliği desteklemez.
9. Dosya veya dizin özelliklerini okurken `FileInfo` ve `DirectoryInfo` sınıflarını kullanmak, daha detaylı bilgi almanızı sağlar.
10. Güvenlik açısından hassas dosyalara erişim izinlerini kontrol edin ve yetkisiz erişimlerden kaçının. Özellikle üretim ortamlarında bu tür kontroller önemlidir.
11. Dosya işlemleri sırasında geçici dosyalar oluşturuyorsanız, bu dosyaları işlemin sonunda otomatik olarak silmek için `using` ifadesi veya benzeri temizleme mekanizmaları kullanın.
12. `StreamReader` ve `StreamWriter`, metin tabanlı dosyalarla çalışmak için idealdir. Özellikle log dosyaları veya basit metin dosyaları için tercih edilir.
13. `BinaryReader` ve `BinaryWriter`, binary dosyalarla çalışmak için kullanılır. Özellikle görsel, ses veya video gibi ikili verilerle çalışırken faydalıdır.
14. Büyük dosyalarla çalışırken satır satır okuma (`ReadLine`) veya yazma (`WriteLine`) işlemleri, bellek kullanımını optimize eder.
15. `using` ifadesi, dosya akışlarını otomatik olarak kapatır ve kaynak sızıntılarını önler.
16. Binary dosyalarda veri sırası önemlidir. Örneğin, önce bir tam sayı yazdıysanız, okurken de aynı sırayla okumalısınız.
17. Dosya işlemleri sırasında hatalar oluşabileceğinden (`FileNotFoundException`, `IOException` vb.), `try-catch` bloklarını kullanmayı unutmayın.
18. Binary dosyalar, insan tarafından okunamaz. Bu nedenle, hassas verileri saklamak için güvenli bir seçenektir.
19. Performans açısından, binary dosyalar genellikle daha hızlıdır çünkü veriler sıkıştırılmış veya ham formatta saklanır.
20. `FileStream`, özellikle binary dosyalarla çalışırken tercih edilir. Verileri byte düzeyinde okuyup yazabilirsiniz.
21. `MemoryStream`, bellekte bir akış oluşturur ve fiziksel dosya kullanmadan veri işlemenizi sağlar. Küçük veriler için idealdir.
22. `BufferedStream`, verileri tamponlayarak dosya işlemlerinin performansını artırır. Büyük dosyalarla çalışırken faydalıdır.
23. Asenkron işlemler, özellikle büyük dosyalar veya ağ işlemleri gibi zaman alan işlemlerde kullanıcı deneyimini iyileştirir. `async` ve `await` anahtar kelimeleriyle kolayca uygulanabilir.
24. `using` ifadesi, dosya akışlarını otomatik olarak kapatır ve kaynak sızıntılarını önler. Bu nedenle her zaman kullanmanız önerilir.
25. Tampon boyutunu optimize etmek, özellikle büyük dosyalarla çalışırken performansı artırır. Örneğin, 1 KB yerine 4 KB veya 8 KB'lık tamponlar kullanabilirsiniz.
- Hataları yakalamak için `try-catch` bloklarını kullanmayı unutmayın. Özellikle dosya işlemleri sırasında hatalar oluşabileceğinden, bu tür kontroller önemlidir.


---


### 5.2. Veri Serileştirme

#### 1. JSON Serileştirme ve Deserileştirme

##### 1.1. JSON Nedir ve Neden Kullanılır?

JSON (JavaScript Object Notation), verileri depolamak ve aktarmak için kullanılan metin tabanlı bir formattır. Günlük hayatta bir alışveriş listesini düşünelim; bu listeyi dijital olarak saklamak veya başka bir kişiyle paylaşmak için JSON formatı idealdir. Örneğin:

```json
{
  "Ad": "Ali",
  "Yas": 25,
  "Meslek": "Mühendis"
}
```

Bu JSON verisi, bir kişinin adını, yaşını ve mesleğini temsil eder. JSON yaygın olarak kullanılır çünkü platform bağımsızdır, hafif ve basittir. Ayrıca web API'leri, mobil uygulamalar ve veritabanları gibi birçok alanda veri alışverişi için tercih edilir.

---

##### 1.2. `System.Text.Json` Kütüphanesi

.NET'in yerleşik JSON işleme kütüphanesi olan `System.Text.Json`, hızlı, güvenilir ve performans odaklıdır. Daha önce yaygın olarak kullanılan `Newtonsoft.Json` kütüphanesine göre daha modern bir yaklaşıma sahiptir. Özellikle .NET Core ve .NET 5+ sürümlerinde tercih edilir çünkü yüksek performans gerektiren senaryolarda hız sağlar, otomatik olarak güvenli varsayılan ayarlara sahiptir ve kullanımı oldukça kolaydır.

---

##### 1.3. JSON Verilerini Nesnelere Dönüştürme ve Tersi

JSON verilerini C# nesnelerine dönüştürmek için deserileştirme, C# nesnelerini JSON verilerine dönüştürmek için ise serileştirme yapılır. Bu işlemler özellikle veri alışverişi ve kalıcı veri depolama işlemleri için çok önemlidir.

###### **Örnek: JSON Verisini Nesneye Dönüştürme (Deserileştirme)**

```csharp
using System;
using System.Text.Json;

class Program
{
    static void Main()
    {
        // JSON verisi bir kişinin bilgilerini içeriyor
        string json = "{ \"Ad\": \"Ali\", \"Yas\": 25, \"Meslek\": \"Mühendis\" }";

        // JSON verisini C# nesnesine dönüştürüyoruz
        Kisi kisi = JsonSerializer.Deserialize<Kisi>(json);

        // Dönüştürülen nesnenin özellikleri ekrana yazdırılıyor
        Console.WriteLine($"Ad: {kisi.Ad}, Yaş: {kisi.Yas}, Meslek: {kisi.Meslek}");
    }
}

// JSON verisini temsil eden sınıf
class Kisi
{
    public string Ad { get; set; }
    public int Yas { get; set; }
    public string Meslek { get; set; }
}
```

Burada JSON verisi, `Kisi` sınıfına dönüştürülür. `JsonSerializer.Deserialize<Kisi>(json)` metodu, JSON verisini C# nesnesine çevirir ve ardından nesnenin özellikleri ekrana yazdırılır.

---

###### **Örnek: Nesneyi JSON Verisine Dönüştürme (Serileştirme)**

```csharp
using System;
using System.Text.Json;

class Program
{
    static void Main()
    {
        // C# nesnesi bir kişinin bilgilerini içeriyor
        Kisi kisi = new Kisi { Ad = "Ayşe", Yas = 30, Meslek = "Doktor" };

        // Nesneyi JSON verisine dönüştürüyoruz
        string json = JsonSerializer.Serialize(kisi);

        // JSON çıktısı ekrana yazdırılıyor
        Console.WriteLine(json); // Çıktı: {"Ad":"Ayşe","Yas":30,"Meslek":"Doktor"}
    }
}

// JSON verisini temsil eden sınıf
class Kisi
{
    public string Ad { get; set; }
    public int Yas { get; set; }
    public string Meslek { get; set; }
}
```

Bu örnekte `Kisi` sınıfından bir nesne oluşturulur ve `JsonSerializer.Serialize(kisi)` metoduyla JSON formatına dönüştürülür. Elde edilen JSON çıktısı ekrana yazdırılır.

---

##### 1.4. JSON Verilerini Dosyaya Yazma ve Dosyadan Okuma

JSON verilerini dosyaya yazmak veya dosyadan okumak özellikle kalıcı veri depolama işlemleri için faydalıdır. Örneğin, bir telefon rehberini JSON formatında bir dosyada saklayabilirsiniz.

###### **Örnek: JSON Verisini Dosyaya Yazma**

```csharp
using System;
using System.IO;
using System.Text.Json;

class Program
{
    static void Main()
    {
        // C# nesnesi bir kişinin bilgilerini içeriyor
        Kisi kisi = new Kisi { Ad = "Mehmet", Yas = 40, Meslek = "Öğretmen" };

        // JSON dosyasının yolu belirleniyor
        string dosyaYolu = @"C:\Ornek\kisi.json";

        // Nesneyi JSON verisine dönüştürüyoruz
        string json = JsonSerializer.Serialize(kisi);

        // JSON verisini dosyaya yazıyoruz
        File.WriteAllText(dosyaYolu, json);

        Console.WriteLine("JSON verisi dosyaya yazıldı.");
    }
}

// JSON verisini temsil eden sınıf
class Kisi
{
    public string Ad { get; set; }
    public int Yas { get; set; }
    public string Meslek { get; set; }
}
```

Bu kodda `Kisi` sınıfından bir nesne oluşturulur, JSON formatına dönüştürülür ve `File.WriteAllText` metoduyla belirtilen dosyaya yazılır. Böylece veri kalıcı olarak saklanmış olur.

---

###### **Örnek: JSON Verisini Dosyadan Okuma**

```csharp
using System;
using System.IO;
using System.Text.Json;

class Program
{
    static void Main()
    {
        // JSON dosyasının yolu belirleniyor
        string dosyaYolu = @"C:\Ornek\kisi.json";

        // Dosyadan JSON verisini okuyoruz
        string json = File.ReadAllText(dosyaYolu);

        // JSON verisini nesneye dönüştürüyoruz
        Kisi kisi = JsonSerializer.Deserialize<Kisi>(json);

        // Dönüştürülen nesnenin özellikleri ekrana yazdırılıyor
        Console.WriteLine($"Ad: {kisi.Ad}, Yaş: {kisi.Yas}, Meslek: {kisi.Meslek}");
    }
}

// JSON verisini temsil eden sınıf
class Kisi
{
    public string Ad { get; set; }
    public int Yas { get; set; }
    public string Meslek { get; set; }
}
```

Bu örnekte `File.ReadAllText` metoduyla JSON verisi dosyadan okunur, `JsonSerializer.Deserialize<Kisi>(json)` metoduyla C# nesnesine dönüştürülür ve ardından nesnenin özellikleri ekrana yazdırılır.

---


#### 2. XML Serileştirme ve Deserileştirme

##### 2.1. XML Nedir ve Neden Kullanılır?

**XML (eXtensible Markup Language)**, verileri yapılandırılmış bir şekilde depolamak ve aktarmak için kullanılan bir metin tabanlı formattır. Günlük hayatta bir alışveriş listesini düşünelim. Bu listeyi dijital olarak saklamak veya başka bir kişiyle paylaşmak için XML formatı kullanılabilir. Örneğin:

```xml
<Kisi>
  <Ad>Ali</Ad>
  <Yas>25</Yas>
  <Meslek>Mühendis</Meslek>
</Kisi>
```

Bu XML verisi, bir kişinin adını, yaşını ve mesleğini temsil eder. XML yaygın olarak kullanılır çünkü:
- **Esnek:** Verileri hiyerarşik bir şekilde düzenleyebilirsiniz.
- **Geniş Kullanım Alanı:** Web servisleri, yapılandırma dosyaları ve daha birçok alanda veri alışverişi için kullanılır.
- **İnsan Okunabilirliği:** XML, insanlar tarafından kolayca okunabilir ve düzenlenmesi mümkündür.

---

##### 2.2. `System.Xml.Serialization` Kütüphanesi

.NET'in yerleşik XML işleme kütüphanesi olan **`System.Xml.Serialization`**, XML verilerini C# nesnelerine dönüştürmek ve tersi işlemi yapmak için kullanılır. Özellikle XML tabanlı web servisleri veya yapılandırma dosyalarıyla çalışırken faydalıdır.

**Avantajları:**
- **Kolay Kullanım:** Basit ve sezgisel API'ler sunar.
- **Standartlaştırılmış:** XML standardına tam uyumludur.
- **Nesne Tabanlı:** XML verilerini doğrudan C# nesnelerine dönüştürür.

---

##### 2.3. XML Verilerini Nesnelere Dönüştürme ve Tersi

XML verilerini C# nesnelerine dönüştürmek için **deserileştirme**, C# nesnelerini XML verilerine dönüştürmek için ise **serileştirme** yapılır. Bu işlemler, özellikle veri alışverişi ve kalıcı veri depolama işlemleri için çok önemlidir.

###### **Örnek: XML Verisini Nesneye Dönüştürme (Deserileştirme)**

```csharp
using System;
using System.IO;
using System.Xml.Serialization;

class Program
{
    static void Main()
    {
        // XML verisi: Bir kişinin bilgilerini içerir
        string xml = @"
        <Kisi>
            <Ad>Ali</Ad>
            <Yas>25</Yas>
            <Meslek>Mühendis</Meslek>
        </Kisi>";

        // XML verisini nesneye dönüştürme
        XmlSerializer serializer = new XmlSerializer(typeof(Kisi));
        using (StringReader reader = new StringReader(xml))
        {
            Kisi kisi = (Kisi)serializer.Deserialize(reader);

            // Nesnenin özellikleri ekrana yazdırılır
            Console.WriteLine($"Ad: {kisi.Ad}, Yaş: {kisi.Yas}, Meslek: {kisi.Meslek}");
        }
    }
}

// XML verisini temsil eden sınıf
[Serializable]
public class Kisi
{
    public string Ad { get; set; }
    public int Yas { get; set; }
    public string Meslek { get; set; }
}
```

Burada XML verisi, `Kisi` sınıfına dönüştürülür. `XmlSerializer.Deserialize` metodu, XML verisini C# nesnesine çevirir ve ardından nesnenin özellikleri ekrana yazdırılır.

---

###### **Örnek: Nesneyi XML Verisine Dönüştürme (Serileştirme)**

```csharp
using System;
using System.IO;
using System.Xml.Serialization;

class Program
{
    static void Main()
    {
        // C# nesnesi: Bir kişinin bilgilerini içerir
        Kisi kisi = new Kisi { Ad = "Ayşe", Yas = 30, Meslek = "Doktor" };

        // Nesneyi XML verisine dönüştürme
        XmlSerializer serializer = new XmlSerializer(typeof(Kisi));
        using (StringWriter writer = new StringWriter())
        {
            serializer.Serialize(writer, kisi);
            string xml = writer.ToString();

            // XML çıktısı ekrana yazdırılır
            Console.WriteLine(xml);
        }
    }
}

// XML verisini temsil eden sınıf
[Serializable]
public class Kisi
{
    public string Ad { get; set; }
    public int Yas { get; set; }
    public string Meslek { get; set; }
}
```

Bu örnekte `Kisi` sınıfından bir nesne oluşturulur ve `XmlSerializer.Serialize` metoduyla XML formatına dönüştürülür. Elde edilen XML çıktısı ekrana yazdırılır.

---

##### 2.4. XML Verilerini Dosyaya Yazma ve Dosyadan Okuma

XML verilerini dosyaya yazmak veya dosyadan okumak, özellikle kalıcı veri depolama işlemleri için çok faydalıdır. Örneğin, bir telefon rehberini XML formatında bir dosyada saklayabilirsiniz.

###### **Örnek: XML Verisini Dosyaya Yazma**

```csharp
using System;
using System.IO;
using System.Xml.Serialization;

class Program
{
    static void Main()
    {
        // C# nesnesi: Bir kişinin bilgilerini içerir
        Kisi kisi = new Kisi { Ad = "Mehmet", Yas = 40, Meslek = "Öğretmen" };

        // XML dosyasının yolu
        string dosyaYolu = @"C:\Ornek\kisi.xml";

        // Nesneyi XML verisine dönüştürme
        XmlSerializer serializer = new XmlSerializer(typeof(Kisi));
        using (StreamWriter writer = new StreamWriter(dosyaYolu))
        {
            serializer.Serialize(writer, kisi);
        }

        Console.WriteLine("XML verisi dosyaya yazıldı.");
    }
}

// XML verisini temsil eden sınıf
[Serializable]
public class Kisi
{
    public string Ad { get; set; }
    public int Yas { get; set; }
    public string Meslek { get; set; }
}
```

Bu kodda `Kisi` sınıfından bir nesne oluşturulur, XML formatına dönüştürülür ve `StreamWriter` ile belirtilen dosyaya yazılır. Böylece veri kalıcı olarak saklanmış olur.

---

###### **Örnek: XML Verisini Dosyadan Okuma**

```csharp
using System;
using System.IO;
using System.Xml.Serialization;

class Program
{
    static void Main()
    {
        // XML dosyasının yolu
        string dosyaYolu = @"C:\Ornek\kisi.xml";

        // Dosyadan XML verisini okuma
        XmlSerializer serializer = new XmlSerializer(typeof(Kisi));
        using (StreamReader reader = new StreamReader(dosyaYolu))
        {
            Kisi kisi = (Kisi)serializer.Deserialize(reader);

            // Nesnenin özellikleri ekrana yazdırılır
            Console.WriteLine($"Ad: {kisi.Ad}, Yaş: {kisi.Yas}, Meslek: {kisi.Meslek}");
        }
    }
}

// XML verisini temsil eden sınıf
[Serializable]
public class Kisi
{
    public string Ad { get; set; }
    public int Yas { get; set; }
    public string Meslek { get; set; }
}
```

Bu örnekte `StreamReader` ile XML verisi dosyadan okunur, `XmlSerializer.Deserialize` metoduyla C# nesnesine dönüştürülür ve ardından nesnenin özellikleri ekrana yazdırılır.

---

#### 3 Custom Serileştirme

##### 3.1. Özel Serileştirme Metotları Yazma

Bazı durumlarda, varsayılan serileştirme yöntemleri (örneğin `System.Text.Json` veya `System.Xml.Serialization`) yeterli olmayabilir. Bu gibi durumlarda **özel serileştirme metotları** yazarak serileştirme ve deserileştirme süreçlerini tamamen kontrol edebilirsiniz.

Örneğin, bir kişinin bilgilerini JSON veya XML formatında saklamak istediğinizi düşünelim. Ancak, kişinin yaşı gibi hassas bilgileri şifrelemek istiyor olabilirsiniz. İşte bu, özel serileştirme metotlarının kullanım mantığı gibidir.

###### **Örnek: Özel Serileştirme ve Deserileştirme**

```csharp
using System;
using System.IO;
using System.Text.Json;

class Program
{
    static void Main()
    {
        // C# nesnesi: Bir kişinin bilgilerini içerir
        Kisi kisi = new Kisi { Ad = "Ali", Yas = 25, Meslek = "Mühendis" };

        // Özel serileştirme
        string json = kisi.CustomSerialize();

        Console.WriteLine("Serileştirilmiş JSON: " + json);

        // Özel deserileştirme
        Kisi yeniKisi = Kisi.CustomDeserialize(json);

        Console.WriteLine($"Ad: {yeniKisi.Ad}, Yaş: {yeniKisi.Yas}, Meslek: {yeniKisi.Meslek}");
    }
}

// Özel serileştirme ve deserileştirme içeren sınıf
public class Kisi
{
    public string Ad { get; set; }
    public int Yas { get; set; }
    public string Meslek { get; set; }

    // Özel serileştirme metodu
    public string CustomSerialize()
    {
        // Yaşı şifreleyerek serileştir
        return $"{{ \"Ad\": \"{Ad}\", \"Yas\": \"{Encrypt(Yas)}\", \"Meslek\": \"{Meslek}\" }}";
    }

    // Özel deserileştirme metodu
    public static Kisi CustomDeserialize(string json)
    {
        // JSON verisini ayrıştır
        var jsonObject = JsonSerializer.Deserialize<dynamic>(json);

        // Şifrelenmiş yaşı çöz
        int yas = Decrypt(jsonObject["Yas"].ToString());

        // Yeni bir Kisi nesnesi oluştur ve doldur
        return new Kisi
        {
            Ad = jsonObject["Ad"].ToString(),
            Yas = yas,
            Meslek = jsonObject["Meslek"].ToString()
        };
    }

    // Basit bir şifreleme metodu (örnek amaçlı)
    private static string Encrypt(int value)
    {
        return (value + 100).ToString(); // Basit bir şifreleme
    }

    // Basit bir çözümleme metodu (örnek amaçlı)
    private static int Decrypt(string encryptedValue)
    {
        return int.Parse(encryptedValue) - 100; // Şifreyi çöz
    }
}
```

- `CustomSerialize` metodu, kişinin yaşını şifreleyerek JSON formatına dönüştürür.
- `CustomDeserialize` metodu, şifrelenmiş yaşı çözer ve nesneyi yeniden oluşturur.
- `Encrypt` ve `Decrypt` metotları, basit bir şifreleme ve çözümleme işlemi yapar.

---

##### 3.2. Serileştirme Sürecini Özelleştirme

Varsayılan serileştirme yöntemlerini özelleştirmek için sınıflara özel nitelikler ekleyebilir veya serileştirme davranışlarını değiştirebilirsiniz. Örneğin, bazı özelliklerin serileştirilmesini engellemek veya farklı adlarla kaydetmek isteyebilirsiniz.

###### **Örnek: JSON Serileştirme Davranışını Özelleştirme**

```csharp
using System;
using System.Text.Json;
using System.Text.Json.Serialization;

class Program
{
    static void Main()
    {
        // C# nesnesi: Bir kişinin bilgilerini içerir
        Kisi kisi = new Kisi { Ad = "Ayşe", Yas = 30, Meslek = "Doktor" };

        // Özel ayarlarla serileştirme
        var options = new JsonSerializerOptions
        {
            WriteIndented = true, // Girintili çıktı
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase // Özellik isimlerini küçük harfle başlat
        };

        string json = JsonSerializer.Serialize(kisi, options);

        Console.WriteLine(json);
    }
}

// Özel serileştirme davranışlarını içeren sınıf
public class Kisi
{
    public string Ad { get; set; }

    [JsonIgnore] // Bu özellik serileştirilmez
    public int Yas { get; set; }

    [JsonPropertyName("meslek")] // Farklı bir isimle kaydedilir
    public string Meslek { get; set; }
}
```

- `[JsonIgnore]` niteliği, `Yas` özelliğini serileştirme sürecinden çıkarır.
- `[JsonPropertyName("meslek")]` niteliği, `Meslek` özelliğini JSON'da farklı bir isimle kaydeder.
- `JsonSerializerOptions`, serileştirme davranışlarını özelleştirmek için kullanılır (örneğin girintili çıktı veya camelCase isimlendirme).

---

###### **Örnek: XML Serileştirme Davranışını Özelleştirme**

```csharp
using System;
using System.IO;
using System.Xml.Serialization;

class Program
{
    static void Main()
    {
        // C# nesnesi: Bir kişinin bilgilerini içerir
        Kisi kisi = new Kisi { Ad = "Mehmet", Yas = 40, Meslek = "Öğretmen" };

        // Özel ayarlarla serileştirme
        XmlSerializer serializer = new XmlSerializer(typeof(Kisi));
        using (StringWriter writer = new StringWriter())
        {
            serializer.Serialize(writer, kisi);
            string xml = writer.ToString();

            Console.WriteLine(xml);
        }
    }
}

// Özel serileştirme davranışlarını içeren sınıf
[XmlRoot("Kisi")] // Kök etiket adını değiştir
public class Kisi
{
    [XmlElement("Isim")] // Farklı bir etiketle kaydedilir
    public string Ad { get; set; }

    [XmlIgnore] // Bu özellik serileştirilmez
    public int Yas { get; set; }

    [XmlAttribute("Meslek")] // Nitelik olarak kaydedilir
    public string Meslek { get; set; }
}
```

- `[XmlRoot("Kisi")]`, XML'in kök etiketini belirler.
- `[XmlElement("Isim")]`, `Ad` özelliğini farklı bir etiketle kaydeder.
- `[XmlIgnore]`, `Yas` özelliğini serileştirme sürecinden çıkarır.
- `[XmlAttribute("Meslek")]`, `Meslek` özelliğini nitelik olarak kaydeder.

---

### Püf Noktaları

1. JSON, anahtar-değer çiftlerinden oluşur. Anahtarlar çift tırnak içinde yazılırken, değerler string, sayı, boolean, array veya başka bir JSON objesi olabilir.

2. `System.Text.Json` ile JSON çıktısını insan tarafından okunabilir hale getirmek için `JsonSerializerOptions` kullanabilirsiniz. Örneğin:
   ```csharp
   var options = new JsonSerializerOptions { WriteIndented = true };
   string formattedJson = JsonSerializer.Serialize(kisi, options);
   ```
   Bu, JSON çıktısını girintili bir şekilde formatlar.

3. JSON verilerini okurken veya yazar iken hatalar oluşabileceğinden, `try-catch` bloklarıyla hata yönetimini unutmayın. Özellikle dosya işlemleri sırasında `FileNotFoundException` veya `JsonException` gibi hatalar yakalanmalıdır.

4. Büyük JSON verileriyle çalışırken bellek kullanımını optimize etmek için akış tabanlı yöntemler (`Utf8JsonReader`, `Utf8JsonWriter`) tercih edilebilir.

5. XML, etiketlerle çevrelenmiş verilerden oluşur. Her etiket bir anahtarı temsil ederken, içeriği değerdir. Örneğin `<Ad>Ali</Ad>` ifadesinde `Ad` anahtar, `Ali` değerdir.

6. XML serileştirme yaparken sınıfların `[Serializable]` niteliğiyle işaretlenmesi önerilir. Bu, sınıfın serileştirilebilir olduğunu belirtir.

7. XML verilerini okurken veya yazar iken hatalar oluşabileceğinden, `try-catch` bloklarıyla hata yönetimini unutmayın. Özellikle dosya işlemleri sırasında `FileNotFoundException` veya `InvalidOperationException` gibi hatalar yakalanmalıdır.
8. Büyük XML verileriyle çalışırken bellek kullanımını optimize etmek için akış tabanlı yöntemler (`XmlReader`, `XmlWriter`) tercih edilebilir.

9. XML verilerini deserileştirirken, verilerin doğru formatta olduğundan emin olun. Örneğin, bir sayı beklenen yerde string gelmesi hataya neden olabilir.

10. Birden fazla nesneyi XML formatında saklamak için bir kapsayıcı etiket kullanabilirsiniz. Örneğin:
    ```xml
    <Kisiler>
        <Kisi>
            <Ad>Ali</Ad>
            <Yas>25</Yas>
        </Kisi>
        <Kisi>
            <Ad>Ayşe</Ad>
            <Yas>30</Yas>
        </Kisi>
    </Kisiler>
    ```

11. Varsayılan serileştirme yöntemleri yetersiz kaldığında, kendi serileştirme ve deserileştirme metotlarınızı yazabilirsiniz. Özellikle şifreleme, sıkıştırma veya özel formatlama işlemleri için faydalıdır.

12. `[JsonIgnore]`, `[JsonPropertyName]`, `[XmlIgnore]`, `[XmlElement]` gibi nitelikler, serileştirme davranışlarını kolayca özelleştirmenizi sağlar.

13. Hassas bilgileri (örneğin şifreler, kimlik numaraları) serileştirme sırasında şifrelemeniz önemlidir. Özel serileştirme metotları bu tür senaryolar için idealdir.

14. Büyük verilerle çalışırken, serileştirme sürecini akış tabanlı yöntemlerle optimize edebilirsiniz.

15. JSON veya XML çıktısını insan tarafından okunabilir hale getirmek için girintili formatlama (`WriteIndented`) veya camelCase isimlendirme (`PropertyNamingPolicy`) gibi seçenekler kullanabilirsiniz.