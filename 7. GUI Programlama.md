## 7. GUI Programlama

#### Nedir, Ne İçin Kullanılır?
**GUI (Graphical User Interface)**, kullanıcıların yazılımla etkileşim kurmasını sağlayan görsel bir arayüzdür. Günlük hayatta telefonunuzdaki bir uygulamayı düşünelim. Uygulamanın butonlarına tıkladığınızda bir işlem gerçekleşir. İşte bu, GUI'nin temel işlevi gibidir.

GUI programlama, kullanıcıların yazılımı kolayca kullanabilmesini sağlamak için tasarlanır. Örneğin:
- Bir hesap makinesi uygulamasında sayıları girmek için butonlar,
- Bir müzik çalar uygulamasında şarkı seçmek için bir liste,
- Bir form uygulamasında bilgi girmek için metin kutuları.

Bu tür görsel bileşenler, kullanıcı deneyimini (UX) artırır ve yazılımı daha erişilebilir hale getirir.

---

### 7.1. Windows Forms

#### 1. Temel Kavramlar

##### 1.1. Nedir? Ne İçin Kullanılır?

**Windows Forms**, Microsoft tarafından geliştirilen bir GUI framework'üdür. .NET ekosisteminde, masaüstü uygulamaları geliştirmek için sıkça tercih edilir. Günlük hayatta bir banka şubesindeki otomatik ödeme terminalini düşünelim. Bu terminalde, kullanıcılar dokunmatik ekranlar üzerinden işlemler yapar. Windows Forms, benzer şekilde masaüstü uygulamaları için görsel arayüzler oluşturmanıza olanak tanır.

Windows Forms'un temel özellikleri:
- Drag-and-drop (sürükle-bırak) arayüzüyle hızlı tasarım.
- Zengin bileşenler (butonlar, metin kutuları, listeler, grafikler vb.).
- Olay tabanlı programlama (event-driven programming).

---

##### 1.2. Nasıl Bir GUI Program Oluşturulur?

Windows Forms ile bir GUI programı oluşturmak için şu adımları izleyebilirsiniz:

1. **Proje Oluşturma:**
   - Visual Studio'da **File > New > Project** seçeneğini seçin.
   - **Windows Forms App (.NET Framework)** veya **Windows Forms App (.NET Core/5/6)** şablonunu seçin.

2. **Form Tasarımı:**
   - Toolbox panelinden (araç kutusu), görsel bileşenleri (örneğin butonlar, metin kutuları) sürükleyip bırakarak formu tasarlayın.
   - Özellikler panelinden (Properties), bileşenlerin özelliklerini (örneğin boyut, renk, yazı tipi) düzenleyin.

3. **Olay İşleyicileri Ekleme:**
   - Bir butona çift tıklayarak olay işleyicisi (event handler) oluşturabilirsiniz. Örneğin:
     ```csharp
     private void button1_Click(object sender, EventArgs e)
     {
         MessageBox.Show("Butona tıklandı!");
     }
     ```

4. **Uygulamayı Çalıştırma:**
   - **F5** tuşuna basarak uygulamayı çalıştırabilirsiniz.

---

##### 1.3. Arayüz ile Kullanım Şekli ve Kodlar ile Kullanım Şekli

Windows Forms'ta iki temel kullanım şekli vardır:
1. **Arayüz (Designer) ile Tasarım:**
   - Form üzerindeki bileşenleri sürükle-bırak yöntemiyle yerleştirirsiniz.
   - Özellikler panelinden bileşenlerin özelliklerini düzenlersiniz.
   - Olay işleyicilerini çift tıklayarak kod kısmına geçiş yapabilirsiniz.

2. **Kod ile Tasarım:**
   - Bileşenleri ve özelliklerini doğrudan kod üzerinden oluşturabilirsiniz. Örneğin:
     ```csharp
     Button button = new Button();
     button.Text = "Tıkla";
     button.Location = new Point(50, 50);
     button.Click += (sender, e) => MessageBox.Show("Butona tıklandı!");
     this.Controls.Add(button);
     ```

Bu yöntemler, esneklik sağlar ve farklı senaryolara göre tercih edilebilir.

---

##### 1.4. Dosya Sistemi ve Hiyerarşisi

Bir Windows Forms projesinin dosya sistemi şu şekilde organize edilir:

1. **Solution (Çözüm):**
   - Projenin ana kapsayıcısıdır. İçerisinde birden fazla proje bulunabilir.

2. **Project (Proje):**
   - Uygulamanın kodlarını, kaynak dosyalarını ve yapılandırma dosyalarını içerir.

3. **Dosyalar ve Klasörler:**
   - **Program.cs:** Uygulamanın giriş noktası (`Main` metodu) burada bulunur.
   - **Form1.cs:** Ana formun kod dosyasıdır.
   - **Form1.Designer.cs:** Formun görsel tasarımının kod karşılığıdır. Burada bileşenlerin özellikleri ve yerleşimi tanımlanır.
   - **Resources:** Resimler, ikonlar gibi kaynak dosyaları burada saklanır.
   - **Properties > Settings.settings:** Uygulama ayarlarını içerir.
   - **App.config:** Uygulama yapılandırma dosyasıdır (örneğin bağlantı dizeleri).

Örnek bir proje hiyerarşisi:
```
MyWindowsApp/
│
├── MyWindowsApp.sln
├── MyWindowsApp/
│   ├── Program.cs
│   ├── Form1.cs
│   ├── Form1.Designer.cs
│   ├── Resources/
│   │   └── logo.png
│   ├── Properties/
│   │   └── Settings.settings
│   └── App.config
└── bin/
    └── Debug/
        └── MyWindowsApp.exe
```

---

##### Örnek: Basit Bir Hesap Makinesi

Diyelim ki bir hesap makinesi uygulaması geliştirmek istiyorsunuz. Windows Forms ile şu şekilde bir tasarım ve kod yazabilirsiniz:

1. **Form Tasarımı:**
   - İki `TextBox` bileşeni (sayı girişi için),
   - Bir `Button` bileşeni ("Hesapla" butonu),
   - Bir `Label` bileşeni (sonuç gösterimi için).

2. **Kod Yazımı:**
   ```csharp
   private void btnHesapla_Click(object sender, EventArgs e)
   {
       int sayi1 = int.Parse(textBox1.Text);
       int sayi2 = int.Parse(textBox2.Text);
       int sonuc = sayi1 + sayi2;
       lblSonuc.Text = $"Sonuç: {sonuc}";
   }
   ```

3. **Çalışma Şekli:**
   - Kullanıcı, iki sayı girer ve "Hesapla" butonuna tıklar.
   - Sonuç, `Label` bileşeninde gösterilir.

Bu yaklaşım, basit ve etkili bir GUI uygulaması oluşturmanıza olanak tanır.

---


#### 2. Form ve Kontroller

##### 2.1. Temel Kontroller

Windows Forms'ta sıkça kullanılan temel kontroller şunlardır:

1. **Button (Buton):**
   - Kullanıcıların bir işlemi tetiklemesi için kullanılır.
   - Örnek: "Kaydet", "Gönder", "Hesapla" gibi işlemler.

2. **TextBox (Metin Kutusu):**
   - Kullanıcıların metin girmesi için kullanılır.
   - Örnek: Kullanıcı adı, şifre veya adres bilgisi girişi.

3. **Label (Etiket):**
   - Metin göstermek için kullanılır.
   - Örnek: Açıklama metni veya sonuç gösterimi.

4. **ComboBox (Açılır Liste):**
   - Kullanıcıların bir listeden seçim yapmasını sağlar.
   - Örnek: Ülke seçimi veya kategori seçimi.

5. **CheckBox (Onay Kutusu):**
   - Kullanıcıların bir seçeneği işaretlemesi için kullanılır.
   - Örnek: "Beni hatırla" veya "Kabul ediyorum" gibi seçenekler.

6. **RadioButton (Radyo Butonu):**
   - Kullanıcıların bir grup içinde yalnızca bir seçeneği seçmesini sağlar.
   - Örnek: Cinsiyet seçimi (Erkek/Kadın).

7. **ListBox (Liste Kutusu):**
   - Birden fazla öğeyi liste halinde gösterir.
   - Örnek: Ürün listesi veya görev listesi.

8. **PictureBox (Resim Kutusu):**
   - Resim veya görsel içerik göstermek için kullanılır.
   - Örnek: Ürün resmi veya logo gösterimi.

---

##### 2.2. Kontrol Özellikleri ve Eventleri

Her kontrolün belirli özellikleri ve eventleri vardır. İşte en yaygın olanlar:

1. **Özellikler:**
   - `Text`: Kontrolde gösterilen metni belirler (örneğin butonun yazısı).
   - `Enabled`: Kontrolün etkin olup olmadığını belirler.
   - `Visible`: Kontrolün görünüp görünmeyeceğini belirler.
   - `Location`: Kontrolün form üzerindeki konumunu belirler.
   - `Size`: Kontrolün boyutunu belirler.

2. **Eventler (Olaylar):**
   - `Click`: Bir kontrol tıklandığında tetiklenir.
   - `TextChanged`: `TextBox`'taki metin değiştiğinde tetiklenir.
   - `SelectedIndexChanged`: `ComboBox` veya `ListBox`'ta bir öğe seçildiğinde tetiklenir.
   - `CheckedChanged`: `CheckBox` veya `RadioButton`'da seçim değiştiğinde tetiklenir.

---

##### 2.3. Örnekler ile Pekiştirme

###### Örnek 1: Basit Bir Form Tasarımı
Bu örnekte, bir formda kullanıcıdan adını alıp bir selamlama mesajı gösteren bir uygulama oluşturacağız.

```csharp
// Form üzerindeki kontroller:
// TextBox: txtAd (Kullanıcı adını girmesi için)
// Button: btnSelamla ("Selamla" butonu)
// Label: lblSonuc (Sonuç mesajını göstermek için)

private void btnSelamla_Click(object sender, EventArgs e)
{
    // TextBox'tan kullanıcı adını al
    string ad = txtAd.Text;

    // Eğer ad boş değilse, selamlama mesajı göster
    if (!string.IsNullOrEmpty(ad))
    {
        lblSonuc.Text = $"Merhaba, {ad}!"; // Label'a mesaj yaz
    }
    else
    {
        lblSonuc.Text = "Lütfen adınızı girin."; // Hata mesajı
    }
}
```

---

###### Örnek 2: ComboBox ile Ülke Seçimi
Bu örnekte, bir ComboBox kullanarak kullanıcıdan ülke seçmesini isteyeceğiz ve seçilen ülkeyi bir Label'da göstereceğiz.

```csharp
// Form üzerindeki kontroller:
// ComboBox: cmbUlke (Ülke seçimi için)
// Label: lblSecilenUlke (Seçilen ülkeyi göstermek için)

private void Form1_Load(object sender, EventArgs e)
{
    // ComboBox'a ülke listesi yükle
    cmbUlke.Items.Add("Türkiye");
    cmbUlke.Items.Add("Amerika");
    cmbUlke.Items.Add("Almanya");
    cmbUlke.Items.Add("Fransa");

    // Varsayılan olarak ilk öğeyi seç
    cmbUlke.SelectedIndex = 0;
}

private void cmbUlke_SelectedIndexChanged(object sender, EventArgs e)
{
    // Seçilen ülkeyi Label'da göster
    lblSecilenUlke.Text = $"Seçilen Ülke: {cmbUlke.SelectedItem}";
}
```

---

###### Örnek 3: CheckBox ve RadioButton Kullanımı
Bu örnekte, bir CheckBox ile kullanıcıdan onay alıp, bir RadioButton grubundan bir seçenek seçmesini sağlayacağız.

```csharp
// Form üzerindeki kontroller:
// CheckBox: chkOnay ("Kabul ediyorum" için)
// RadioButton: rbErkek ("Erkek" seçeneği)
// RadioButton: rbKadin ("Kadın" seçeneği)
// Button: btnGonder ("Gönder" butonu)
// Label: lblSonuc (Sonuç mesajını göstermek için)

private void btnGonder_Click(object sender, EventArgs e)
{
    // CheckBox kontrolü: Onay verilip verilmediğini kontrol et
    if (chkOnay.Checked)
    {
        // RadioButton kontrolü: Hangi cinsiyet seçildiğini kontrol et
        if (rbErkek.Checked)
        {
            lblSonuc.Text = "Erkek seçildi ve onaylandı.";
        }
        else if (rbKadin.Checked)
        {
            lblSonuc.Text = "Kadın seçildi ve onaylandı.";
        }
        else
        {
            lblSonuc.Text = "Lütfen bir cinsiyet seçin.";
        }
    }
    else
    {
        lblSonuc.Text = "Lütfen 'Kabul ediyorum' kutusunu işaretleyin.";
    }
}
```

---

###### Örnek 4: ListBox ile Ürün Listesi
Bu örnek, bir ListBox kullanarak ürün listesi oluşturma ve seçilen ürünü göstermeyi içerir.

```csharp
// Form üzerindeki kontroller:
// ListBox: lstUrunler (Ürün listesi için)
// Button: btnEkle ("Ürün Ekle" butonu)
// TextBox: txtUrunAdi (Yeni ürün adını girmek için)
// Label: lblSecilenUrun (Seçilen ürünü göstermek için)

private void Form1_Load(object sender, EventArgs e)
{
    // ListBox'a varsayılan ürünler ekle
    lstUrunler.Items.Add("Elma");
    lstUrunler.Items.Add("Armut");
    lstUrunler.Items.Add("Çilek");
}

private void btnEkle_Click(object sender, EventArgs e)
{
    // TextBox'tan yeni ürün adını al ve ListBox'a ekle
    string urunAdi = txtUrunAdi.Text;

    if (!string.IsNullOrEmpty(urunAdi))
    {
        lstUrunler.Items.Add(urunAdi); // Yeni ürünü listeye ekle
        txtUrunAdi.Clear(); // TextBox'ı temizle
    }
    else
    {
        MessageBox.Show("Lütfen bir ürün adı girin.");
    }
}

private void lstUrunler_SelectedIndexChanged(object sender, EventArgs e)
{
    // Seçilen ürünü Label'da göster
    if (lstUrunler.SelectedItem != null)
    {
        lblSecilenUrun.Text = $"Seçilen Ürün: {lstUrunler.SelectedItem}";
    }
}
```

---

###### Örnek 5: PictureBox ile Resim Gösterme
Bu örnekte, bir PictureBox kullanarak bir resim gösterip değiştirme işlemini gerçekleştireceğiz.

```csharp
// Form üzerindeki kontroller:
// PictureBox: pictureBox1 (Resim göstermek için)
// Button: btnResimDegistir ("Resim Değiştir" butonu)

private void btnResimDegistir_Click(object sender, EventArgs e)
{
    // OpenFileDialog ile kullanıcıdan bir resim dosyası seçmesini iste
    using (OpenFileDialog openFileDialog = new OpenFileDialog())
    {
        openFileDialog.Filter = "Resim Dosyaları|*.jpg;*.jpeg;*.png"; // Filtreleme

        if (openFileDialog.ShowDialog() == DialogResult.OK)
        {
            // Seçilen resmi PictureBox'a yükle
            pictureBox1.Image = Image.FromFile(openFileDialog.FileName);
        }
    }
}
```

---


#### 3. Event Handling

##### 3.1. Temel Eventler

Windows Forms'ta sıkça kullanılan temel eventler şunlardır:

1. **Click:**
   - Bir kontrol tıklandığında tetiklenir.
   - Örnek: Bir butona tıklandığında bir işlem gerçekleştirmek.

2. **TextChanged:**
   - Bir `TextBox`'taki metin değiştiğinde tetiklenir.
   - Örnek: Kullanıcının yazdığı metni anlık olarak doğrulamak veya işlemek.

3. **SelectedIndexChanged:**
   - Bir `ComboBox` veya `ListBox`'ta bir öğe seçildiğinde tetiklenir.
   - Örnek: Kullanıcı bir ülke seçtiğinde ilgili bilgileri göstermek.

4. **CheckedChanged:**
   - Bir `CheckBox` veya `RadioButton`'da seçim değiştiğinde tetiklenir.
   - Örnek: "Kabul ediyorum" kutusunun işaretlenip işaretlenmediğini kontrol etmek.

5. **Load:**
   - Form veya kontrol yüklendiğinde tetiklenir.
   - Örnek: Form açıldığında varsayılan verileri yüklemek.

6. **MouseEnter / MouseLeave:**
   - Fare bir kontrolün üzerine geldiğinde veya ayrıldığında tetiklenir.
   - Örnek: Butonun rengini değiştirmek.

7. **KeyPress / KeyDown / KeyUp:**
   - Klavyeden bir tuşa basıldığında tetiklenir.
   - Örnek: Enter tuşuna basıldığında bir işlem gerçekleştirmek.

---

##### 3.2. Event Handler Metotları Yazma

Event handler metotları, belirli bir olay gerçekleştiğinde çalışacak kodları içerir. Bu metotlar genellikle aşağıdaki yapıda yazılır:

```csharp
private void KontrolAdi_EventAdi(object sender, EventArgs e)
{
    // Olay gerçekleştiğinde çalışacak kodlar
}
```

- **`object sender`:** Olayın hangi kontrol tarafından tetiklendiğini belirtir.
- **`EventArgs e`:** Olayla ilgili ek bilgiler içerir (örneğin, klavye tuşu bilgisi).

---

##### 3.3. Örnekler ile Pekiştirme

###### Örnek 1: Button Click Event'i
Bu örnekte, bir butona tıklandığında bir mesaj gösteren bir uygulama oluşturacağız.

```csharp
// Form üzerindeki kontroller:
// Button: btnMesaj ("Mesaj Göster" butonu)

private void btnMesaj_Click(object sender, EventArgs e)
{
    // Butona tıklandığında bir mesaj göster
    MessageBox.Show("Butona tıklandı!", "Bilgi", MessageBoxButtons.OK, MessageBoxIcon.Information);
}
```

---

###### Örnek 2: TextBox TextChanged Event'i
Bu örnekte, bir `TextBox`'a yazılan metni anlık olarak bir `Label`'da göstereceğiz.

```csharp
// Form üzerindeki kontroller:
// TextBox: txtGirdi (Kullanıcı girişi için)
// Label: lblSonuc (Girilen metni göstermek için)

private void txtGirdi_TextChanged(object sender, EventArgs e)
{
    // TextBox'taki metni Label'da göster
    lblSonuc.Text = $"Yazdığınız: {txtGirdi.Text}";
}
```

---

###### Örnek 3: ComboBox SelectedIndexChanged Event'i
Bu örnekte, bir `ComboBox`'tan ülke seçildiğinde seçilen ülkeyi bir `Label`'da göstereceğiz.

```csharp
// Form üzerindeki kontroller:
// ComboBox: cmbUlke (Ülke seçimi için)
// Label: lblSecilenUlke (Seçilen ülkeyi göstermek için)

private void Form1_Load(object sender, EventArgs e)
{
    // ComboBox'a ülke listesi yükle
    cmbUlke.Items.Add("Türkiye");
    cmbUlke.Items.Add("Amerika");
    cmbUlke.Items.Add("Almanya");
    cmbUlke.Items.Add("Fransa");

    // Varsayılan olarak ilk öğeyi seç
    cmbUlke.SelectedIndex = 0;
}

private void cmbUlke_SelectedIndexChanged(object sender, EventArgs e)
{
    // Seçilen ülkeyi Label'da göster
    lblSecilenUlke.Text = $"Seçilen Ülke: {cmbUlke.SelectedItem}";
}
```

---

###### Örnek 4: CheckBox CheckedChanged Event'i
Bu örnekte, bir `CheckBox` işaretlendiğinde veya kaldırıldığında bir butonun etkinliğini değiştireceğiz.

```csharp
// Form üzerindeki kontroller:
// CheckBox: chkOnay ("Kabul ediyorum" için)
// Button: btnDevam ("Devam Et" butonu)

private void chkOnay_CheckedChanged(object sender, EventArgs e)
{
    // CheckBox işaretlendiyse butonu etkinleştir, aksi halde devre dışı bırak
    btnDevam.Enabled = chkOnay.Checked;
}
```

---

###### Örnek 5: ListBox SelectedIndexChanged Event'i
Bu örnekte, bir `ListBox`'tan bir ürün seçildiğinde seçilen ürünü bir `Label`'da göstereceğiz.

```csharp
// Form üzerindeki kontroller:
// ListBox: lstUrunler (Ürün listesi için)
// Label: lblSecilenUrun (Seçilen ürünü göstermek için)

private void Form1_Load(object sender, EventArgs e)
{
    // ListBox'a varsayılan ürünler ekle
    lstUrunler.Items.Add("Elma");
    lstUrunler.Items.Add("Armut");
    lstUrunler.Items.Add("Çilek");
}

private void lstUrunler_SelectedIndexChanged(object sender, EventArgs e)
{
    // Seçilen ürünü Label'da göster
    if (lstUrunler.SelectedItem != null)
    {
        lblSecilenUrun.Text = $"Seçilen Ürün: {lstUrunler.SelectedItem}";
    }
}
```

---

###### Örnek 6: MouseEnter ve MouseLeave Event'leri
Bu örnekte, bir butonun üzerine fare geldiğinde rengini değiştireceğiz ve farenin uzaklaştığında rengini eski haline döndüreceğiz.

```csharp
// Form üzerindeki kontroller:
// Button: btnRenkDegistir ("Renk Değiştir" butonu)

private void btnRenkDegistir_MouseEnter(object sender, EventArgs e)
{
    // Fare butonun üzerine geldiğinde arka plan rengini değiştir
    btnRenkDegistir.BackColor = Color.LightGreen;
}

private void btnRenkDegistir_MouseLeave(object sender, EventArgs e)
{
    // Fare butondan ayrıldığında arka plan rengini eski haline döndür
    btnRenkDegistir.BackColor = SystemColors.Control;
}
```

---

###### Örnek 7: KeyPress Event'i
Bu örnekte, bir `TextBox`'ta yalnızca sayısal giriş yapılmasını sağlayacağız.

```csharp
// Form üzerindeki kontroller:
// TextBox: txtSayi (Yalnızca sayı girişi için)

private void txtSayi_KeyPress(object sender, KeyPressEventArgs e)
{
    // Eğer girilen karakter sayı değilse, giriş engellenir
    if (!char.IsDigit(e.KeyChar) && !char.IsControl(e.KeyChar))
    {
        e.Handled = true; // Giriş işlemini iptal et
    }
}
```

---


#### 4. Data Binding

##### 4.1. Kontrollere Veri Bağlama

**Data Binding**, bir kontrolün (örneğin `TextBox`, `ComboBox`, `ListBox`) veri kaynağındaki verilerle otomatik olarak senkronize olmasını sağlar. Bu, özellikle veritabanı işlemleri veya koleksiyonlarla çalışırken faydalıdır.

**Neden Data Binding Kullanılır?**
- Veri gösterimi ve düzenleme işlemlerini kolaylaştırır.
- Veri kaynağındaki değişiklikler, kontrollerde otomatik olarak yansıtılır.
- Kod karmaşıklığını azaltır.

---

##### 4.2. BindingSource Kullanımı

**`BindingSource`**, bir kontrol ile veri kaynağı arasında köprü görevi görür. Özellikle veri kaynaklarının yönetilmesi ve güncellenmesi için kullanılır.

###### Örnek: TextBox'a Veri Bağlama
Bu örnekte, bir `TextBox`'a bir nesnenin özelliğini bağlayacağız.

```csharp
// Bir sınıf tanımlayalım
public class Kisi
{
    public string Ad { get; set; }
    public int Yas { get; set; }
}

// Form üzerindeki kontroller:
// TextBox: txtAd (Ad bilgisi için)
// TextBox: txtYas (Yaş bilgisi için)

private void Form1_Load(object sender, EventArgs e)
{
    // Bir kişi nesnesi oluşturalım
    Kisi kisi = new Kisi { Ad = "Ali", Yas = 25 };

    // BindingSource oluşturup kişi nesnesini bağlayalım
    BindingSource bindingSource = new BindingSource();
    bindingSource.DataSource = kisi;

    // TextBox'ları BindingSource'a bağlayalım
    txtAd.DataBindings.Add("Text", bindingSource, "Ad");
    txtYas.DataBindings.Add("Text", bindingSource, "Yas");
}
```

`txtAd` ve `txtYas` kontrolleri, `Kisi` nesnesinin özelliklerine (`Ad` ve `Yas`) bağlanır. `TextBox`'taki değişiklikler, nesnenin özelliklerinde otomatik olarak yansıtılır.

---

##### Örnek: ComboBox'a Liste Bağlama
Bu örnekte, bir `ComboBox`'a bir liste bağlayacağız.

```csharp
// Form üzerindeki kontroller:
// ComboBox: cmbUrunler (Ürün listesi için)

private void Form1_Load(object sender, EventArgs e)
{
    // Ürün listesi oluşturalım
    List<string> urunler = new List<string>
    {
        "Elma",
        "Armut",
        "Çilek"
    };

    // ComboBox'a ürün listesini bağlayalım
    cmbUrunler.DataSource = urunler;
}
```

`cmbUrunler` kontrolü, `urunler` listesine bağlanır. Liste güncellendiğinde, `ComboBox` otomatik olarak yenilenir.

---

##### 4.3. BindingNavigator Kullanımı

**`BindingNavigator`**, veri kaynaklarındaki kayıtları gezinmek (ileri/geri gitmek) ve düzenlemek için kullanılan bir araçtır. Genellikle `BindingSource` ile birlikte kullanılır.

###### Örnek: BindingNavigator ile Kayıt Gezinme
Bu örnekte, bir `BindingNavigator` ile bir liste içindeki kayıtları gezineceğiz.

```csharp
// Form üzerindeki kontroller:
// TextBox: txtAd (Ad bilgisi için)
// TextBox: txtYas (Yaş bilgisi için)
// BindingNavigator: bindingNavigator1 (Kayıt gezinme için)

private void Form1_Load(object sender, EventArgs e)
{
    // Kişi listesi oluşturalım
    List<Kisi> kisiler = new List<Kisi>
    {
        new Kisi { Ad = "Ali", Yas = 25 },
        new Kisi { Ad = "Ayşe", Yas = 30 },
        new Kisi { Ad = "Mehmet", Yas = 40 }
    };

    // BindingSource oluşturup kişi listesini bağlayalım
    BindingSource bindingSource = new BindingSource();
    bindingSource.DataSource = kisiler;

    // TextBox'ları BindingSource'a bağlayalım
    txtAd.DataBindings.Add("Text", bindingSource, "Ad");
    txtYas.DataBindings.Add("Text", bindingSource, "Yas");

    // BindingNavigator'ı BindingSource'a bağlayalım
    bindingNavigator1.BindingSource = bindingSource;
}
```

`bindingNavigator1`, `BindingSource` aracılığıyla kayıtları gezinir. İleri/geri düğmeleriyle kayıtlar arasında geçiş yapabilirsiniz.

---

##### 4.4. Örnekler ile Pekiştirme

###### Örnek 1: DataGridView ile Veri Bağlama
Bu örnekte, bir `DataGridView`'e bir liste bağlayacağız.

```csharp
// Form üzerindeki kontroller:
// DataGridView: dataGridView1 (Veri göstermek için)

private void Form1_Load(object sender, EventArgs e)
{
    // Ürün listesi oluşturalım
    List<Urun> urunler = new List<Urun>
    {
        new Urun { Id = 1, Ad = "Laptop", Fiyat = 5000 },
        new Urun { Id = 2, Ad = "Telefon", Fiyat = 3000 },
        new Urun { Id = 3, Ad = "Tablet", Fiyat = 2000 }
    };

    // DataGridView'e ürün listesini bağlayalım
    dataGridView1.DataSource = urunler;
}

// Ürün sınıfı
public class Urun
{
    public int Id { get; set; }
    public string Ad { get; set; }
    public decimal Fiyat { get; set; }
}
```

`dataGridView1`, `urunler` listesine bağlanır. Liste güncellendiğinde, tablo otomatik olarak yenilenir.

---

###### Örnek 2: Birden Fazla Kontrole Aynı Veriyi Bağlama
Bu örnekte, aynı veriyi birden fazla kontrolde göstereceğiz.

```csharp
// Form üzerindeki kontroller:
// TextBox: txtAd (Ad bilgisi için)
// Label: lblAd (Ad bilgisi için)

private void Form1_Load(object sender, EventArgs e)
{
    // Bir kişi nesnesi oluşturalım
    Kisi kisi = new Kisi { Ad = "Ali", Yas = 25 };

    // BindingSource oluşturup kişi nesnesini bağlayalım
    BindingSource bindingSource = new BindingSource();
    bindingSource.DataSource = kisi;

    // TextBox ve Label'ı BindingSource'a bağlayalım
    txtAd.DataBindings.Add("Text", bindingSource, "Ad");
    lblAd.DataBindings.Add("Text", bindingSource, "Ad");
}
```

`txtAd` ve `lblAd`, aynı veri kaynağına (`Ad` özelliği) bağlanır. Birinde yapılan değişiklik, diğerinde de yansır.

---


#### 5. DataGridView Kullanımı

##### 5.1. Veri Tablolarını Gösterme

**DataGridView**, veri setlerini (örneğin listeler, veritabanı tabloları) tablo şeklinde göstermek için kullanılan güçlü bir kontroldür. Özellikle raporlama veya veri düzenleme işlemleri için idealdir.

###### Örnek 1: DataGridView'e Liste Bağlama
Bu örnekte, bir `DataGridView`'e bir liste bağlayacağız.

```csharp
// Form üzerindeki kontroller:
// DataGridView: dataGridView1 (Veri göstermek için)

private void Form1_Load(object sender, EventArgs e)
{
    // Ürün listesi oluşturalım
    List<Urun> urunler = new List<Urun>
    {
        new Urun { Id = 1, Ad = "Laptop", Fiyat = 5000 },
        new Urun { Id = 2, Ad = "Telefon", Fiyat = 3000 },
        new Urun { Id = 3, Ad = "Tablet", Fiyat = 2000 }
    };

    // DataGridView'e ürün listesini bağlayalım
    dataGridView1.DataSource = urunler;
}

// Ürün sınıfı
public class Urun
{
    public int Id { get; set; }
    public string Ad { get; set; }
    public decimal Fiyat { get; set; }
}
```
`dataGridView1`, `urunler` listesine bağlanır. Liste güncellendiğinde, tablo otomatik olarak yenilenir.

---

###### Örnek 2: DataGridView'e Veritabanı Tablosu Bağlama
Bu örnekte, bir veritabanındaki tabloyu `DataGridView` ile göstereceğiz.

```csharp
// Form üzerindeki kontroller:
// DataGridView: dataGridView1 (Veri göstermek için)

private void Form1_Load(object sender, EventArgs e)
{
    // Veritabanı bağlantısı oluşturalım
    string connectionString = "Server=localhost;Database=UrunDB;User Id=sa;Password=12345;";
    using (SqlConnection connection = new SqlConnection(connectionString))
    {
        // SQL sorgusu ile verileri çekelim
        string query = "SELECT * FROM Urunler";
        SqlDataAdapter adapter = new SqlDataAdapter(query, connection);
        DataTable dataTable = new DataTable();

        // Verileri DataTable'a dolduralım
        adapter.Fill(dataTable);

        // DataGridView'e DataTable'ı bağlayalım
        dataGridView1.DataSource = dataTable;
    }
}
```
`dataGridView1`, veritabanından çekilen `Urunler` tablosuna bağlanır. Veritabanında yapılan değişiklikler, yeniden sorgulama yapılarak yansıtılabilir.

---

##### 5.2. Hücre Düzenleme

**DataGridView**, hücreleri düzenlemek için çeşitli özellikler sunar. Örneğin, kullanıcıların belirli hücreleri düzenlemesine izin verebilir veya düzenlemeyi kısıtlayabilirsiniz.

###### Özellikler:
- **`ReadOnly`:** Tüm hücrelerin düzenlenmesini engeller.
- **`EditMode`:** Düzenleme modunu belirler (örneğin tıklamayla düzenleme).
- **`CellBeginEdit` ve `CellEndEdit`:** Hücre düzenleme olaylarını yönetir.

###### Örnek: Hücre Düzenleme İzni Verme
Bu örnekte, yalnızca belirli bir sütundaki hücreleri düzenlenebilir yapacağız.

```csharp
// Form üzerindeki kontroller:
// DataGridView: dataGridView1 (Veri göstermek için)

private void Form1_Load(object sender, EventArgs e)
{
    // Ürün listesi oluşturalım
    List<Urun> urunler = new List<Urun>
    {
        new Urun { Id = 1, Ad = "Laptop", Fiyat = 5000 },
        new Urun { Id = 2, Ad = "Telefon", Fiyat = 3000 },
        new Urun { Id = 3, Ad = "Tablet", Fiyat = 2000 }
    };

    // DataGridView'e ürün listesini bağlayalım
    dataGridView1.DataSource = urunler;

    // "Ad" sütununu düzenlenebilir yapalım
    dataGridView1.Columns["Ad"].ReadOnly = false;

    // Diğer sütunları salt okunur yapalım
    dataGridView1.Columns["Id"].ReadOnly = true;
    dataGridView1.Columns["Fiyat"].ReadOnly = true;
}
```
"Ad" sütunundaki hücreler düzenlenebilir, diğer sütunlar ise salt okunurdur.

---

##### 5.3. Event Handling

**DataGridView**, çeşitli olaylar sağlar. Bu olaylar, kullanıcı etkileşimlerini yönetmek için kullanılır.

###### Ortak Eventler:
- **`CellClick`:** Bir hücreye tıklandığında tetiklenir.
- **`CellDoubleClick`:** Bir hücreye çift tıklandığında tetiklenir.
- **`CellValueChanged`:** Bir hücredeki değer değiştiğinde tetiklenir.
- **`CellFormatting`:** Hücrelerin biçimlendirilmesi için kullanılır.

###### Örnek 1: CellClick Event'i
Bu örnekte, bir hücreye tıklandığında hücrenin içeriğini bir `Label`'da göstereceğiz.

```csharp
// Form üzerindeki kontroller:
// DataGridView: dataGridView1 (Veri göstermek için)
// Label: lblHücreBilgi (Hücre bilgisi için)

private void Form1_Load(object sender, EventArgs e)
{
    // Ürün listesi oluşturalım
    List<Urun> urunler = new List<Urun>
    {
        new Urun { Id = 1, Ad = "Laptop", Fiyat = 5000 },
        new Urun { Id = 2, Ad = "Telefon", Fiyat = 3000 },
        new Urun { Id = 3, Ad = "Tablet", Fiyat = 2000 }
    };

    // DataGridView'e ürün listesini bağlayalım
    dataGridView1.DataSource = urunler;
}

private void dataGridView1_CellClick(object sender, DataGridViewCellEventArgs e)
{
    // Tıklanan hücrenin satır ve sütun indekslerini alalım
    if (e.RowIndex >= 0 && e.ColumnIndex >= 0)
    {
        // Hücrenin değerini alalım
        string hücreIcerik = dataGridView1.Rows[e.RowIndex].Cells[e.ColumnIndex].Value.ToString();

        // Hücre içeriğini Label'da gösterelim
        lblHücreBilgi.Text = $"Hücre İçeriği: {hücreIcerik}";
    }
}
```
`CellClick` event'i, tıklanan hücrenin içeriğini alır ve bir `Label`'da gösterir.

---

###### Örnek 2: CellValueChanged Event'i
Bu örnekte, bir hücredeki değer değiştiğinde bir mesaj göstereceğiz.

```csharp
private void dataGridView1_CellValueChanged(object sender, DataGridViewCellEventArgs e)
{
    // Değişen hücrenin satır ve sütun indekslerini alalım
    if (e.RowIndex >= 0 && e.ColumnIndex >= 0)
    {
        // Hücrenin yeni değerini alalım
        string yeniDeger = dataGridView1.Rows[e.RowIndex].Cells[e.ColumnIndex].Value?.ToString();

        // Değişikliği bir mesaj olarak gösterelim
        MessageBox.Show($"Hücre Değiştirildi: Yeni Değer = {yeniDeger}");
    }
}
```
`CellValueChanged` event'i, hücredeki değerin değiştiğini algılar ve kullanıcıya bildirir.

---


#### Püf Noktalar

1. Windows Forms, masaüstü uygulamaları geliştirmek için kullanılan bir GUI framework'üdür. Özellikle .NET ekosisteminde sıkça tercih edilir.

2. Görsel tasarım yaparken formunuzu düzenli tutmak için bileşenlerin boyutlarını ve yerleşimlerini dikkatlice ayarlayın. Kullanıcı deneyimini artırmak için `Anchor` ve `Dock` özelliklerini kullanarak bileşenlerin pencere boyutuna uyum sağlamasını sağlayın.

3. Her bileşenin belirli olayları vardır (örneğin `Click`, `TextChanged`). Bu olaylara işleyiciler ekleyerek kullanıcı etkileşimlerini yönetebilirsiniz. Örneğin, bir butonun tıklanma olayını yakalamak için `Click` olayını kullanın.

4. Bileşenleri dinamik olarak oluşturmak, özellikle karmaşık veya özelleştirilmiş arayüzler için faydalıdır. Örneğin, bir liste kutusu veya butonu kod üzerinden oluşturabilir ve özelliklerini programlı olarak ayarlayabilirsiniz.

5. `Form1.cs` ile `Form1.Designer.cs` arasındaki ilişkiyi anlamak önemlidir. Designer dosyası, görsel tasarımın kod karşılığını içerir. Bu dosyayı manuel olarak değiştirmekten kaçının.

6. Resimler, ikonlar gibi kaynak dosyalarını `Resources` klasörü altında saklayın. Bu, projenizin düzenli kalmasını sağlar ve kaynak dosyalarını kolayca yönetmenizi sağlar.

7. Bağlantı dizeleri, kullanıcı tercihleri gibi ayarları `Settings.settings` dosyasında saklayın. Bu, uygulama ayarlarınızı merkezi bir yerde yönetmenizi sağlar.

8. Uygulamanızı geliştirirken `Debug` modunu kullanın. Yayınlamadan önce `Release` moduna geçiş yapmayı unutmayın. `Release` modu, performansı optimize edilmiş bir yapı sunar.

9. Büyük resimler veya çok sayıda bileşen içeren formlarda performans sorunları yaşayabilirsiniz. Gereksiz bileşenleri kaldırın veya yükleme sürelerini optimize edin. Örneğin, büyük resimleri küçültün veya gerekli olduğunda yükleyin.

10. Kullanıcı deneyimini artırmak için butonlara anlamlı isimler verin, metin kutularına placeholder (ipucu) ekleyin ve hata mesajlarını net bir şekilde gösterin. Örneğin, bir metin kutusu için "Adınızı girin" yazısı ekleyin.

11. Form üzerindeki bileşenleri gruplamak için `Panel` veya `GroupBox` bileşenlerini kullanın. Bu, arayüzü daha düzenli ve kullanıcı dostu hale getirir.

12. Birden fazla form kullanan uygulamalarda, formlar arasında veri aktarımı için `Constructor`, `Properties` veya `Events` kullanabilirsiniz. Örneğin, bir formdan diğerine veri göndermek için constructor parametreleri ekleyebilirsiniz.

13. Kullanıcı girdilerini doğrulamak için `ErrorProvider` bileşenini kullanın. Bu, kullanıcıların yanlış giriş yaptığında anında geri bildirim almasını sağlar.

14. Uygulamanızda tema desteği eklemek için `BackColor`, `ForeColor` gibi özellikleri kullanarak bileşenlerin renklerini özelleştirin. Ayrıca, modern görünümler için `FlatStyle` özelliğini kullanabilirsiniz.

15. Veritabanı işlemleri yaparken, uzun sürecek işlemler için asenkron programlama (`async/await`) kullanın. Bu, uygulamanızın donmasını engeller ve kullanıcı deneyimini artırır.

16. Formunuzu farklı çözünürlüklerde iyi görünmesini sağlamak için `AutoSize` ve `AutoSizeMode` özelliklerini kullanın. Ayrıca, font boyutlarını ölçeklenebilir hale getirin.

17. Uygulamanızda birden fazla dil desteği eklemek için `ResourceManager` sınıfını kullanabilirsiniz. Bu, uygulamanızı küresel hale getirir.

18. Form üzerindeki bileşenlerin sıralamasını düzenlemek için `TabIndex` özelliğini kullanın. Bu, klavye ile gezinmeyi kolaylaştırır.

19. Uygulamanızda grafiksel işlemler yapmak için `Graphics` sınıfını kullanabilirsiniz. Örneğin, bir çizim uygulaması oluşturmak için `Paint` olayını kullanabilirsiniz.

20. Uygulamanızın kapatılması sırasında kaydedilmemiş değişiklikler varsa kullanıcıyı uyarmak için `FormClosing` olayını kullanın.

21. Uygulamanızda kısa yollar (shortcuts) eklemek için `KeyPreview` özelliğini `true` yapın ve `KeyDown` olayını kullanın. Örneğin, `Ctrl+S` ile bir işlem tetikleyebilirsiniz.

22. Form üzerindeki bileşenleri düzenlemek için `TableLayoutPanel` veya `FlowLayoutPanel` gibi düzen bileşenlerini kullanın. Bu, bileşenlerin otomatik olarak düzenlenmesini sağlar.

23. Uygulamanızda ilerleme durumunu göstermek için `ProgressBar` bileşenini kullanabilirsiniz. Örneğin, bir dosya yükleme işlemi sırasında ilerleme çubuğu ekleyebilirsiniz.

24. Form üzerindeki bileşenlerin görünürlüğünü kontrol etmek için `Visible` özelliğini kullanın. Örneğin, bir butonu belirli koşullar altında göstermek veya gizlemek için bu özelliği değiştirin.

25. Uygulamanızda özel stiller eklemek için `Custom Controls` oluşturabilirsiniz. Örneğin, bir özel buton tasarlayabilir ve tüm projede yeniden kullanabilirsiniz.

26. Kullanıcı girdisini her zaman kontrol edin. Örneğin, boş girişleri engellemek için `string.IsNullOrEmpty` kullanın.

27. `Items.Add` ile veri ekleyebilir veya bir koleksiyonu direkt olarak bağlayabilirsiniz (`DataSource` özelliği).

28. Her olayın ne zaman tetikleneceğini anlayın. Örneğin, `TextChanged` olayı, TextBox'taki her karakter değişikliğinde çalışır.

29. Büyük resimleri küçültmek için `Image.GetThumbnailImage` yöntemini kullanabilirsiniz.

30. Örneğin, bir butonu belirli koşullar altında etkinleştirmek için `Enabled` özelliğini değiştirin.

31. `SelectionMode` özelliğini `MultiSimple` veya `MultiExtended` olarak ayarlayarak çoklu seçim sağlayın.

32. `TableLayoutPanel` veya `FlowLayoutPanel` gibi düzen bileşenleri, kontrollerin otomatik olarak düzenlenmesini sağlar.

33. Kullanıcıya net geri bildirim sağlamak için `MessageBox.Show` ile hata mesajları gösterin.

34. Visual Studio'da bir kontrolü çift tıklayarak otomatik olarak event handler oluşturabilirsiniz. Örneğin, bir butonu çift tıklayarak `Click` event handler'ını oluşturabilirsiniz.

35. `sender`, olayı tetikleyen kontrolü belirtir. Birden fazla kontrol aynı event handler'ı kullanıyorsa, `sender` üzerinden kontrolü tanımlayabilirsiniz.

36. `EventArgs`, olayla ilgili ek bilgiler içerir. Örneğin, `KeyPressEventArgs` ile basılan tuşu kontrol edebilirsiniz.

37. Tasarım zamanında değil, çalışma zamanında event bağlamak için `+=` operatörünü kullanabilirsiniz.

38. Kullanılmayan eventleri temizleyin. Aksi halde, gereksiz bellek tüketimi olabilir.

39. Kullanıcı girdisini anlık olarak kontrol etmek için `TextChanged` event'ini kullanabilirsiniz.

40. Butonların veya diğer kontrollerin görünümünü dinamik olarak değiştirmek için `MouseEnter` ve `MouseLeave` eventlerini kullanabilirsiniz.

41. Klavye girişlerini kontrol etmek için `KeyPress`, `KeyDown` veya `KeyUp` eventlerini kullanabilirsiniz. Örneğin, Enter tuşuna basıldığında bir işlem gerçekleştirmek için `KeyDown` event'ini kullanabilirsiniz.

42. Birden fazla kontrol aynı event handler'ı kullanabilir. Örneğin, birden fazla buton için tek bir `Click` event handler'ı yazabilirsiniz.

43. Veri kaynağı olarak koleksiyonlar (örneğin `List<T>`), veritabanı tabloları veya XML dosyaları kullanılabilir.

44. `BindingSource`, veri kaynağını soyutlar ve kontrollerle ilişkilendirmeyi kolaylaştırır. Veri kaynağındaki değişiklikler, kontrollerde otomatik olarak yansıtılır.

45. `BindingNavigator`'ın varsayılan düğmelerini kaldırabilir veya yeni düğmeler ekleyebilirsiniz.

46. `DataGridView`, büyük veri setlerini göstermek için idealdir. Ancak performans açısından optimize etmek için `VirtualMode` özelliğini kullanabilirsiniz.

47. `DataSource` özelliğini kullanarak veri kaynağındaki değişiklikleri anında yansıtın.

48. Veri doğrulama sırasında hataları yakalamak için `BindingSource`'un `CurrentItemChanged` event'ini kullanabilirsiniz.

49. Aynı veri kaynağına birden fazla kontrol bağlayarak tutarlılığı sağlayın.

50. Çalışma zamanında `BindingSource`'un `DataSource` özelliğini değiştirerek farklı veri kaynaklarını bağlayabilirsiniz.

51. Düzenleme izni vermek istemediğiniz sütunları `ReadOnly` yaparak koruyabilirsiniz.

52. `CellClick`, `CellDoubleClick` ve `CellValueChanged` gibi eventler, kullanıcı etkileşimlerini yönetmek için faydalıdır.

53. Büyük veri setleri için `VirtualMode` özelliğini kullanarak performansı artırabilirsiniz.

54. `CellFormatting` event'i ile hücreleri özel şekilde biçimlendirebilirsiniz. Örneğin, fiyat sütununda para birimi ekleyebilirsiniz.

55. Kullanıcı girdilerini doğrulamak için `DataError` event'ini kullanabilirsiniz.

56. İstenmeyen sütunları gizlemek için `Visible` özelliğini `false` yapabilirsiniz.

57. `SelectionMode` özelliğini değiştirerek tekli veya çoklu seçim yapabilirsiniz.

---


## 7.2. WPF (Windows Presentation Foundation)

### WPF Nedir?

**WPF (Windows Presentation Foundation)**, Microsoft tarafından geliştirilen bir GUI (Graphical User Interface) framework'üdür. WPF, masaüstü uygulamaları geliştirmek için kullanılan modern ve güçlü bir araçtır. Özellikle görsel olarak zengin, etkileşimli ve ölçeklenebilir kullanıcı arayüzleri oluşturmak için tasarlanmıştır.

Günlük hayattan bir örnek vermek gerekirse, bir sinema bileti alma uygulamasını düşünelim. Kullanıcılar film seçebilir, koltukları görsel olarak işaretleyebilir ve ödeme yapabilir. WPF, bu tür görsel olarak karmaşık ve interaktif uygulamaları kolayca geliştirmenizi sağlar.

---

### WPF Ne İçin Kullanılır?

WPF, özellikle aşağıdaki senaryolar için tercih edilir:

1. **Görsel Olarak Zengin Uygulamalar:**
   - Animasyonlar, grafikler, 3D modeller ve özel stiller içeren uygulamalar.
   - Örnek: Bir oyun kontrol paneli veya dijital sanat uygulaması.

2. **Etkileşimli Kullanıcı Arayüzleri:**
   - Kullanıcıların birçok şekilde etkileşime girebildiği dinamik arayüzler.
   - Örnek: Bir e-ticaret sitesi benzeri ürün listeleme ve filtreleme uygulaması.

3. **Veri Bağlama (Data Binding):**
   - Veri kaynaklarını (örneğin veritabanları, koleksiyonlar) kullanıcı arayüzüne bağlamak için idealdir.
   - Örnek: Bir raporlama uygulamasında verileri tablo şeklinde gösterme.

4. **Özelleştirilebilir Stiller ve Şablonlar:**
   - Kontrollerin görünümünü tamamen özelleştirmek için `Styles` ve `ControlTemplates` kullanılır.
   - Örnek: Özel butonlar, metin kutuları veya listeler tasarlamak.

5. **Çoklu Ortam Desteği:**
   - Resimler, videolar, sesler ve dokümanlar gibi farklı medya türlerini entegre etmek için kullanılır.
   - Örnek: Bir eğitim uygulamasında video oynatma veya PDF görüntüleme.

6. **MVVM (Model-View-ViewModel) Deseni:**
   - WPF, MVVM desenini destekler. Bu, kodun daha düzenli, test edilebilir ve sürdürülebilir olmasını sağlar.
   - Örnek: Büyük ölçekli projelerde arayüz ile iş mantığını ayırma.

---

### WPF Ne Zaman Tercih Edilir?

WPF, aşağıdaki durumlarda tercih edilir:

1. **Modern ve Görsel Olarak Karmaşık Uygulamalar:**
   - Eğer uygulamanızda animasyonlar, grafikler veya özel görünümler gerekiyorsa, WPF en iyi seçenektir.

2. **Veri Odaklı Uygulamalar:**
   - Veri bağlama ve dinamik içerik güncellemesi gerektiren projelerde WPF'nin data binding özellikleri faydalıdır.

3. **Özelleştirilebilirlik İhtiyacı:**
   - Standart kontrollerin yerine tamamen özelleştirilmiş bir arayüz tasarlamak istiyorsanız, WPF'nin `Styles` ve `ControlTemplates` özellikleri size esneklik sağlar.

4. **MVVM Desenini Kullanmak İsteyen Projeler:**
   - Büyük ölçekli projelerde, arayüz ile iş mantığını ayırmak için MVVM deseni kullanmak istiyorsanız, WPF idealdir.

5. **Çoklu Platform Destekli Olmayan Projeler:**
   - Eğer uygulamanız yalnızca Windows üzerinde çalışacaksa, WPF en uygun seçenektir. Ancak çapraz platform desteği gerekiyorsa (örneğin macOS veya Linux), alternatif olarak **MAUI** veya **Avalonia** gibi araçlar tercih edilebilir.

6. **Performans ve Ölçeklenebilirlik:**
   - WPF, DirectX tabanlıdır ve grafik performansı açısından güçlüdür. Bu nedenle, yüksek performans gerektiren uygulamalar için uygundur.

---

### WPF'nin Avantajları

1. **Görsel Tasarım Esnekliği:**
   - XAML ile bildirimli (declarative) tasarım yapabilirsiniz. Bu, arayüzleri daha kolay tasarlamayı ve düzenlemeyi sağlar.

2. **Veri Bağlama (Data Binding):**
   - Veri kaynaklarını doğrudan arayüz elemanlarına bağlayabilirsiniz. Bu, veri güncellemelerini otomatikleştirir.

3. **MVVM Desteği:**
   - MVVM deseni sayesinde, arayüz kodu ile iş mantığı kodunu ayırabilirsiniz. Bu, kodun daha düzenli ve test edilebilir olmasını sağlar.

4. **Zengin Medya Desteği:**
   - Resimler, videolar, sesler ve dokümanlar gibi farklı medya türlerini kolayca entegre edebilirsiniz.

5. **Özelleştirilebilir Stiller ve Şablonlar:**
   - Kontrollerin görünümünü tamamen özelleştirebilirsiniz. Örneğin, bir butonu tamamen farklı bir şablona dönüştürebilirsiniz.

6. **DirectX Tabanlı Grafik Motoru:**
   - WPF, DirectX tabanlı bir grafik motoru kullanır. Bu, yüksek performanslı grafik işlemlerini mümkün kılar.

7. **Responsive Design:**
   - Layout panelleri (`Grid`, `StackPanel`, vb.) ve özellikler (`Auto`, `*`) ile responsive tasarım oluşturabilirsiniz.

---

### WPF'nin Dezavantajları

1. **Sadece Windows Üzerinde Çalışır:**
   - WPF, yalnızca Windows işletim sistemi üzerinde çalışır. Çapraz platform desteği yoktur.

2. **Öğrenme Eğrisi:**
   - Özellikle XAML ve MVVM deseni, yeni başlayanlar için biraz zor olabilir.

3. **Performans Sorunları:**
   - Çok fazla animasyon veya grafik içeren uygulamalarda performans sorunları yaşayabilirsiniz.

4. **Küçük Projeler İçin Fazla Karmaşık Olabilir:**
   - Basit projeler için WPF, gereksiz derecede karmaşık gelebilir. Bu tür durumlarda **Windows Forms** daha uygun olabilir.

---

### Windows Forms ile Karşılaştırma

| Özellik                     | **Windows Forms**                          | **WPF**                                   |
|-----------------------------|--------------------------------------------|-------------------------------------------|
| **Görsel Tasarım**          | Sınırlı özelleştirme                       | Tamamen özelleştirilebilir                |
| **Veri Bağlama**            | Temel düzeyde                             | Gelişmiş düzeyde                          |
| **Performans**              | Basit uygulamalar için yeterli             | Yüksek performanslı grafik işlemleri      |
| **Platform Desteği**        | Sadece Windows                            | Sadece Windows                            |
| **Öğrenme Eğrisi**          | Kolay                                      | Orta-Zor                                  |
| **Tasarım Araçları**        | Drag-and-drop ağırlıklı                   | XAML tabanlı                              |
| **Layout Yönetimi**         | Sınırlı                                    | Esnek layout panelleri (`Grid`, `StackPanel`, vb.) |


---

### 2. XAML Temelleri

#### 2.1. XAML Syntax ve Özellikleri

**XAML (Extensible Application Markup Language)**, WPF uygulamalarında kullanıcı arayüzlerini tanımlamak için kullanılan bir XML tabanlı dilidir. Günlük hayatta bir ev planı düşünün. Ev planındaki odalar, duvarlar ve mobilyalar, XAML'de kontroller, layout'lar ve özellikler olarak temsil edilir.

##### Temel Özellikler:
- **Declarative Syntax:** XAML, kontrolleri ve özellikleri bildirimli (declarative) bir şekilde tanımlar. Örneğin:
  ```xml
  <Button Content="Tıkla" Width="100" Height="50" />
  ```
  Bu, bir buton oluşturur ve metnini "Tıkla" olarak ayarlar.

- **Hierarchical Structure:** XAML, hiyerarşik bir yapıya sahiptir. Örneğin, bir `Grid` içinde birden fazla kontrol yer alabilir:
  ```xml
  <Grid>
      <TextBlock Text="Merhaba Dünya!" />
      <Button Content="Tamam" />
  </Grid>
  ```

- **Data Binding:** XAML, veri bağlamayı destekler. Örneğin, bir `TextBox`'ın metni bir özelliğe bağlanabilir:
  ```xml
  <TextBox Text="{Binding Ad}" />
  ```

- **Styles and Templates:** XAML, kontrollerin görünümünü özelleştirmek için stiller ve şablonlar sağlar. Örneğin:
  ```xml
  <Style TargetType="Button">
      <Setter Property="Background" Value="LightBlue" />
      <Setter Property="FontSize" Value="16" />
  </Style>
  ```

---

#### 2.2. Layout Panelleri

**Layout panelleri**, kontrollerin ekranda nasıl düzenleneceğini belirler. WPF'de çeşitli layout panelleri bulunur:

1. **Grid:**
   - Kontrolleri satır ve sütunlara böler.
   - Günlük hayatta bir Excel tablosu gibi düşünebilirsiniz.

   ```xml
   <Grid>
       <Grid.RowDefinitions>
           <RowDefinition Height="Auto" /> <!-- Otomatik yükseklik -->
           <RowDefinition Height="*" />   <!-- Kullanılabilir alanı doldur -->
       </Grid.RowDefinitions>
       <Grid.ColumnDefinitions>
           <ColumnDefinition Width="*" />
           <ColumnDefinition Width="2*" /> <!-- İkinci sütun, ilk sütunun iki katı genişlikte -->
       </Grid.ColumnDefinitions>

       <TextBlock Grid.Row="0" Grid.Column="0" Text="Ad:" />
       <TextBox Grid.Row="0" Grid.Column="1" />

       <TextBlock Grid.Row="1" Grid.Column="0" Text="Soyad:" />
       <TextBox Grid.Row="1" Grid.Column="1" />
   </Grid>
   ```

 `Grid`, kontrolleri satır ve sütunlara böler. `RowDefinition` ve `ColumnDefinition` ile boyutları belirlersiniz.

---

2. **StackPanel:**
   - Kontrolleri yatay veya dikey olarak sıralar.
   - Günlük hayatta bir raftaki kitaplar gibi düşünebilirsiniz.

   ```xml
   <StackPanel Orientation="Vertical"> <!-- Dikey düzenleme -->
       <Button Content="Buton 1" />
       <Button Content="Buton 2" />
       <Button Content="Buton 3" />
   </StackPanel>
   ```

   ```xml
   <StackPanel Orientation="Horizontal"> <!-- Yatay düzenleme -->
       <Button Content="Buton A" />
       <Button Content="Buton B" />
       <Button Content="Buton C" />
   </StackPanel>
   ```

 `StackPanel`, kontrolleri tek bir yönde (yatay veya dikey) sıralar.

---

3. **DockPanel:**
   - Kontrolleri kenarlara (üst, alt, sol, sağ) yaslar.
   - Günlük hayatta bir oda duvarına asılan posterler gibi düşünebilirsiniz.

   ```xml
   <DockPanel>
       <Button Content="Üst" DockPanel.Dock="Top" />
       <Button Content="Sol" DockPanel.Dock="Left" />
       <Button Content="Sağ" DockPanel.Dock="Right" />
       <Button Content="Alt" DockPanel.Dock="Bottom" />
       <Button Content="Orta" /> <!-- Kalan alanı doldurur -->
   </DockPanel>
   ```

 `DockPanel`, kontrolleri belirtilen kenarlara yaslar. Son kontrol, kalan alanı doldurur.

---

4. **WrapPanel:**
   - Kontrolleri satır veya sütun dolana kadar sıralar.
   - Günlük hayatta bir rafa sığmayan kitapların alt satıra geçmesi gibi düşünebilirsiniz.

   ```xml
   <WrapPanel Orientation="Horizontal"> <!-- Yatay düzenleme -->
       <Button Content="Buton 1" Width="100" />
       <Button Content="Buton 2" Width="100" />
       <Button Content="Buton 3" Width="100" />
       <Button Content="Buton 4" Width="100" />
   </WrapPanel>
   ```

 `WrapPanel`, kontrolleri satır veya sütun dolana kadar sıralar. Yer kalmazsa, bir sonraki satıra geçer.

---

5. **Canvas:**
   - Kontrolleri kesin koordinatlarla konumlandırır.
   - Günlük hayatta bir resim çerçevesinde nesneleri belirli noktalara yerleştirmek gibi düşünebilirsiniz.

   ```xml
   <Canvas>
       <Button Content="Sol Üst" Canvas.Left="10" Canvas.Top="10" />
       <Button Content="Sağ Alt" Canvas.Right="10" Canvas.Bottom="10" />
   </Canvas>
   ```

 `Canvas`, kontrolleri kesin koordinatlarla (`Left`, `Top`, `Right`, `Bottom`) konumlandırır.

---


### 3. Data Binding

#### 3.1. One-Way ve Two-Way Binding

**Data Binding**, bir kontrolün veri kaynağındaki verilerle otomatik olarak senkronize olmasını sağlar. WPF'de iki temel binding türü vardır:

1. **One-Way Binding:**
   - Veri kaynağındaki değişiklikler, kullanıcı arayüzünde otomatik olarak yansır.
   - Ancak, kullanıcı arayüzündeki değişiklikler veri kaynağını etkilemez.
   - Örnek: Bir metin kutusunda bir değeri göstermek, ancak kullanıcı tarafından düzenlenmesine izin vermemek.

   ```xml
   <TextBox Text="{Binding Ad, Mode=OneWay}" />
   ```

   - **Açıklama:** `Ad` özelliği, yalnızca veri kaynağından TextBox'a aktarılır. Kullanıcı TextBox'ta değişiklik yapamaz.

---

2. **Two-Way Binding:**
   - Veri kaynağındaki değişiklikler, kullanıcı arayüzünde yansır.
   - Aynı zamanda, kullanıcı arayüzündeki değişiklikler de veri kaynağını günceller.
   - Örnek: Bir metin kutusunda bir değeri hem göstermek hem de düzenlemek.

   ```xml
   <TextBox Text="{Binding Ad, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
   ```

   - **Açıklama:** `Ad` özelliği, hem veri kaynağından TextBox'a hem de TextBox'tan veri kaynağına aktarılır. `UpdateSourceTrigger=PropertyChanged`, her karakter değişikliğinde veri kaynağını günceller.

---

#### 3.2. `INotifyPropertyChanged` Interface'i**

**`INotifyPropertyChanged`**, veri kaynağında yapılan değişiklikleri kullanıcı arayüzüne bildirmek için kullanılan bir interfacedir. Özellikle **MVVM (Model-View-ViewModel)** deseniyle birlikte sıkça kullanılır.

##### Neden `INotifyPropertyChanged` Kullanılır?**
- Data binding, veri kaynağında yapılan değişiklikleri otomatik olarak kullanıcı arayüzünde yansıtmak için bu interface'i kullanır.
- Eğer `INotifyPropertyChanged` uygulanmazsa, veri kaynağında yapılan değişiklikler kullanıcı arayüzünde güncellenmez.

---

##### Örnek: `INotifyPropertyChanged` ile Two-Way Binding

Bu örnekte, bir ViewModel sınıfı oluşturacağız ve `INotifyPropertyChanged` interface'ini uygulayacağız.

```csharp
// ViewModel sınıfı
public class KisiViewModel : INotifyPropertyChanged
{
    private string ad;

    // Ad özelliği
    public string Ad
    {
        get => ad;
        set
        {
            if (ad != value)
            {
                ad = value;
                OnPropertyChanged(nameof(Ad)); // Değişikliği bildir
            }
        }
    }

    // PropertyChanged event'i
    public event PropertyChangedEventHandler PropertyChanged;

    // OnPropertyChanged metodu
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

---

##### XAML Kodu:

```xml
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Data Binding Örneği" Height="200" Width="400">
    <Grid>
        <!-- TextBox ile Two-Way Binding -->
        <TextBox Text="{Binding Ad, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" 
                 Width="200" Height="30" Margin="10" />

        <!-- Label ile One-Way Binding -->
        <Label Content="{Binding Ad, Mode=OneWay}" 
               Width="200" Height="30" Margin="10,50,10,10" />
    </Grid>
</Window>
```

---

##### Code-Behind Kodu:

```csharp
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();

        // ViewModel'i bağla
        DataContext = new KisiViewModel { Ad = "Ali" };
    }
}
```

  - `TextBox`, `Ad` özelliğini iki yönlü olarak bağlar. Kullanıcı TextBox'ta değişiklik yaptığında, `Ad` özelliği güncellenir.
  - `Label`, `Ad` özelliğini tek yönlü olarak bağlar. Veri kaynağında yapılan değişiklikler, Label'da yansır.

---

#### 3.3. Örnekler ile Pekiştirme

##### Örnek 1: ComboBox ile One-Way Binding
Bu örnekte, bir `ComboBox`'a bir liste bağlayacağız ve seçilen öğeyi bir `Label`'da göstereceğiz.

```xml
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="ComboBox Örneği" Height="200" Width="400">
    <Grid>
        <!-- ComboBox ile One-Way Binding -->
        <ComboBox ItemsSource="{Binding Urunler}" 
                  SelectedItem="{Binding SeciliUrun, Mode=TwoWay}" 
                  Width="200" Height="30" Margin="10" />

        <!-- Label ile One-Way Binding -->
        <Label Content="{Binding SeciliUrun, Mode=OneWay}" 
               Width="200" Height="30" Margin="10,50,10,10" />
    </Grid>
</Window>
```

```csharp
public class UrunViewModel : INotifyPropertyChanged
{
    private string seciliUrun;

    public List<string> Urunler { get; set; } = new List<string> { "Elma", "Armut", "Çilek" };

    public string SeciliUrun
    {
        get => seciliUrun;
        set
        {
            if (seciliUrun != value)
            {
                seciliUrun = value;
                OnPropertyChanged(nameof(SeciliUrun));
            }
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

  - `ComboBox`, `Urunler` listesine bağlanır. Kullanıcı bir ürün seçtiğinde, `SeciliUrun` özelliği güncellenir.
  - `Label`, `SeciliUrun` özelliğini tek yönlü olarak bağlar.

---


### 4. Command ve Event Handling

#### 4.1. `ICommand` Interface'i ve Command Binding

**`ICommand`**, WPF'de komut tabanlı işlemler için kullanılan bir interfacedir. Özellikle **MVVM (Model-View-ViewModel)** deseniyle birlikte sıkça kullanılır. `ICommand`, kullanıcı etkileşimlerini (örneğin buton tıklama) iş mantığından ayırır.

##### Neden `ICommand` Kullanılır?
- Komutlar, kodun daha düzenli ve test edilebilir olmasını sağlar.
- Aynı komutu birden fazla kontrolde yeniden kullanabilirsiniz.
- Örnek: Bir butona tıklandığında veya bir menü öğesine tıklandığında aynı işlemi gerçekleştirmek.

---

##### `ICommand` Interface'i

`ICommand`, iki temel metot içerir:
1. **`Execute(object parameter)`**: Komut çalıştırıldığında çağrılır.
2. **`CanExecute(object parameter)`**: Komutun çalıştırılıp çalıştırılamayacağını belirler.

Ayrıca, `CanExecuteChanged` event'i, komutun çalıştırılabilir durumu değiştiğinde tetiklenir.

---

##### Örnek: `ICommand` ile Buton Tıklama

Bu örnekte, bir ViewModel sınıfı oluşturacağız ve `ICommand` interface'ini uygulayacağız.

```csharp
// ViewModel sınıfı
public class AnaSayfaViewModel
{
    public ICommand KaydetCommand { get; }

    public AnaSayfaViewModel()
    {
        KaydetCommand = new RelayCommand(Kaydet, CanKaydet);
    }

    // Execute metodu
    private void Kaydet(object parameter)
    {
        MessageBox.Show("Kaydedildi!");
    }

    // CanExecute metodu
    private bool CanKaydet(object parameter)
    {
        // Örnek olarak, her zaman kaydedilebilir
        return true;
    }
}
```

---

##### RelayCommand Sınıfı

`RelayCommand`, `ICommand` interface'ini uygulayan bir yardımcı sınıftır. Kendi `RelayCommand` sınıfınızı oluşturabilirsiniz:

```csharp
public class RelayCommand : ICommand
{
    private readonly Action<object> _execute;
    private readonly Predicate<object> _canExecute;

    public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }

    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute(parameter);
    }

    public void Execute(object parameter)
    {
        _execute(parameter);
    }

    public event EventHandler CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }
}
```

---

##### XAML Kodu:

```xml
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Command Örneği" Height="200" Width="400">
    <Window.DataContext>
        <local:AnaSayfaViewModel />
    </Window.DataContext>
    <Grid>
        <!-- Button ile Command Binding -->
        <Button Content="Kaydet" 
                Command="{Binding KaydetCommand}" 
                Width="100" Height="30" Margin="10" />
    </Grid>
</Window>
```

  - `Button`, `KaydetCommand` komutuna bağlanır.
  - Komut, `Execute` metodu aracılığıyla çalıştırılır.
  - `CanExecute` metodu, butonun aktif olup olmayacağını belirler.

---

#### 4.2. Routed Events ve Event Handling

**Routed Events**, WPF'de olayların nasıl yayıldığını (bubbling veya tunneling) tanımlar. Bu, özellikle karmaşık arayüzlerde faydalıdır.

##### Routed Event Türleri:
1. **Bubbling:** Olay, en içteki kontrolden başlayarak dışarı doğru ilerler.
   - Örnek: Bir butona tıklandığında, önce buton, sonra kapsayan panel, en son da pencere olayı işler.

2. **Tunneling:** Olay, en dıştaki kontrolden başlayarak içeri doğru ilerler.
   - Örnek: Bir pencerede bir butona tıklandığında, önce pencere, sonra panel, en son da buton olayı işler.

---

##### Örnek: Bubbling ve Tunneling

Bu örnekte, bir `StackPanel` içinde bir `Button` yer alır. Hem bubbling hem de tunneling olaylarını ele alacağız.

```xml
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Routed Events Örneği" Height="200" Width="400">
    <StackPanel PreviewMouseDown="StackPanel_PreviewMouseDown" MouseDown="StackPanel_MouseDown">
        <Button Content="Tıkla" 
                PreviewMouseDown="Button_PreviewMouseDown" 
                MouseDown="Button_MouseDown" 
                Width="100" Height="30" Margin="10" />
    </StackPanel>
</Window>
```

---

##### Code-Behind Kodu:

```csharp
private void StackPanel_PreviewMouseDown(object sender, MouseButtonEventArgs e)
{
    MessageBox.Show("StackPanel Tunneling");
}

private void StackPanel_MouseDown(object sender, MouseButtonEventArgs e)
{
    MessageBox.Show("StackPanel Bubbling");
}

private void Button_PreviewMouseDown(object sender, MouseButtonEventArgs e)
{
    MessageBox.Show("Button Tunneling");
}

private void Button_MouseDown(object sender, MouseButtonEventArgs e)
{
    MessageBox.Show("Button Bubbling");
}
```

  - `PreviewMouseDown`: Tunneling olayıdır.
  - `MouseDown`: Bubbling olayıdır.
  - Butona tıklandığında, önce tunneling (`PreviewMouseDown`) ardından bubbling (`MouseDown`) gerçekleşir.

---


### 5. Styling ve Templating

#### 5.1. Stil Tanımlama ve Uygulama

**Stil**, bir kontrolün görünümünü özelleştirmek için kullanılan bir araçtır. Stiller, CSS'deki gibi, kontrollerin özelliklerini merkezi olarak tanımlamanızı sağlar. Bu, tekrar kullanılabilirlik ve tutarlılık sağlar.

##### Neden Stil Kullanılır?**
- Aynı görünümü birden fazla kontrolde kullanmak için stil tanımlayabilirsiniz.
- Örnek: Tüm butonların aynı arka plan rengi, yazı tipi ve boyuta sahip olmasını sağlamak.

---

##### Örnek: Basit Bir Stil Tanımlama

Bu örnekte, tüm `Button` kontrolleri için bir stil tanımlayacağız.

```xml
<Window.Resources>
    <!-- Buton için stil tanımlama -->
    <Style TargetType="Button">
        <Setter Property="Background" Value="LightBlue" />
        <Setter Property="Foreground" Value="White" />
        <Setter Property="FontSize" Value="16" />
        <Setter Property="Padding" Value="10,5" />
        <Setter Property="Margin" Value="5" />
    </Style>
</Window.Resources>

<Grid>
    <Button Content="Buton 1" />
    <Button Content="Buton 2" Margin="0,40,0,0" />
</Grid>
```
  `Style`, tüm `Button` kontrollerinin arka plan rengini, yazı rengini, font boyutunu ve dolgu değerlerini ayarlar.

---

##### Örnek: İsimli Stil Tanımlama ve Uygulama

Bu örnekte, bir isim verilen stil tanımlayacağız ve belirli kontrollerde kullanacağız.

```xml
<Window.Resources>
    <!-- İsimli stil tanımlama -->
    <Style x:Key="OzelButonStili" TargetType="Button">
        <Setter Property="Background" Value="Orange" />
        <Setter Property="Foreground" Value="Black" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="Padding" Value="8,4" />
    </Style>
</Window.Resources>

<Grid>
    <!-- İsimli stili uygulama -->
    <Button Content="Özel Buton" Style="{StaticResource OzelButonStili}" />
    <Button Content="Normal Buton" Margin="0,40,0,0" />
</Grid>
```
  `x:Key` ile isim verilen stil, yalnızca belirtilen kontrollerde kullanılır.

---

#### 5.2. Control Template Kullanımı

**Control Template**, bir kontrolün görsel yapısını tamamen değiştirmenizi sağlar. Özellikle standart kontrollerin görünümünü özelleştirmek için kullanılır.

##### Neden Control Template Kullanılır?
- Standart kontrollerin görünümünü değiştirerek özelleştirilmiş bir arayüz oluşturabilirsiniz.
- Örnek: Bir butonun yerine özel bir şekil veya grafik kullanmak.

---

##### Örnek: Button için Özelleştirilmiş Control Template

Bu örnekte, bir `Button`'un görünümünü tamamen değiştireceğiz.

```xml
<Window.Resources>
    <!-- Button için Control Template -->
    <ControlTemplate x:Key="KareButonTemplate" TargetType="Button">
        <Border Background="Green" CornerRadius="10" Padding="10">
            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center" />
        </Border>
    </ControlTemplate>
</Window.Resources>

<Grid>
    <!-- Control Template'i uygulama -->
    <Button Content="Kare Buton" Template="{StaticResource KareButonTemplate}" Width="150" Height="50" />
</Grid>
```
  `ControlTemplate`, butonun görünümünü bir `Border` ile sarar ve köşeleri yuvarlatır.

---

#### 5.3. Data Template Kullanımı

**Data Template**, veri nesnelerinin nasıl görüntüleneceğini tanımlar. Özellikle koleksiyonlar veya veri bağlama işlemleri için faydalıdır.

##### Neden Data Template Kullanılır?
- Veri nesnelerini özel bir şekilde göstermek için kullanılır.
- Örnek: Bir liste kutusunda her bir öğeyi özel bir şablonla görüntülemek.

---

##### Örnek: ListBox için Data Template

Bu örnekte, bir `ListBox` içindeki öğeleri özel bir şablonla göstereceğiz.

```xml
<Window.Resources>
    <!-- Data Template tanımlama -->
    <DataTemplate x:Key="UrunTemplate">
        <StackPanel Orientation="Horizontal" Margin="5">
            <TextBlock Text="{Binding Ad}" FontSize="16" FontWeight="Bold" />
            <TextBlock Text=" - " />
            <TextBlock Text="{Binding Fiyat, StringFormat='{}{0:C}'}" FontSize="14" Foreground="Gray" />
        </StackPanel>
    </DataTemplate>
</Window.Resources>

<Grid>
    <!-- Data Template'i uygulama -->
    <ListBox ItemsSource="{Binding Urunler}" ItemTemplate="{StaticResource UrunTemplate}" Width="300" Height="150" />
</Grid>
```

```csharp
// ViewModel sınıfı
public class UrunViewModel
{
    public List<Urun> Urunler { get; set; }

    public UrunViewModel()
    {
        Urunler = new List<Urun>
        {
            new Urun { Ad = "Laptop", Fiyat = 5000 },
            new Urun { Ad = "Telefon", Fiyat = 3000 },
            new Urun { Ad = "Tablet", Fiyat = 2000 }
        };
    }
}

// Ürün sınıfı
public class Urun
{
    public string Ad { get; set; }
    public decimal Fiyat { get; set; }
}
```
  `DataTemplate`, her bir ürünün adını ve fiyatını özel bir düzen ile gösterir.

---

#### Püf Noktalar

1. Windows Forms, masaüstü uygulamaları geliştirmek için kullanılan bir GUI framework'üdür. Özellikle .NET ekosisteminde sıkça tercih edilir.

2. Görsel tasarım yaparken formunuzu düzenli tutmak için bileşenlerin boyutlarını ve yerleşimlerini dikkatlice ayarlayın. Kullanıcı deneyimini artırmak için `Anchor` ve `Dock` özelliklerini kullanarak bileşenlerin pencere boyutuna uyum sağlamasını sağlayın.  

3. Her bileşenin belirli olayları vardır (örneğin `Click`, `TextChanged`). Bu olaylara işleyiciler ekleyerek kullanıcı etkileşimlerini yönetebilirsiniz. Örneğin, bir butonun tıklanma olayını yakalamak için `Click` olayını kullanın.  

4. Bileşenleri dinamik olarak oluşturmak, özellikle karmaşık veya özelleştirilmiş arayüzler için faydalıdır. Örneğin, bir liste kutusu veya butonu kod üzerinden oluşturabilir ve özelliklerini programlı olarak ayarlayabilirsiniz.  

5. `Form1.cs` ile `Form1.Designer.cs` arasındaki ilişkiyi anlamak önemlidir. Designer dosyası, görsel tasarımın kod karşılığını içerir. Bu dosyayı manuel olarak değiştirmekten kaçının.  

6. Resimler, ikonlar gibi kaynak dosyalarını `Resources` klasörü altında saklayın. Bu, projenizin düzenli kalmasını sağlar ve kaynak dosyalarını kolayca yönetmenizi sağlar.  

7. Bağlantı dizeleri, kullanıcı tercihleri gibi ayarları `Settings.settings` dosyasında saklayın. Bu, uygulama ayarlarınızı merkezi bir yerde yönetmenizi sağlar.  

8. Uygulamanızı geliştirirken `Debug` modunu kullanın. Yayınlamadan önce `Release` moduna geçiş yapmayı unutmayın. `Release` modu, performansı optimize edilmiş bir yapı sunar.  

9. Büyük resimler veya çok sayıda bileşen içeren formlarda performans sorunları yaşayabilirsiniz. Gereksiz bileşenleri kaldırın veya yükleme sürelerini optimize edin. Örneğin, büyük resimleri küçültün veya gerekli olduğunda yükleyin.  

10. Kullanıcı deneyimini artırmak için butonlara anlamlı isimler verin, metin kutularına placeholder (ipucu) ekleyin ve hata mesajlarını net bir şekilde gösterin. Örneğin, bir metin kutusu için "Adınızı girin" yazısı ekleyin.  

11. Form üzerindeki bileşenleri gruplamak için `Panel` veya `GroupBox` bileşenlerini kullanın. Bu, arayüzü daha düzenli ve kullanıcı dostu hale getirir.  

12. Birden fazla form kullanan uygulamalarda, formlar arasında veri aktarımı için `Constructor`, `Properties` veya `Events` kullanabilirsiniz. Örneğin, bir formdan diğerine veri göndermek için constructor parametreleri ekleyebilirsiniz.  

13. Kullanıcı girdilerini doğrulamak için `ErrorProvider` bileşenini kullanın. Bu, kullanıcıların yanlış giriş yaptığında anında geri bildirim almasını sağlar.  

14. Uygulamanızda tema desteği eklemek için `BackColor`, `ForeColor` gibi özellikleri kullanarak bileşenlerin renklerini özelleştirin. Ayrıca, modern görünümler için `FlatStyle` özelliğini kullanabilirsiniz.  

15. Veritabanı işlemleri yaparken, uzun sürecek işlemler için asenkron programlama (`async/await`) kullanın. Bu, uygulamanızın donmasını engeller ve kullanıcı deneyimini artırır.  

16. Formunuzu farklı çözünürlüklerde iyi görünmesini sağlamak için `AutoSize` ve `AutoSizeMode` özelliklerini kullanın. Ayrıca, font boyutlarını ölçeklenebilir hale getirin.  

17. Uygulamanızda birden fazla dil desteği eklemek için `ResourceManager` sınıfını kullanabilirsiniz. Bu, uygulamanızı küresel hale getirir.  

18. Form üzerindeki bileşenlerin sıralamasını düzenlemek için `TabIndex` özelliğini kullanın. Bu, klavye ile gezinmeyi kolaylaştırır.  

19. Uygulamanızda grafiksel işlemler yapmak için `Graphics` sınıfını kullanabilirsiniz. Örneğin, bir çizim uygulaması oluşturmak için `Paint` olayını kullanabilirsiniz.  

20. Uygulamanızın kapatılması sırasında kaydedilmemiş değişiklikler varsa kullanıcıyı uyarmak için `FormClosing` olayını kullanın.  

21. Uygulamanızda kısa yollar (shortcuts) eklemek için `KeyPreview` özelliğini `true` yapın ve `KeyDown` olayını kullanın. Örneğin, `Ctrl+S` ile bir işlem tetikleyebilirsiniz.  

22. Form üzerindeki bileşenleri düzenlemek için `TableLayoutPanel` veya `FlowLayoutPanel` gibi düzen bileşenlerini kullanın. Bu, bileşenlerin otomatik olarak düzenlenmesini sağlar.  

23. Uygulamanızda ilerleme durumunu göstermek için `ProgressBar` bileşenini kullanabilirsiniz. Örneğin, bir dosya yükleme işlemi sırasında ilerleme çubuğu ekleyebilirsiniz.  

24. Form üzerindeki bileşenlerin görünürlüğünü kontrol etmek için `Visible` özelliğini kullanın. Örneğin, bir butonu belirli koşullar altında göstermek veya gizlemek için bu özelliği değiştirin.  

25. Uygulamanızda özel stiller eklemek için `Custom Controls` oluşturabilirsiniz. Örneğin, bir özel buton tasarlayabilir ve tüm projede yeniden kullanabilirsiniz.  

26. Kullanıcı girdisini her zaman kontrol edin. Örneğin, boş girişleri engellemek için `string.IsNullOrEmpty` kullanın.  

27. `Items.Add` ile veri ekleyebilir veya bir koleksiyonu direkt olarak bağlayabilirsiniz (`DataSource` özelliği).  

28. Her olayın ne zaman tetikleneceğini anlayın. Örneğin, `TextChanged` olayı, TextBox'taki her karakter değişikliğinde çalışır.  

29. Büyük resimleri küçültmek için `Image.GetThumbnailImage` yöntemini kullanabilirsiniz.  

30. Örneğin, bir butonu belirli koşullar altında etkinleştirmek için `Enabled` özelliğini değiştirin.  

31. `SelectionMode` özelliğini `MultiSimple` veya `MultiExtended` olarak ayarlayarak çoklu seçim sağlayın.  

32. `TableLayoutPanel` veya `FlowLayoutPanel` gibi düzen bileşenleri, kontrollerin otomatik olarak düzenlenmesini sağlar.  

33. Kullanıcıya net geri bildirim sağlamak için `MessageBox.Show` ile hata mesajları gösterin.  

34. Visual Studio'da bir kontrolü çift tıklayarak otomatik olarak event handler oluşturabilirsiniz. Örneğin, bir butonu çift tıklayarak `Click` event handler'ını oluşturabilirsiniz.  

35. `sender`, olayı tetikleyen kontrolü belirtir. Birden fazla kontrol aynı event handler'ı kullanıyorsa, `sender` üzerinden kontrolü tanımlayabilirsiniz.  

36. `EventArgs`, olayla ilgili ek bilgiler içerir. Örneğin, `KeyPressEventArgs` ile basılan tuşu kontrol edebilirsiniz.  

37. Tasarım zamanında değil, çalışma zamanında event bağlamak için `+=` operatörünü kullanabilirsiniz.  

38. Kullanılmayan eventleri temizleyin. Aksi halde, gereksiz bellek tüketimi olabilir.  

39. Kullanıcı girdisini anlık olarak kontrol etmek için `TextChanged` event'ini kullanabilirsiniz.  

40. Butonların veya diğer kontrollerin görünümünü dinamik olarak değiştirmek için `MouseEnter` ve `MouseLeave` eventlerini kullanabilirsiniz.  

41. Klavye girişlerini kontrol etmek için `KeyPress`, `KeyDown` veya `KeyUp` eventlerini kullanabilirsiniz. Örneğin, Enter tuşuna basıldığında bir işlem gerçekleştirmek için `KeyDown` event'ini kullanabilirsiniz.  

42. Birden fazla kontrol aynı event handler'ı kullanabilir. Örneğin, birden fazla buton için tek bir `Click` event handler'ı yazabilirsiniz.  

43. Veri kaynağı olarak koleksiyonlar (örneğin `List<T>`), veritabanı tabloları veya XML dosyaları kullanılabilir.  

44. `BindingSource`, veri kaynağını soyutlar ve kontrollerle ilişkilendirmeyi kolaylaştırır. Veri kaynağındaki değişiklikler, kontrollerde otomatik olarak yansıtılır.  

45. `BindingNavigator`'ın varsayılan düğmelerini kaldırabilir veya yeni düğmeler ekleyebilirsiniz.  

46. `DataGridView`, büyük veri setlerini göstermek için idealdir. Ancak performans açısından optimize etmek için `VirtualMode` özelliğini kullanabilirsiniz.  

47. `DataSource` özelliğini kullanarak veri kaynağındaki değişiklikleri anında yansıtın.  

48. Veri doğrulama sırasında hataları yakalamak için `BindingSource`'un `CurrentItemChanged` event'ini kullanabilirsiniz.  

49. Aynı veri kaynağına birden fazla kontrol bağlayarak tutarlılığı sağlayın.  

50. Çalışma zamanında `BindingSource`'un `DataSource` özelliğini değiştirerek farklı veri kaynaklarını bağlayabilirsiniz.  

51. Düzenleme izni vermek istemediğiniz sütunları `ReadOnly` yaparak koruyabilirsiniz.  

52. `CellClick`, `CellDoubleClick` ve `CellValueChanged` gibi eventler, kullanıcı etkileşimlerini yönetmek için faydalıdır.  

53. Büyük veri setleri için `VirtualMode` özelliğini kullanarak performansı artırabilirsiniz.  

54. `CellFormatting` event'i ile hücreleri özel şekilde biçimlendirebilirsiniz. Örneğin, fiyat sütununda para birimi ekleyebilirsiniz.  

55. Kullanıcı girdilerini doğrulamak için `DataError` event'ini kullanabilirsiniz.  

56. İstenmeyen sütunları gizlemek için `Visible` özelliğini `false` yapabilirsiniz.  

57. `SelectionMode` özelliğini değiştirerek tekli veya çoklu seçim yapabilirsiniz.