## 6. Veritabanı İşlemleri

### 6.1. ADO.NET

#### 1. Temel Kavramlar

##### 1.1. Veritabanı Bağlantısı (`SqlConnection`)

Veritabanı işlemlerinin temeli, veritabanına bağlanmaktır. Günlük hayatta bir banka şubesine girdiğinizi düşünelim. Şube kapısını açmak için anahtar kullanmanız gerekiyor. İşte bu anahtar, `SqlConnection` nesnesi gibidir.

`SqlConnection`, SQL Server veritabanına bağlanmak için kullanılan bir sınıftır. Bir bağlantı dizesi (connection string) ile veritabanına erişim sağlanır. Bu bağlantı dizesi, veritabanının adresini, kullanıcı adını, şifresini ve diğer yapılandırma bilgilerini içerir.

###### **Örnek: Veritabanına Bağlanma**

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main()
    {
        // Bağlantı dizesi: Veritabanı bilgilerini içerir
        string connectionString = "Server=localhost;Database=OrnekDB;User Id=sa;Password=12345;";

        // SqlConnection nesnesi oluştur
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                // Veritabanına bağlan
                connection.Open();
                Console.WriteLine("Veritabanına başarıyla bağlandı.");
            }
            catch (Exception ex)
            {
                // Bağlantı sırasında hata oluşursa yakala
                Console.WriteLine($"Hata: {ex.Message}");
            }
        }
    }
}
```

- `connectionString`, veritabanına erişmek için gerekli bilgileri içerir. Örneğin:
  - `Server`: Veritabanı sunucusunun adresi (örneğin `localhost`).
  - `Database`: Kullanılacak veritabanının adı.
  - `User Id` ve `Password`: Veritabanına erişim için kullanıcı adı ve şifre.
- `SqlConnection`, veritabanına fiziksel olarak bağlanmak için kullanılır.
- `connection.Open()`, bağlantıyı başlatır. Eğer bağlantı başarısız olursa, bir hata fırlatılır ve `catch` bloğu çalışır.

---

##### 1.2. Veritabanı Komutları (`SqlCommand`)

Veritabanına bağlandıktan sonra, veritabanında işlem yapmak için komutlar göndermeniz gerekir. Günlük hayatta bir banka memuruna bir talep iletirsiniz. Örneğin, "Bakiyemi sorgula" veya "Para yatır" gibi. İşte bu, `SqlCommand` sınıfının rolü gibidir.

`SqlCommand`, SQL sorgularını veya saklı yordamları (stored procedures) çalıştırmak için kullanılır. Sorgu sonucunda veri döndürülmesi veya güncelleme işlemleri yapılabilir.

###### **Örnek: Veritabanında Sorgu Çalıştırma**

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main()
    {
        // Bağlantı dizesi
        string connectionString = "Server=localhost;Database=OrnekDB;User Id=sa;Password=12345;";

        // SQL sorgusu
        string query = "SELECT Ad, Yas FROM Kisiler WHERE Yas > @yas";

        // SqlConnection ve SqlCommand kullanımı
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                // Bağlantıyı aç
                connection.Open();

                // SqlCommand nesnesi oluştur
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    // Parametre ekle
                    command.Parameters.AddWithValue("@yas", 20);

                    // Sorguyu çalıştır ve sonuçları oku
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            string ad = reader["Ad"].ToString();
                            int yas = Convert.ToInt32(reader["Yas"]);
                            Console.WriteLine($"Ad: {ad}, Yaş: {yas}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Hata: {ex.Message}");
            }
        }
    }
}
```

- `SqlCommand`, SQL sorgusunu veya saklı yordamı çalıştırmak için kullanılır.
- `command.Parameters.AddWithValue`, sorguya parametre ekler. Bu, SQL enjeksiyon saldırılarını önlemek için önemlidir.
- `command.ExecuteReader()`, sorgu sonucunu okumak için kullanılır. `SqlDataReader`, veriyi satır satır okur.

---

##### 1.3. Veri Okuma (`SqlDataReader`)

Veritabanından veri okumak için `SqlDataReader` kullanılır. Günlük hayatta bir kitaptan bilgi almak gibi düşünebilirsiniz. Kitabın her sayfasını tek tek okuyorsunuz. İşte bu, `SqlDataReader`'ın yaptığı iş gibidir.

`SqlDataReader`, veritabanından gelen verileri hızlı ve etkili bir şekilde okur. Ancak, yalnızca ileri yönlü (forward-only) okuma yapar. Yani, bir kez okunan veriye geri dönemezsiniz.

###### **Örnek: Veritabanından Veri Okuma**

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main()
    {
        // Bağlantı dizesi
        string connectionString = "Server=localhost;Database=OrnekDB;User Id=sa;Password=12345;";

        // SQL sorgusu
        string query = "SELECT Ad, Meslek FROM Kisiler";

        // SqlConnection ve SqlDataReader kullanımı
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                // Bağlantıyı aç
                connection.Open();

                // SqlCommand nesnesi oluştur
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    // SqlDataReader ile veri okuma
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            string ad = reader.GetString(0); // İlk sütun (Ad)
                            string meslek = reader.GetString(1); // İkinci sütun (Meslek)
                            Console.WriteLine($"Ad: {ad}, Meslek: {meslek}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Hata: {ex.Message}");
            }
        }
    }
}
```

- `SqlDataReader`, veritabanından gelen verileri satır satır okur.
- `reader.GetString(0)` ve `reader.GetString(1)`, sırasıyla ilk ve ikinci sütunlardaki verileri okur.
- `SqlDataReader`, yalnızca ileri yönlü okuma yaptığı için performans açısından oldukça etkilidir.

---


#### 2. CRUD İşlemleri

CRUD işlemleri, veritabanı işlemlerinin temel taşlarını oluşturur. Günlük hayatta bir alışveriş listesi düşünelim:
- Listeye yeni bir ürün eklemek (`INSERT`),
- Listenin içindeki ürünleri görmek (`SELECT`),
- Bir ürünün adını veya miktarını değiştirmek (`UPDATE`),
- Artık gerekli olmayan bir ürünü listeden çıkarmak (`DELETE`).

Bu işlemler, veritabanında da benzer şekilde gerçekleştirilir.

---

##### 2.1. Veri Ekleme (INSERT)

Veri ekleme işlemi, veritabanına yeni bir kayıt eklemek için kullanılır. Örneğin, bir müşteri bilgisi veya ürün kaydı eklemek gibi.

###### **Örnek: Veri Ekleme**

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main()
    {
        // Bağlantı dizesi
        string connectionString = "Server=localhost;Database=OrnekDB;User Id=sa;Password=12345;";

        // SQL INSERT sorgusu
        string query = "INSERT INTO Kisiler (Ad, Yas, Meslek) VALUES (@ad, @yas, @meslek)";

        // SqlConnection ve SqlCommand kullanımı
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                // Bağlantıyı aç
                connection.Open();

                // SqlCommand nesnesi oluştur
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    // Parametreleri ekle
                    command.Parameters.AddWithValue("@ad", "Ahmet");
                    command.Parameters.AddWithValue("@yas", 30);
                    command.Parameters.AddWithValue("@meslek", "Mimar");

                    // Sorguyu çalıştır
                    int etkilenenSatirSayisi = command.ExecuteNonQuery();
                    Console.WriteLine($"{etkilenenSatirSayisi} satır eklendi.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Hata: {ex.Message}");
            }
        }
    }
}
```

- `INSERT INTO Kisiler (Ad, Yas, Meslek) VALUES (@ad, @yas, @meslek)` sorgusu, `Kisiler` tablosuna yeni bir kayıt ekler.
- `command.Parameters.AddWithValue`, sorguya parametre ekler. Bu, SQL enjeksiyon saldırılarını önlemek için önemlidir.
- `command.ExecuteNonQuery()`, sorguyu çalıştırır ve etkilenen satır sayısını döndürür.

---

##### 2.2. Veri Sorgulama (SELECT)

Veri sorgulama işlemi, veritabanından bilgi almak için kullanılır. Örneğin, belirli bir yaş aralığındaki kişileri veya belirli bir meslekteki kişileri bulmak gibi.

###### **Örnek: Veri Sorgulama**

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main()
    {
        // Bağlantı dizesi
        string connectionString = "Server=localhost;Database=OrnekDB;User Id=sa;Password=12345;";

        // SQL SELECT sorgusu
        string query = "SELECT Ad, Yas FROM Kisiler WHERE Yas > @yas";

        // SqlConnection ve SqlDataReader kullanımı
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                // Bağlantıyı aç
                connection.Open();

                // SqlCommand nesnesi oluştur
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    // Parametre ekle
                    command.Parameters.AddWithValue("@yas", 25);

                    // SqlDataReader ile veri okuma
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            string ad = reader["Ad"].ToString();
                            int yas = Convert.ToInt32(reader["Yas"]);
                            Console.WriteLine($"Ad: {ad}, Yaş: {yas}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Hata: {ex.Message}");
            }
        }
    }
}
```

- `SELECT Ad, Yas FROM Kisiler WHERE Yas > @yas` sorgusu, belirli bir yaşın üzerindeki kişileri getirir.
- `SqlDataReader`, veritabanından gelen verileri satır satır okur.
- `reader["Ad"]` ve `reader["Yas"]`, sütunlardaki verilere erişmek için kullanılır.

---

##### 2.3. Veri Güncelleme (UPDATE)

Veri güncelleme işlemi, mevcut bir kaydın bilgilerini değiştirmek için kullanılır. Örneğin, bir kişinin yaşını veya mesleğini güncellemek gibi.

###### **Örnek: Veri Güncelleme**

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main()
    {
        // Bağlantı dizesi
        string connectionString = "Server=localhost;Database=OrnekDB;User Id=sa;Password=12345;";

        // SQL UPDATE sorgusu
        string query = "UPDATE Kisiler SET Yas = @yas WHERE Ad = @ad";

        // SqlConnection ve SqlCommand kullanımı
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                // Bağlantıyı aç
                connection.Open();

                // SqlCommand nesnesi oluştur
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    // Parametreleri ekle
                    command.Parameters.AddWithValue("@yas", 35);
                    command.Parameters.AddWithValue("@ad", "Ahmet");

                    // Sorguyu çalıştır
                    int etkilenenSatirSayisi = command.ExecuteNonQuery();
                    Console.WriteLine($"{etkilenenSatirSayisi} satır güncellendi.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Hata: {ex.Message}");
            }
        }
    }
}
```

- `UPDATE Kisiler SET Yas = @yas WHERE Ad = @ad` sorgusu, belirli bir kişinin yaşını günceller.
- `command.ExecuteNonQuery()`, sorguyu çalıştırır ve etkilenen satır sayısını döndürür.

---

##### 2.4. Veri Silme (DELETE)

Veri silme işlemi, veritabanından bir kaydı tamamen kaldırmak için kullanılır. Örneğin, artık gerekli olmayan bir müşteriyi veya ürünü silmek gibi.

###### **Örnek: Veri Silme**

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main()
    {
        // Bağlantı dizesi
        string connectionString = "Server=localhost;Database=OrnekDB;User Id=sa;Password=12345;";

        // SQL DELETE sorgusu
        string query = "DELETE FROM Kisiler WHERE Ad = @ad";

        // SqlConnection ve SqlCommand kullanımı
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                // Bağlantıyı aç
                connection.Open();

                // SqlCommand nesnesi oluştur
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    // Parametre ekle
                    command.Parameters.AddWithValue("@ad", "Ahmet");

                    // Sorguyu çalıştır
                    int etkilenenSatirSayisi = command.ExecuteNonQuery();
                    Console.WriteLine($"{etkilenenSatirSayisi} satır silindi.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Hata: {ex.Message}");
            }
        }
    }
}
```

- `DELETE FROM Kisiler WHERE Ad = @ad` sorgusu, belirli bir kişiyi veritabanından siler.
- `command.ExecuteNonQuery()`, sorguyu çalıştırır ve etkilenen satır sayısını döndürür.

---


#### 3. Parametreli Sorgular

##### 3.1. SQL Injection Riskleri ve Korunma Yöntemleri

**SQL Injection**, veritabanı güvenliği açısından en büyük tehditlerden biridir. SQL Injection, saldırganların kötü niyetli SQL kodlarını uygulamanıza enjekte etmesiyle gerçekleşir. Bu, veritabanınıza yetkisiz erişim sağlama, verileri çalma veya hatta veritabanını tamamen bozma gibi ciddi sonuçlara yol açabilir.

Günlük hayatta bir banka şubesindeki güvenlik sistemini düşünelim. Eğer güvenlik önlemleri yetersizse, bir saldırgan kolayca içeri girebilir ve önemli bilgileri çalabilir. İşte bu, SQL Injection'ın yaptığı iş gibidir.

###### **Örnek: Güvensiz Sorgu (SQL Injection Riski)**

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main()
    {
        // Kullanıcıdan giriş al
        Console.Write("Kullanıcı adı girin: ");
        string kullaniciAdi = Console.ReadLine();

        // Güvensiz sorgu (SQL Injection riski içerir)
        string query = $"SELECT * FROM Kullanicilar WHERE KullaniciAdi = '{kullaniciAdi}'";

        // SqlConnection ve SqlCommand kullanımı
        using (SqlConnection connection = new SqlConnection("Server=localhost;Database=OrnekDB;User Id=sa;Password=12345;"))
        {
            try
            {
                connection.Open();
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            Console.WriteLine($"Kullanıcı Adı: {reader["KullaniciAdi"]}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Hata: {ex.Message}");
            }
        }
    }
}
```

- Yukarıdaki kodda, kullanıcıdan alınan `kullaniciAdi` doğrudan sorguya eklenmiştir.
- Eğer kullanıcı `" OR '1'='1"` gibi bir değer girerse, sorgu şu hale gelir:
  ```sql
  SELECT * FROM Kullanicilar WHERE KullaniciAdi = '' OR '1'='1'
  ```
  Bu, tüm kayıtları getiren bir sorgudur ve veritabanına yetkisiz erişim sağlar.

---

##### 3.2. Parametre Kullanarak Güvenli Sorgular Yazma

SQL Injection saldırılarından korunmanın en etkili yolu, **parametreli sorgular** kullanmaktır. Parametreli sorgular, SQL kodunu ve kullanıcı girdilerini birbirinden ayırır. Böylece, kullanıcı girdilerinin SQL koduna çevrilmesi engellenir.

###### **Örnek: Güvenli Sorgu (Parametreli Sorgu)**

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main()
    {
        // Kullanıcıdan giriş al
        Console.Write("Kullanıcı adı girin: ");
        string kullaniciAdi = Console.ReadLine();

        // Güvenli sorgu (parametreli)
        string query = "SELECT * FROM Kullanicilar WHERE KullaniciAdi = @kullaniciAdi";

        // SqlConnection ve SqlCommand kullanımı
        using (SqlConnection connection = new SqlConnection("Server=localhost;Database=OrnekDB;User Id=sa;Password=12345;"))
        {
            try
            {
                connection.Open();
                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    // Parametre ekle
                    command.Parameters.AddWithValue("@kullaniciAdi", kullaniciAdi);

                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            Console.WriteLine($"Kullanıcı Adı: {reader["KullaniciAdi"]}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Hata: {ex.Message}");
            }
        }
    }
}
```

- `@kullaniciAdi`, sorguda bir parametre olarak tanımlanmıştır.
- `command.Parameters.AddWithValue`, kullanıcı girdisini parametreye güvenli bir şekilde ekler.
- Artık kullanıcı ne kadar kötü niyetli bir giriş yaparsa yapsın (örneğin `" OR '1'='1"`), bu giriş sadece bir değer olarak değerlendirilir ve SQL koduna çevrilmez.

---

##### 3.3. SQL Injection'a Karşı Diğer Korunma Yöntemleri

1. **Doğrulama (Validation):**
   - Kullanıcı girdilerini doğrulayarak, yalnızca beklenen formatlarda giriş yapılmasını sağlayın. Örneğin, bir e-posta adresi için geçerli bir format kontrolü yapabilirsiniz.
   - Sayısal alanlarda yalnızca sayısal değerler kabul edilmelidir.

2. **En Az Yetki İlkesi:**
   - Veritabanına erişim sağlayan kullanıcı hesaplarının, yalnızca gerekli izinlere sahip olması sağlanmalıdır. Örneğin, bir uygulama veritabanından yalnızca okuma yapacaksa, yazma izni verilmemelidir.

3. **Stored Procedures (Saklı Yordamlar):**
   - Karmaşık sorguları saklı yordamlar içinde çalıştırarak, doğrudan SQL sorgularının kullanılmamasını sağlayabilirsiniz. Saklı yordamlar, parametreli sorgular gibi güvenli bir yapı sunar.

4. **ORM (Object-Relational Mapping) Kullanımı:**
   - Entity Framework gibi ORM araçları, SQL sorgularını sizin yerinize otomatik olarak oluşturur ve SQL Injection riskini minimize eder.

5. **Güvenlik Duvarları ve İzleme:**
   - Veritabanı sunucusunda güvenlik duvarları kurarak ve şüpheli aktiviteleri izleyerek SQL Injection saldırılarını tespit edebilirsiniz.

---


#### 4. Transaction Yönetimi

##### 4.1. Transaction Kavramı

**Transaction**, veritabanında birden fazla işlemin bir bütün olarak ele alınmasını sağlayan bir mekanizmadır. Günlük hayatta bir banka transferini düşünelim:
- Bir hesaptan para çekilir (İşlem 1),
- Para başka bir hesaba yatırılır (İşlem 2).

Bu işlemlerin her ikisinin de başarıyla tamamlanması gerekir. Eğer birinci işlem başarılı olur ancak ikinci işlem başarısız olursa, veritabanı tutarsız bir durumda kalabilir. İşte bu tür senaryolarda **transaction** kullanılır.

Transaction'lar şu temel özelliklere sahiptir (**ACID** özellikleri):
- **Atomicity (Atomiklik):** İşlemler ya tamamen gerçekleşir ya da hiç gerçekleşmez.
- **Consistency (Tutarlılık):** Veritabanı, işlemleri tamamladıktan sonra tutarlı bir durumda kalır.
- **Isolation (İzolasyon):** Aynı anda gerçekleştirilen işlemler birbirinden bağımsızdır.
- **Durability (Kalıcılık):** İşlemler başarıyla tamamlandıktan sonra, sonuçlar kalıcı olarak saklanır.

---

##### 4.2. `SqlTransaction` Sınıfı ile İşlem Yönetimi

`SqlTransaction`, SQL Server'da transactionları yönetmek için kullanılan bir sınıftır. Bu sınıf, birden fazla işlemin bir bütün olarak yürütülmesini sağlar. Eğer işlemlerden biri başarısız olursa, tüm işlemler geri alınır (**rollback**).

###### **Örnek: Para Transferi (Transaction Kullanımı)**

```csharp
using System;
using System.Data.SqlClient;

class Program
{
    static void Main()
    {
        // Bağlantı dizesi
        string connectionString = "Server=localhost;Database=OrnekDB;User Id=sa;Password=12345;";

        // SqlConnection ve SqlTransaction kullanımı
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            try
            {
                // Bağlantıyı aç
                connection.Open();

                // Transaction başlat
                SqlTransaction transaction = connection.BeginTransaction();

                try
                {
                    // SqlCommand nesnesi oluştur
                    using (SqlCommand command = connection.CreateCommand())
                    {
                        command.Transaction = transaction;

                        // İşlem 1: Hesaptan para çekme
                        command.CommandText = "UPDATE Hesaplar SET Bakiye = Bakiye - @miktar WHERE HesapNo = @hesapNo";
                        command.Parameters.AddWithValue("@miktar", 500);
                        command.Parameters.AddWithValue("@hesapNo", 1);
                        command.ExecuteNonQuery();

                        // İşlem 2: Başka bir hesaba para yatırma
                        command.CommandText = "UPDATE Hesaplar SET Bakiye = Bakiye + @miktar WHERE HesapNo = @hesapNo";
                        command.Parameters.Clear();
                        command.Parameters.AddWithValue("@miktar", 500);
                        command.Parameters.AddWithValue("@hesapNo", 2);
                        command.ExecuteNonQuery();

                        // Tüm işlemler başarılıysa, transaction'u tamamla (commit)
                        transaction.Commit();
                        Console.WriteLine("Para transferi başarıyla tamamlandı.");
                    }
                }
                catch (Exception ex)
                {
                    // Herhangi bir hata oluşursa, transaction'u geri al (rollback)
                    transaction.Rollback();
                    Console.WriteLine($"Hata oluştu. İşlemler geri alındı. Hata: {ex.Message}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Bağlantı hatası: {ex.Message}");
            }
        }
    }
}
```

- `connection.BeginTransaction()`, bir transaction başlatır.
- `command.Transaction = transaction`, komutun transaction kapsamında çalışacağını belirtir.
- Eğer her iki işlem de başarıyla tamamlanırsa, `transaction.Commit()` ile transaction tamamlanır.
- Eğer bir hata oluşursa, `transaction.Rollback()` ile tüm işlemler geri alınır.

---

##### 4.3. Transaction Kullanmanın Avantajları

1. **Veri Tutarlılığı:** Birden fazla işlemin bir bütün olarak ele alınmasını sağlar. Örneğin, bir hesaptan para çekildikten sonra, para başka bir hesaba yatırılmazsa, işlem geri alınır ve veritabanı tutarlı kalır.

2. **Güvenlik:** Transactionlar, veritabanının yanlış veya eksik işlemlerle bozulmasını önler.

3. **Performans:** Bazı durumlarda, transactionlar performansı artırabilir. Örneğin, birden fazla işlemin tek bir transaction içinde gerçekleştirilmesi, veritabanına yapılan yazma sayısını azaltabilir.

4. **Hata Yönetimi:** Transactionlar, hataları kolayca yakalamanızı ve işlemleri geri almanızı sağlar.

---

##### 4.4. Transaction Kullanırken Dikkat Edilmesi Gerekenler

1. **Transaction Süresi:** Transactionlar, veritabanı kaynaklarını kilitleyebilir. Bu nedenle, transaction süresini mümkün olduğunca kısa tutun.

2. **Deadlock Riski:** İki transactionın birbirini beklemesi durumunda deadlock oluşabilir. Bu tür durumları önlemek için, işlemlerin sırasını dikkatli bir şekilde planlayın.

3. **Rollback Kullanımı:** Eğer bir hata oluşursa, mutlaka `Rollback` çağrısı yapın. Aksi takdirde, veritabanı kaynakları kilitli kalabilir.

4. **Asenkron İşlemler:** Asenkron işlemlerde transaction yönetimi daha karmaşık olabilir. Bu tür senaryolarda, transactionların doğru şekilde yönetildiğinden emin olun.

---

#### Püf Noktalar:

1. Güvenlik açısından bağlantı dizesini doğrudan kod içine yazmaktan kaçının. Bunun yerine, bağlantı dizesini yapılandırma dosyalarında (örneğin `appsettings.json`) saklayın. Bu, hassas bilgilerin korunmasını sağlar.

2. SQL sorgularında her zaman parametre kullanmayı unutmayın. `command.Parameters.AddWithValue` ile parametre ekleyerek SQL enjeksiyon saldırılarını önlemeye katkıda bulunabilirsiniz.

3. `SqlConnection`, `SqlCommand` ve `SqlDataReader` gibi nesneleri kullandıktan sonra bellekten temizlemek için `using` bloklarını kullanın. Bu, kaynakların otomatik olarak kapatılmasını sağlar ve bellek sızıntılarını önler.

4. Büyük veri setleriyle çalışırken, verileri bellekte tutmayan ve yalnızca ileri yönlü okuma yapan `SqlDataReader`'ı tercih edin. Bu, performansınızı artırır.

5. Veritabanı işlemlerinde hatalar sıkça oluşabilir (örneğin bağlantı hatası veya sorgu hatası). Bu nedenle, her zaman `try-catch` bloklarıyla hata yönetimini yapın ve olası sorunları önceden belirleyin.

6. Karmaşık sorgular için saklı yordamlar (stored procedures) kullanmayı düşünebilirsiniz. Bu, hem kodunuzu daha düzenli hale getirir hem de veritabanı işlemlerinin hızlanmasına yardımcı olur.

7. Özellikle büyük veritabanlarıyla çalışırken, işlemleri engellemeden gerçekleştirmek için `ExecuteReaderAsync` veya `ExecuteNonQueryAsync` gibi asenkron metotları kullanın. Bu, uygulamanızın yanıt verme süresini iyileştirir.

8. Birden fazla işlem gerçekleştirdiğinizde, işlemlerin bütünlüğünü sağlamak için `SqlTransaction` kullanın. Örneğin, bir hesaptan para çekme ve başka bir hesaba yatırma işlemlerini tek bir transaction içinde yaparak veri tutarlılığını sağlayın.

9. Kullanıcı girdilerini daima doğrulayın. Örneğin, e-posta adresleri için geçerli bir format kontrolü yapın veya sayısal alanlarda yalnızca sayısal değerler kabul edin. Bu, hem güvenlik hem de veri bütünlüğü açısından önemlidir.

10. Karmaşık CRUD işlemlerini basitleştirmek için saklı yordamlar kullanmayı öneririz. Örneğin, birden fazla tabloya aynı anda veri eklemek veya güncellemek için saklı yordamlar idealdir.

11. Entity Framework gibi ORM araçlarını kullanarak SQL Injection riskini minimize edebilir ve veritabanı işlemlerini daha kolay hale getirebilirsiniz. Ayrıca, bu araçlar kod tekrarını azaltır.

12. Veritabanına erişim sağlayan kullanıcı hesaplarının yalnızca gerekli izinlere sahip olmasını sağlayın. Örneğin, bir uygulama veritabanından yalnızca okuma yapacaksa, yazma izni verilmemelidir.

13. Veritabanı hatalarını kullanıcıya doğrudan göstermek yerine, genel hata mesajları kullanın. Bu, saldırganların sistem hakkında bilgi toplamasını engeller.

14. Veritabanı aktivitelerini düzenli olarak izleyin ve şüpheli giriş denemelerini tespit etmeye çalışın. Bu, potansiyel güvenlik açıklarını hızlıca fark etmenizi sağlar.

15. Hassas verileri (örneğin parolalar) şifreleyerek saklayın. Ayrıca, bağlantı dizesini şifreleyerek depolamak, hassas bilgilerin güvenliğini artırır.

16. Transactionlar, veritabanının atomiklik, tutarlılık, izolasyon ve kalıcılık (ACID) özelliklerini sağlar. Bu özellikleri göz önünde bulundurarak transactionlarınızı tasarlayın.

17. İşlemler başarıyla tamamlanırsa `Commit`, bir hata oluşursa `Rollback` çağrısı yapmayı unutmayın. Bu, veritabanının tutarlı kalmasını sağlar.

18. Transaction süresini mümkün olduğunca kısa tutun. Uzun transactionlar, veritabanı performansını olumsuz etkileyebilir ve kaynakları kilitleyebilir.

19. Deadlock riskini azaltmak için, işlemlerin sırasını dikkatli bir şekilde planlayın. Özellikle eşzamanlı işlemlerde bu durum önemlidir.

20. Asenkron işlemlerde transaction yönetimi daha karmaşık olabilir. Bu tür senaryolarda, transactionların doğru şekilde yönetildiğinden emin olun.

21. Birden fazla işlemin tek bir transaction içinde gerçekleştirilmesi, veritabanına yapılan yazma sayısını azaltabilir ve performansı artırabilir.


---


### 6.2. Entity Framework

#### 1. ORM Kavramı

##### 1.1. ORM (Object-Relational Mapping) Nedir?

**ORM (Object-Relational Mapping)**, nesne yönelimli programlama ile ilişkisel veritabanları arasında köprü görevi gören bir teknolojidir. Günlük hayatta bir çevirmen düşünelim. Çevirmen, iki farklı dil konuşan kişiler arasında iletişim kurmasını sağlar. İşte bu, ORM'in yaptığı iş gibidir.

Örneğin, bir banka şubesinde çalışan bir memur düşünelim. Müşterilerin bilgilerini bir form üzerinden giriyor ve bu bilgiler otomatik olarak veritabanına kaydediliyor. Eğer ORM kullanılmıyorsa, bu bilgileri kaydetmek için SQL sorguları yazmanız gerekebilir:
```sql
INSERT INTO Musteriler (Ad, Soyad, HesapNo) VALUES ('Ali', 'Yılmaz', 12345);
```

Ancak ORM ile bu işlem çok daha basitleşir. Örneğin, Entity Framework kullanarak aşağıdaki gibi bir kod yazabilirsiniz:
```csharp
Musteri musteri = new Musteri { Ad = "Ali", Soyad = "Yılmaz", HesapNo = 12345 };
dbContext.Musteriler.Add(musteri);
dbContext.SaveChanges();
```

Bu kodda, `Musteri` sınıfı veritabanındaki `Musteriler` tablosunu temsil eder. Veritabanıyla etkileşim için SQL sorgusu yazmak yerine, nesneler üzerinden çalışılır.

---

##### 1.2. Entity Framework Avantajları ve Dezavantajları

###### **Avantajlar:**

1. **Kod Üretkenliği Artar:**
   - Entity Framework, SQL sorguları yazma ihtiyacını ortadan kaldırır. Örneğin, bir müşteri listesi çekmek için uzun bir SQL sorgusu yazmak yerine, LINQ ile şu şekilde bir kod yazabilirsiniz:
     ```csharp
     var musteriler = dbContext.Musteriler.Where(m => m.Yas > 18).ToList();
     ```
     Bu, geliştirme süresini kısaltır ve kodun daha okunabilir olmasını sağlar.

2. **SQL Injection Riskini Azaltır:**
   - Entity Framework, parametreli sorgular kullanarak SQL Injection saldırılarını önler. Örneğin, kullanıcıdan alınan bir girişle veri çekmek için şu şekilde güvenli bir kod yazabilirsiniz:
     ```csharp
     string kullaniciAdi = "admin";
     var kullanici = dbContext.Kullanicilar.FirstOrDefault(k => k.KullaniciAdi == kullaniciAdi);
     ```
     Bu kod, SQL Injection riskini ortadan kaldırır.

3. **Platform Bağımsızlık:**
   - Entity Framework Core, hem Windows hem de Linux üzerinde çalışabilir. Ayrıca, farklı veritabanı sistemleriyle uyumlu çalışabilir. Örneğin, bir projeyi SQL Server'dan PostgreSQL'a geçirmek için yalnızca bağlantı dizesini değiştirmeniz yeterlidir.

4. **Kolay Entegrasyon:**
   - Entity Framework, .NET ekosistemiyle sorunsuz entegre edilir. Özellikle ASP.NET Core projelerinde sıkça tercih edilir. Örneğin, bir API projesinde veri tabanından veri çekmek için şu şekilde bir kod yazabilirsiniz:
     ```csharp
     [HttpGet]
     public IActionResult GetMusteriler()
     {
         var musteriler = dbContext.Musteriler.ToList();
         return Ok(musteriler);
     }
     ```

5. **Veri Modeli Yönetimi:**
   - Code-First yaklaşımıyla, veritabanı şemasını C# sınıflarından otomatik olarak oluşturabilirsiniz. Örneğin:
     ```csharp
     public class Musteri
     {
         public int Id { get; set; }
         public string Ad { get; set; }
         public string Soyad { get; set; }
         public int Yas { get; set; }
     }
     ```
     Migration özelliği sayesinde, bu sınıfın değişikliklerini veritabanına yansıtabilirsiniz:
     ```bash
     Add-Migration InitialCreate
     Update-Database
     ```

6. **LINQ Desteği:**
   - Entity Framework, LINQ desteği sunar. Bu, veritabanı sorgularını C# kodunda yazmanızı sağlar. Örneğin:
     ```csharp
     var yetiskinler = dbContext.Musteriler.Where(m => m.Yas > 18).OrderBy(m => m.Ad).ToList();
     ```

7. **Test Edilebilirlik:**
   - Entity Framework, birim testlerini kolaylaştırır. Örneğin, in-memory veritabanı kullanarak test senaryoları oluşturabilirsiniz:
     ```csharp
     var options = new DbContextOptionsBuilder<MyDbContext>()
         .UseInMemoryDatabase(databaseName: "TestDb")
         .Options;

     using (var context = new MyDbContext(options))
     {
         context.Musteriler.Add(new Musteri { Ad = "Ali", Yas = 25 });
         context.SaveChanges();
     }
     ```

---

###### **Dezavantajlar:**

1. **Performans Sorunları:**
   - Karmaşık sorgularda, Entity Framework'in otomatik oluşturduğu SQL sorguları performans açısından optimize olmayabilir. Örneğin:
     ```csharp
     var musteriler = dbContext.Musteriler
         .Include(m => m.Siparisler)
         .Where(m => m.Yas > 18)
         .ToList();
     ```
     Bu kod, birden fazla JOIN işlemi içerir ve büyük veritabanlarında yavaş çalışabilir. Bu durumda, elle yazılmış SQL sorguları daha hızlı olabilir.

2. **Öğrenme Eğrisi:**
   - Entity Framework'in sunduğu geniş özellik seti (örneğin Migration, Lazy Loading), yeni başlayanlar için biraz karmaşık olabilir. Örneğin, Lazy Loading özelliği, ilişkili verilerin otomatik olarak yüklenmesini sağlar, ancak yanlış kullanılırsa performans sorunlarına yol açabilir.

3. **Sınırlı Kontrol:**
   - Veritabanı işlemleri üzerinde tam kontrol sahibi olamazsınız. Örneğin, Entity Framework tarafından oluşturulan SQL sorgularını değiştiremezsiniz. Bu, bazı özel senaryolarda kısıtlama yaratabilir.

4. **Bellek Tüketimi:**
   - Entity Framework, verileri bellekte nesneler olarak tutar. Büyük veri setleriyle çalışırken, bu durum bellek tüketimini artırabilir. Örneğin:
     ```csharp
     var musteriler = dbContext.Musteriler.ToList(); // Tüm müşteriler belleğe yüklenir.
     ```

5. **Veritabanı Bağımlılığı:**
   - Bazı durumlarda, Entity Framework'in belirli bir veritabanı sistemi için optimize edilmiş özellikleri olabilir. Farklı bir veritabanına geçiş yapmak zorlaşabilir. Örneğin, SQL Server'dan Oracle'a geçiş yaparken bazı özelliklerin yeniden düzenlenmesi gerekebilir.

---

##### Örnek: Alışveriş Sepeti

Diyelim ki bir e-ticaret sitesi için bir alışveriş sepeti uygulaması geliştiriyorsunuz. Veritabanında `Sepet` ve `Urun` tablolarınız var. Entity Framework kullanarak bu tabloları C# sınıflarına dönüştürebilirsiniz:

```csharp
public class Sepet
{
    public int Id { get; set; }
    public string KullaniciAdi { get; set; }
    public ICollection<Urun> Urunler { get; set; }
}

public class Urun
{
    public int Id { get; set; }
    public string Ad { get; set; }
    public decimal Fiyat { get; set; }
    public int SepetId { get; set; }
    public Sepet Sepet { get; set; }
}
```

Bu sınıflar sayesinde, veritabanıyla etkileşim için SQL sorguları yazmak yerine, şu şekilde bir kod yazabilirsiniz:
```csharp
// Yeni bir ürün eklemek
var urun = new Urun { Ad = "Laptop", Fiyat = 5000 };
var sepet = dbContext.Sepetler.FirstOrDefault(s => s.KullaniciAdi == "Ali");
sepet.Urunler.Add(urun);
dbContext.SaveChanges();

// Sepetteki ürünleri listelemek
var sepetUrunleri = dbContext.Sepetler
    .Include(s => s.Urunler)
    .FirstOrDefault(s => s.KullaniciAdi == "Ali")?.Urunler;
foreach (var urun in sepetUrunleri)
{
    Console.WriteLine($"{urun.Ad} - {urun.Fiyat}");
}
```

Bu yaklaşım, veritabanı işlemlerini nesne yönelimli bir şekilde yönetmenizi sağlar.

---


#### 2. Code First Yaklaşımı

##### 2.1. Code First Felsefesi

**Code First**, Entity Framework'in sunduğu bir yaklaşımdır ve "kod öncelikli" anlamına gelir. Bu yaklaşımın temel felsefesi, veritabanını kod üzerinden tasarlamak ve yönetmektir. Günlük hayatta bir mimar düşünelim. Mimari planları (sınıflar) önce kağıt üzerinde çizer ve ardından bu plana göre binayı (veritabanını) inşa eder. İşte bu, Code First yaklaşımının mantığı gibidir.

Code First, veritabanı şemasını C# sınıflarından otomatik olarak oluşturur. Bu sayede:
- Veritabanı tasarımını kod düzeyinde yönetebilirsiniz.
- Veritabanı şemasını değiştirmek için SQL sorguları yazmak yerine, sınıf yapılarını güncellersiniz.
- Migration özelliği sayesinde, veritabanı değişikliklerini kolayca izleyebilir ve uygulayabilirsiniz.

Bu yaklaşım, özellikle **Domain-Driven Design (DDD)** veya **Clean Architecture** gibi modern yazılım geliştirme prensipleriyle uyumlu çalışır. Kodunuzun merkezindeki nesneler (sınıflar), iş kurallarını temsil eder ve veritabanı bu nesnelere bağlı olarak şekillenir.

---

##### 2.2. Sınıflardan Veritabanı Oluşturma

Code First yaklaşımında, veritabanı şeması doğrudan C# sınıflarından oluşturulur. Örneğin, bir kütüphane uygulaması için aşağıdaki sınıfları tanımlayabilirsiniz:

```csharp
public class Kitap
{
    public int Id { get; set; }
    public string Ad { get; set; }
    public string Yazar { get; set; }
    public DateTime YayinTarihi { get; set; }
}

public class Uye
{
    public int Id { get; set; }
    public string Ad { get; set; }
    public string Soyad { get; set; }
    public ICollection<Kitap> OkunanKitaplar { get; set; }
}
```

Bu sınıflar, veritabanındaki `Kitap` ve `Uye` tablolarını temsil eder. Ayrıca, `OkunanKitaplar` özelliği, `Uye` ve `Kitap` arasında bir ilişki tanımlar.

Veritabanını oluşturmak için bir `DbContext` sınıfı tanımlamanız gerekir:

```csharp
public class KütüphaneDbContext : DbContext
{
    public DbSet<Kitap> Kitaplar { get; set; }
    public DbSet<Uye> Uyeler { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("Server=localhost;Database=KutuphaneDB;User Id=sa;Password=12345;");
    }
}
```

Bu kod, `KutuphaneDB` adlı bir veritabanı oluşturur ve `Kitap` ile `Uye` tablolarını ekler. Artık veritabanını oluşturmak için aşağıdaki komutları kullanabilirsiniz:

```bash
Add-Migration InitialCreate
Update-Database
```

Bu komutlar, veritabanını sınıflara göre otomatik olarak oluşturur.

---

##### 2.3. Migration İşlemleri

**Migration**, veritabanı şemasını güncellemek için kullanılan bir mekanizmadır. Code First yaklaşımında, veritabanı şemasını değiştirmek için SQL sorguları yazmak yerine, migrationlar kullanılır. Migrationlar, veritabanı değişikliklerini takip eder ve bu değişiklikleri uygular.

###### **Örnek: Migration ile Veritabanı Şemasını Güncelleme**

1. **Yeni Bir Özellik Ekleme:**
   Diyelim ki `Kitap` sınıfına bir `SayfaSayisi` özelliği eklemek istiyorsunuz:
   ```csharp
   public class Kitap
   {
       public int Id { get; set; }
       public string Ad { get; set; }
       public string Yazar { get; set; }
       public DateTime YayinTarihi { get; set; }
       public int SayfaSayisi { get; set; } // Yeni özellik
   }
   ```

2. **Migration Oluşturma:**
   Değişikliği kaydetmek için yeni bir migration oluşturun:
   ```bash
   Add-Migration AddSayfaSayisiToKitap
   ```

   Bu komut, bir migration dosyası oluşturur. Örneğin:
   ```csharp
   public partial class AddSayfaSayisiToKitap : Migration
   {
       protected override void Up(MigrationBuilder migrationBuilder)
       {
           migrationBuilder.AddColumn<int>(
               name: "SayfaSayisi",
               table: "Kitaplar",
               nullable: false,
               defaultValue: 0);
       }

       protected override void Down(MigrationBuilder migrationBuilder)
       {
           migrationBuilder.DropColumn(
               name: "SayfaSayisi",
               table: "Kitaplar");
       }
   }
   ```

3. **Veritabanını Güncelleme:**
   Değişikliği veritabanına uygulamak için şu komutu çalıştırın:
   ```bash
   Update-Database
   ```

Bu işlemler, veritabanını kod değişikliklerine göre günceller.

---

##### 2.4. Veritabanı Güncellemeleri

Code First yaklaşımında, veritabanı güncellemeleri migrationlar aracılığıyla yapılır. Bu, veritabanı şemasını sürekli olarak geliştirmenize olanak tanır. Örneğin:

1. **Tablo Silme:**
   Eğer bir tabloyu silmek isterseniz, ilgili sınıfı koddan kaldırabilirsiniz. Ardından yeni bir migration oluşturup veritabanını güncelleyebilirsiniz.

2. **İlişki Değiştirme:**
   Diyelim ki `Uye` ve `Kitap` arasındaki ilişkiyi değiştirmek istiyorsunuz. Örneğin, bir üyenin birden fazla kitabı olabileceği için `ICollection<Kitap>` özelliğini ekleyebilirsiniz. Migrationlar, bu değişikliği veritabanına yansıtır.

3. **Veri Taşıma:**
   Migrationlar, yalnızca şema değişikliklerini değil, aynı zamanda veri taşıma işlemlerini de destekler. Örneğin, bir sütundaki verileri başka bir sütuna taşımak için `Up` metodu içinde özel bir SQL sorgusu yazabilirsiniz:
   ```csharp
   migrationBuilder.Sql("UPDATE Kitaplar SET YeniSutun = EskiSutun");
   ```

---


##### Örnek: Okul Yönetim Sistemi

Diyelim ki bir okul yönetim sistemi geliştiriyorsunuz. Veritabanında `Ogrenci`, `Ogretmen` ve `Ders` tablolarınız var. Code First yaklaşımıyla bu tabloları şu şekilde tanımlayabilirsiniz:

```csharp
public class Ogrenci
{
    public int Id { get; set; }
    public string Ad { get; set; }
    public string Soyad { get; set; }
    public ICollection<Ders> AldigiDersler { get; set; }
}

public class Ogretmen
{
    public int Id { get; set; }
    public string Ad { get; set; }
    public ICollection<Ders> VerdigiDersler { get; set; }
}

public class Ders
{
    public int Id { get; set; }
    public string Ad { get; set; }
    public int OgretmenId { get; set; }
    public Ogretmen Ogretmen { get; set; }
}
```

Bu sınıflar sayesinde, veritabanı şemasını otomatik olarak oluşturabilir ve migrationlarla güncelleyebilirsiniz. Örneğin, bir öğrenciye yeni bir ders eklemek için şu şekilde bir kod yazabilirsiniz:

```csharp
var ogrenci = dbContext.Ogrenciler.FirstOrDefault(o => o.Ad == "Ali");
var ders = dbContext.Dersler.FirstOrDefault(d => d.Ad == "Matematik");

ogrenci.AldigiDersler.Add(ders);
dbContext.SaveChanges();
```

Bu yaklaşım, veritabanı işlemlerini nesne yönelimli bir şekilde yönetmenizi sağlar.

---


#### 3. Database First Yaklaşımı

##### 3.1. Database First Felsefesi

**Database First**, Entity Framework'in sunduğu bir yaklaşımdır ve "veritabanı öncelikli" anlamına gelir. Bu yaklaşımın temel felsefesi, var olan bir veritabanını temel alarak C# sınıflarını (Entity Modellerini) otomatik olarak oluşturmak ve yönetmektir. Günlük hayatta bir mimar düşünelim. Mimari planlar (sınıflar) doğrudan mevcut bir binadan (veritabanı) çıkarılır ve bu plana göre yeni yapılar inşa edilir. İşte bu, Database First yaklaşımının mantığı gibidir.

Database First, özellikle şu durumlarda tercih edilir:
- Zaten var olan bir veritabanınız var ve bu veritabanını kullanan bir uygulama geliştirmek istiyorsunuz.
- Veritabanı şemasını değiştirmek veya yeniden tasarlamak mümkün değil.
- Takım içinde veritabanı uzmanları ve yazılım geliştiriciler farklı rollerde çalışıyorsa.

Bu yaklaşım, özellikle eski projelerde veya büyük ölçekli sistemlerde sıkça kullanılır.

---

##### 3.2. Varolan Veritabanından Sınıflar Oluşturma

Database First yaklaşımında, var olan bir veritabanından C# sınıflarını otomatik olarak oluşturmak için **EDMX (Entity Data Model)** dosyası kullanılır. EDMX dosyası, veritabanı şemasını ve ilişkilerini modelleyen bir XML tabanlı dosyadır.

###### **Adım Adım: Varolan Veritabanından Sınıflar Oluşturma**

1. **Veritabanını Hazırlama:**
   Diyelim ki bir kütüphane uygulaması için aşağıdaki tablolar zaten oluşturulmuş olsun:
   - `Kitap` tablosu (`Id`, `Ad`, `Yazar`, `SayfaSayisi`)
   - `Uye` tablosu (`Id`, `Ad`, `Soyad`)
   - `OduncAlma` tablosu (`Id`, `KitapId`, `UyeId`, `AlisTarihi`)

2. **EDMX Dosyası Oluşturma:**
   Visual Studio'da bir Entity Framework projesi oluşturduktan sonra, aşağıdaki adımları izleyin:
   - **Solution Explorer**'da sağ tıklayın ve **Add > New Item** seçeneğini seçin.
   - **Data** kategorisinden **ADO.NET Entity Data Model**'i seçin.
   - **Generate from Database** (Veritabanından Oluştur) seçeneğini seçin.
   - Veritabanı bağlantısını yapılandırın ve ilgili tabloları seçin.

3. **Oluşturulan Sınıflar:**
   EDMX dosyası, veritabanındaki tabloları temsil eden C# sınıflarını otomatik olarak oluşturur. Örneğin:
   ```csharp
   public partial class Kitap
   {
       public int Id { get; set; }
       public string Ad { get; set; }
       public string Yazar { get; set; }
       public int SayfaSayisi { get; set; }
       public virtual ICollection<OduncAlma> OduncAlmalar { get; set; }
   }

   public partial class Uye
   {
       public int Id { get; set; }
       public string Ad { get; set; }
       public string Soyad { get; set; }
       public virtual ICollection<OduncAlma> OduncAlmalar { get; set; }
   }

   public partial class OduncAlma
   {
       public int Id { get; set; }
       public int KitapId { get; set; }
       public int UyeId { get; set; }
       public DateTime AlisTarihi { get; set; }
       public virtual Kitap Kitap { get; set; }
       public virtual Uye Uye { get; set; }
   }
   ```

4. **DbContext Kullanımı:**
   EDMX dosyası ayrıca bir `DbContext` sınıfı da oluşturur. Bu sınıf, veritabanıyla etkileşim kurmanızı sağlar:
   ```csharp
   public partial class KütüphaneEntities : DbContext
   {
       public virtual DbSet<Kitap> Kitaplar { get; set; }
       public virtual DbSet<Uye> Uyeler { get; set; }
       public virtual DbSet<OduncAlma> OduncAlmalar { get; set; }
   }
   ```

5. **Veritabanı İşlemleri:**
   Artık oluşturulan sınıfları kullanarak veritabanı işlemlerini gerçekleştirebilirsiniz:
   ```csharp
   using (var context = new KütüphaneEntities())
   {
       var kitaplar = context.Kitaplar.Where(k => k.SayfaSayisi > 300).ToList();
       foreach (var kitap in kitaplar)
       {
           Console.WriteLine($"{kitap.Ad} - {kitap.Yazar}");
       }
   }
   ```

---

##### 3.3. EDMX Dosyaları ve Kullanımı

**EDMX (Entity Data Model)** dosyası, veritabanı şemasını ve ilişkilerini modelleyen bir XML tabanlı dosyadır. Bu dosya, hem görsel bir tasarım yüzeyi sunar hem de veritabanı ile uygulama arasında bir köprü görevi görür.

###### **EDMX Dosyasının Bileşenleri:**

1. **Storage Model (SSDL):**
   Veritabanının fiziksel yapısını tanımlar. Örneğin, tablolar, sütunlar ve ilişkiler gibi bilgiler burada yer alır.

2. **Conceptual Model (CSDL):**
   Uygulamanın nesne yönelimli yapısını tanımlar. Örneğin, C# sınıfları ve özellikleri burada yer alır.

3. **Mapping (MSL):**
   Storage Model ile Conceptual Model arasındaki eşleştirmeyi sağlar. Örneğin, veritabanındaki bir tablonun hangi C# sınıfına karşılık geldiğini belirtir.

###### **EDMX Dosyasının Avantajları:**

- **Görsel Tasarım:** EDMX dosyası, veritabanı şemasını görsel olarak düzenlemenizi sağlar. Tablolar ve ilişkileri grafiksel bir arayüzde görüntüleyebilirsiniz.
- **Kolay Entegrasyon:** Var olan bir veritabanını hızlıca C# sınıflarına dönüştürür.
- **Otomatik Kod Üretimi:** Veritabanı değişikliklerini yansıtmak için EDMX dosyasını güncelleyebilir ve otomatik olarak yeni sınıflar üretebilirsiniz.

###### **EDMX Dosyasının Dezavantajları:**

- **Performans Sorunları:** Büyük veritabanlarında EDMX dosyası oldukça karmaşık hale gelebilir ve performans sorunlarına yol açabilir.
- **Esneklik Eksikliği:** Code First yaklaşımına göre daha az esnektir. Örneğin, özel yapılandırmalar yapmak zor olabilir.
- **XML Karmaşıklığı:** EDMX dosyası, XML tabanlı olduğu için manuel düzenleme yapmak zor olabilir.

---


##### Örnek: Personel Yönetim Sistemi

Diyelim ki bir personel yönetim sistemi geliştiriyorsunuz. Veritabanında `Personel`, `Departman` ve `Pozisyon` tablolarınız var. Database First yaklaşımıyla bu tabloları şu şekilde kullanabilirsiniz:

```csharp
public partial class Personel
{
    public int Id { get; set; }
    public string Ad { get; set; }
    public string Soyad { get; set; }
    public int DepartmanId { get; set; }
    public virtual Departman Departman { get; set; }
}

public partial class Departman
{
    public int Id { get; set; }
    public string Ad { get; set; }
    public virtual ICollection<Personel> Personeller { get; set; }
}
```

Bu sınıflar sayesinde, veritabanı işlemleri için şu şekilde bir kod yazabilirsiniz:

```csharp
using (var context = new PersonelEntities())
{
    var departman = context.Departmanlar.FirstOrDefault(d => d.Ad == "IT");
    var personeller = departman.Personeller.ToList();

    foreach (var personel in personeller)
    {
        Console.WriteLine($"{personel.Ad} {personel.Soyad}");
    }
}
```

Bu yaklaşım, var olan bir veritabanını hızlıca kullanmanıza olanak tanır.

---


#### 4. LINQ to Entities

##### 4.1. LINQ Sorguları ile Veritabanı İşlemleri

**LINQ (Language Integrated Query)**, C# dilinde veri sorgulamak için kullanılan güçlü bir araçtır. LINQ to Entities, Entity Framework üzerinden veritabanı işlemlerini gerçekleştirmenizi sağlar. Günlük hayatta bir alışveriş listesi düşünelim. Listedeki ürünleri filtrelemek, sıralamak veya belirli kriterlere göre seçmek için LINQ kullanabilirsiniz.

###### **Örnek: LINQ ile Veritabanından Veri Çekme**

Diyelim ki bir kütüphane uygulaması geliştirdiniz ve `Kitap` tablosundaki kitapları sorgulamak istiyorsunuz. İşte LINQ sorgusu ile bu işlemi nasıl yapabileceğiniz:

```csharp
using (var context = new KütüphaneDbContext())
{
    // Tüm kitapları çekme
    var tümKitaplar = from kitap in context.Kitaplar
                      select kitap;

    foreach (var kitap in tümKitaplar)
    {
        Console.WriteLine($"{kitap.Ad} - {kitap.Yazar}");
    }

    // Sayfa sayısı 300'den fazla olan kitapları çekme
    var uzunKitaplar = from kitap in context.Kitaplar
                       where kitap.SayfaSayisi > 300
                       orderby kitap.YayinTarihi descending
                       select kitap;

    foreach (var kitap in uzunKitaplar)
    {
        Console.WriteLine($"{kitap.Ad} - {kitap.SayfaSayisi} sayfa");
    }
}
```

Bu kodda:
- `from ... in ... select` yapısı, SQL sorgularına benzer bir şekilde çalışır.
- `where` koşulu, filtreleme yapar.
- `orderby` ifadesi, sonuçları sıralar.

---

##### 4.2. Lambda İfadeleri ile Sorgulama

Lambda ifadeleri, LINQ'in alternatif bir yazım şeklidir ve genellikle daha kısa ve okunabilir bir syntax sunar. Günlük hayatta bir marketteki ürünleri filtrelemek için bir arama motoru düşünelim. Bu arama motoru, lambda ifadeleri ile hızlı ve etkili bir şekilde çalışabilir.

###### **Örnek: Lambda İfadeleri ile Veritabanı İşlemleri**

Aynı kütüphane uygulamasında, lambda ifadeleri ile şu şekilde sorgulama yapabilirsiniz:

```csharp
using (var context = new KütüphaneDbContext())
{
    // Tüm kitapları çekme
    var tümKitaplar = context.Kitaplar.ToList();

    // Sayfa sayısı 300'den fazla olan kitapları çekme
    var uzunKitaplar = context.Kitaplar
        .Where(k => k.SayfaSayisi > 300)
        .OrderByDescending(k => k.YayinTarihi)
        .ToList();

    foreach (var kitap in uzunKitaplar)
    {
        Console.WriteLine($"{kitap.Ad} - {kitap.SayfaSayisi} sayfa");
    }

    // Belirli bir yazarın kitaplarını çekme
    var yazarinKitaplari = context.Kitaplar
        .Where(k => k.Yazar == "Orhan Pamuk")
        .Select(k => new { k.Ad, k.YayinTarihi })
        .ToList();

    foreach (var kitap in yazarinKitaplari)
    {
        Console.WriteLine($"{kitap.Ad} - {kitap.YayinTarihi}");
    }
}
```

Bu kodda:
- `Where`, filtreleme yapar.
- `OrderByDescending`, sonuçları azalan sıraya göre sıralar.
- `Select`, yalnızca belirli alanları seçmenizi sağlar.

---

##### 4.3. Performans Optimizasyonu ve Best Practices

LINQ to Entities, güçlü bir araç olsa da, yanlış kullanıldığında performans sorunlarına yol açabilir. İşte LINQ to Entities'i kullanırken dikkat etmeniz gereken bazı **performans optimizasyonu** ve **best practices** önerileri:

###### **1. Eager Loading vs Lazy Loading**
- **Eager Loading:** İlişkili verileri tek bir sorguda yüklemek için `Include` metodunu kullanın. Örneğin:
  ```csharp
  var kitaplarVeYazarlar = context.Kitaplar
      .Include(k => k.Yazar)
      .ToList();
  ```
  Bu, birden fazla JOIN içeren tek bir SQL sorgusu oluşturur.

- **Lazy Loading:** İlişkili verileri ihtiyaç duyulduğunda yükler. Ancak, bu yaklaşım birden fazla sorguya neden olabilir ve performansı düşürebilir. Örneğin:
  ```csharp
  foreach (var kitap in context.Kitaplar)
  {
      Console.WriteLine(kitap.Yazar.Ad); // Yazar bilgisi burada ayrı bir sorgu ile yüklenir.
  }
  ```

###### **2. AsNoTracking Kullanımı**
- Eğer verileri yalnızca okumak istiyorsanız, `AsNoTracking` metodunu kullanarak performansı artırabilirsiniz. Bu, Entity Framework'in verileri izlemesini engeller:
  ```csharp
  var kitaplar = context.Kitaplar.AsNoTracking().ToList();
  ```

###### **3. Select ile Projeleme**
- Tüm sütunları çekmek yerine, yalnızca ihtiyacınız olan alanları seçmek için `Select` metodunu kullanın. Bu, veritabanından çekilen veri miktarını azaltır:
  ```csharp
  var kitapAdlari = context.Kitaplar
      .Where(k => k.SayfaSayisi > 300)
      .Select(k => k.Ad)
      .ToList();
  ```

###### **4. ToList() ve IQueryable**
- `IQueryable` üzerinde filtreleme yaparken, mümkün olduğunca son adıma kadar `ToList()` çağrısı yapmayın. Çünkü `ToList()` çağrısı, veritabanına sorguyu gönderir ve sonuçları belleğe yükler. Örneğin:
  ```csharp
  // Yanlış kullanım
  var kitaplar = context.Kitaplar.ToList()
      .Where(k => k.SayfaSayisi > 300)
      .ToList();

  // Doğru kullanım
  var kitaplar = context.Kitaplar
      .Where(k => k.SayfaSayisi > 300)
      .ToList();
  ```

###### **5. Indexing ve Veritabanı Optimizasyonu**
- LINQ sorgularının performansını artırmak için, veritabanındaki ilgili sütunlarda indeksler oluşturun. Örneğin, `SayfaSayisi` sütununda bir indeks oluşturmak, filtreleme işlemlerini hızlandırır.

###### **6. Büyük Veri Setleri için Paginate**
- Büyük veri setleriyle çalışırken, tüm veriyi tek seferde çekmek yerine, sayfalama yaparak veriyi parça parça yükleyin. Örneğin:
  ```csharp
  var sayfa1 = context.Kitaplar
      .OrderBy(k => k.Id)
      .Skip(0) // İlk 10 kaydı atla
      .Take(10) // Sonraki 10 kaydı al
      .ToList();
  ```

###### **7. SQL Profiler ile İzleme**
- LINQ sorgularının veritabanında nasıl çalıştığını görmek için SQL Profiler veya Entity Framework Core'un `LogTo` özelliğini kullanabilirsiniz. Örneğin:
  ```csharp
  optionsBuilder.LogTo(Console.WriteLine);
  ```

---


##### Örnek: Ürün Stok Takibi

Diyelim ki bir e-ticaret sitesi için bir ürün stok takip sistemi geliştiriyorsunuz. Veritabanında `Urun` ve `Kategori` tablolarınız var. LINQ to Entities ile şu şekilde sorgulama yapabilirsiniz:

```csharp
using (var context = new EticaretDbContext())
{
    // Stokta olan ürünler
    var stoktakiUrunler = context.Urunler
        .Where(u => u.StokMiktari > 0)
        .OrderBy(u => u.Fiyat)
        .ToList();

    foreach (var urun in stoktakiUrunler)
    {
        Console.WriteLine($"{urun.Ad} - {urun.Fiyat} TL");
    }

    // Belirli bir kategorideki ürünler
    var elektronikUrunler = context.Urunler
        .Include(u => u.Kategori)
        .Where(u => u.Kategori.Ad == "Elektronik")
        .Select(u => new { u.Ad, u.Fiyat })
        .ToList();

    foreach (var urun in elektronikUrunler)
    {
        Console.WriteLine($"{urun.Ad} - {urun.Fiyat} TL");
    }
}
```

Bu yaklaşım, veritabanı işlemlerini hızlı ve etkili bir şekilde yönetmenizi sağlar.

---


#### Püf Noktaları

1. ORM kullanarak veritabanı tablolarını nesnelere dönüştürün. Bu, SQL sorguları yazmadan çalışmanızı sağlar ve kodunuzu daha anlaşılır ve sürdürülebilir hale getirir.

2. Entity Framework, SQL Injection riskini azaltır. LINQ desteği sayesinde veritabanı sorgularını güvenli bir şekilde C# kodunda yazabilirsiniz.

3. Code-First yaklaşımıyla veritabanı şemasını otomatik olarak oluşturun ve Migration özelliğiyle güncelleyin. Bu, veritabanı değişikliklerini kolayca yönetmenizi sağlar.

4. Entity Framework'in performans sorunları yaşatabileceği durumlarda, elle yazılmış SQL sorgularını tercih edin. Özellikle karmaşık sorgularda bu yöntem daha etkilidir.

5. Büyük veri setleriyle çalışırken bellek tüketimini optimize etmek için verileri parça parça yükleyin. `Skip` ve `Take` gibi yöntemlerle sayfalama yapmayı unutmayın.

6. Veritabanını kod üzerinden tasarlamak için Code-First yaklaşımını kullanın. Bu, veritabanı şemasını C# sınıflarından otomatik olarak oluşturur ve yönetir.

7. Sınıfları, veritabanındaki tabloları temsil edecek şekilde tasarlayın. Özellikler sütunları, ilişkiler (örneğin `ICollection`) ise yabancı anahtarları temsil eder.

8. Migrationlar, veritabanı şemasını güncellemek için kullanılır. Her değişiklik için yeni bir migration oluşturun ve veritabanına uygulayın.

9. Migration'ların `Down` metodunu kullanarak yanlış yapılan bir güncelleme durumunda değişiklikleri geri alabilirsiniz.

10. Migrationlar sırasında veri kaybı yaşanmaması için dikkatli olun. Özellikle sütun silme veya veri taşıma işlemlerinde verilerin korunmasını sağlayın.

11. Büyük veritabanlarında migration işlemleri zaman alabilir. Bu nedenle, migrationları test ortamında deneyin ve üretim ortamına uygulamadan önce yedek alın.

12. Migrationlar, veritabanı değişikliklerinin bir tarihçesini oluşturur. Bu, takım çalışması sırasında herkesin veritabanı şemasının güncel olmasını sağlar.

13. Migrationlar, veritabanına başlangıç verileri eklemek için de kullanılabilir. Örneğin, bir `Admin` kullanıcısı veya varsayılan ayarlar eklemek için `OnModelCreating` metodunu kullanabilirsiniz.

14. Var olan bir veritabanını temel alarak C# sınıflarını otomatik olarak oluşturmak için Database First yaklaşımını kullanın. Bu, özellikle eski projelerde veya büyük ölçekli sistemlerde faydalıdır.

15. EDMX dosyası, veritabanı şemasını ve ilişkilerini modelleyen bir XML tabanlı dosyadır. Görsel bir tasarım yüzeyi sunar ve veritabanı ile uygulama arasında bir köprü görevi görür.

16. EDMX dosyası, veritabanındaki tabloları temsil eden C# sınıflarını otomatik olarak oluşturur. Bu, geliştirme süresini kısaltır.

17. Veritabanı şemasında yapılan değişiklikleri EDMX dosyasına yansıtmak için **Update Model from Database** seçeneğini kullanın.

18. Büyük veritabanlarında EDMX dosyası karmaşık hale gelebilir. Performans açısından optimize etmek için gereksiz tabloları veya ilişkileri kaldırın.

19. Database First yaklaşımında migration desteği yoktur. Veritabanı şemasını değiştirmek için SQL sorguları yazın veya EDMX dosyasını güncelleyin.

20. EDMX dosyası, veritabanı şemasını görsel olarak düzenlemenizi sağlar. Tablolar ve ilişkileri grafiksel bir arayüzde görüntüleyebilirsiniz.

21. EDMX dosyası, birim testlerini kolaylaştırır. Örneğin, in-memory veritabanı kullanarak test senaryoları oluşturabilirsiniz.

22. LINQ, SQL sorgularını C# kodunda yazmanızı sağlar. Bu, kodunuzu daha okunabilir ve sürdürülebilir hale getirir.

23. Lambda ifadeleri, LINQ'in alternatif bir yazım şeklidir ve genellikle daha kısa ve okunabilir bir syntax sunar. Lambda ifadelerini tercih ederek kodunuzu daha temiz tutun.

24. İlişkili verileri tek bir sorguda yüklemek için `Include` metodunu kullanın. Bu, birden fazla sorgu yerine tek bir JOIN işlemi gerçekleştirir.

25. Okuma işlemleri için `AsNoTracking` kullanarak performansı artırın. Bu, Entity Framework'in verileri izlemesini engeller.

26. Tüm sütunları çekmek yerine, yalnızca ihtiyacınız olan alanları seçmek için `Select` metodunu kullanın. Bu, veritabanından çekilen veri miktarını azaltır.

27. `ToList()` çağrısını mümkün olduğunca son adıma kadar erteleyin. Erken çağrılması, gereksiz veri yüklemesine ve performans kaybına neden olabilir.

28. Veritabanındaki ilgili sütunlarda indeksler oluşturarak LINQ sorgularının performansını artırın. Özellikle filtreleme yapılan sütunlarda indeksleme yapmayı unutmayın.

29. Büyük veri setleri için sayfalama yaparak veriyi parça parça yükleyin. `Skip` ve `Take` yöntemlerini kullanarak veri yüklemeyi optimize edin.

30. LINQ sorgularının veritabanında nasıl çalıştığını izlemek için SQL Profiler veya Entity Framework Core'un `LogTo` özelliğini kullanın. Bu, performans sorunlarını tespit etmenize yardımcı olur.