## 8. Web Geliştirme (ASP.NET Core)

### 8.1. ASP.NET Nedir?
ASP.NET, Microsoft tarafından geliştirilen bir web uygulaması framework'üdür ve yazılımcılara web siteleri, web uygulamaları ve API'ler geliştirmek için güçlü araçlar sunar. Özellikle Windows tabanlı sistemlerde çalışmak üzere tasarlanmıştır. Örneğin, bir e-ticaret sitesi düşündüğünüzde müşterilerin ürünleri görebildiği, sepete ekleyebildiği ve ödeme yapabildiği bir sistem ASP.NET ile kolayca geliştirilebilir. Bu tür bir sistemde alışveriş sepetindeki ürünlerin fiyatlarını hesaplama veya stok kontrolü yapma gibi işlevler, ASP.NET'in sunduğu araçlar sayesinde hızlı ve güvenli bir şekilde gerçekleştirilir. Ayrıca, ASP.NET'in Windows'a bağımlı olmasının nedeni, .NET Framework üzerine kurulu olmasıdır çünkü .NET Framework yalnızca Windows üzerinde çalışır. Eğer C# dilini biliyorsanız ASP.NET'i öğrenmek oldukça kolaydır çünkü syntax olarak benzerlik gösterir.


#### 2. ASP.NET Core Nedir?
ASP.NET Core ise ASP.NET'in daha modern, hızlı ve esnek bir versiyonudur. Platform bağımsızdır, yani artık sadece Windows değil Linux veya macOS gibi işletim sistemlerinde de çalışabilir. Ayrıca, açık kaynaklı olduğu için geliştiriciler kendi ihtiyaçlarına göre özelleştirebilirler. Örneğin, bir blog sitesi düşünelim; bu sitede kullanıcılar yazılarını yayınlayabilir, yorum yapabilir ve etkileşimde bulunabilir. Eğer bu siteyi ASP.NET Core ile geliştirirseniz, site çok daha hızlı yanıt süreleri sunar ve kullanıcı deneyimini artırır. ASP.NET Core'un modüler yapısı sayesinde projenize yalnızca ihtiyacınız olan bileşenleri ekleyebilirsiniz. Örneğin, veritabanı bağlantısı için Entity Framework Core ekleyebilir veya başka bir veritabanı aracı kullanabilirsiniz. Bu da hem projenizin boyutunu küçültür hem de bakımını kolaylaştırır. Performans açısından bakıldığında ASP.NET Core çoğu durumda Node.js veya PHP'den daha hızlıdır. Örneğin, bir haber sitesinde anlık olarak güncellenen haberler yayınlanıyorsa ve binlerce kullanıcı aynı anda siteye giriyorsa, ASP.NET Core ile geliştirilmiş bir sistem bu trafiği daha verimli bir şekilde yönetebilir.


#### 3. ASP.NET ve ASP.NET Core Arasındaki Farklar ve Benzerlikler
ASP.NET ve ASP.NET Core arasındaki temel farklardan biri platform bağımlılığıdır. ASP.NET sadece Windows üzerinde çalışabilirken ASP.NET Core herhangi bir platformda sorunsuz çalışır. Bu özellikle farklı platformlarda çalışan takımlar için büyük bir avantajdır çünkü bir yazılımcı olarak Linux veya macOS kullanıyorsanız ASP.NET Core ile projelerinizi rahatlıkla geliştirebilirsiniz. Performans açısından ise ASP.NET Core genellikle ASP.NET'e göre daha hızlıdır. Örneğin, bir alışveriş sitesinde binlerce ürün listeleniyor ve her gün yüzlerce sipariş alınıyorsa, bu site ASP.NET Core ile geliştirilmişse kullanıcılar daha hızlı bir şekilde ürünleri görebilir ve alışveriş yapabilir. Modüler yapı da ASP.NET Core'un önemli bir özelliğidir. Projenize yalnızca ihtiyacınız olan bileşenleri ekleyebilirsiniz. Örneğin, bir proje geliştirirken veritabanı bağlantısı için Entity Framework Core ekleyebilirsiniz ama bunu yapmak zorunda değilsiniz. İstediğiniz başka bir veritabanı aracı da kullanabilirsiniz. Bu esneklik, ASP.NET Core'yi modern web geliştirme için oldukça çekici hale getirir. Her iki framework de Microsoft tarafından geliştirilmiştir ve C# dilini kullanır. Ayrıca, her ikisi de web uygulamaları geliştirmek için güçlü araçlar sunar. Kullanıcı kimlik doğrulama, yetkilendirme ve güvenlik gibi konularda size yardımcı olurlar.


#### 4. Diğer Web Geliştirme Dillerinden ve Teknolojilerinden Farkı Nedir?
ASP.NET ve ASP.NET Core, diğer web geliştirme dilleri ve teknolojilerinden birkaç açıdan ayrılır. Öncelikle ASP.NET Core açık kaynaklıdır ve platform bağımsızdır. Bu, onu PHP, Java veya Node.js gibi diğer teknolojilerle karşılaştırırken önemli bir avantaj haline getirir. Örneğin, PHP genellikle Linux tabanlı sunucularda çalışır ancak Windows'da çalışması için ekstra bir çaba gerektirir. ASP.NET Core ise herhangi bir platformda sorunsuz çalışır. Performans açısından bakıldığında ASP.NET Core çoğu durumda Node.js veya PHP'den daha hızlıdır. Bir haber sitesi düşünelim; bu sitede anlık olarak güncellenen haberler yayınlanıyor ve binlerce kullanıcı aynı anda siteye giriyor. ASP.NET Core ile geliştirilmiş bir sistem bu trafiği daha verimli bir şekilde yönetebilir. Ayrıca, ASP.NET Core'un entegrasyon yetenekleri oldukça güçlüdür. Örneğin, bir mobil uygulama geliştirdiğinizi ve bu uygulamanın bir API ile iletişim kurmasını istediğinizde, ASP.NET Core ile bu API'yi hızlıca oluşturabilirsiniz. Bu API, mobil uygulamanın yanı sıra web sitesi veya masaüstü uygulaması gibi farklı platformlar tarafından da kullanılabilir.


#### 5. Temel Kavramlar
ASP.NET Core'u anlamak için bazı temel kavramları bilmek gerekir. Öncelikle MVC (Model-View-Controller) mimarisinden bahsedelim. MVC bir web uygulamasını üç ana bileşene ayırır: Model, View ve Controller. Model veri ve iş mantığını temsil eder. Örneğin, bir e-ticaret sitesinde ürün bilgilerini tutan sınıf bir modeldir. View ise kullanıcı arayüzünü temsil eder. Örneğin, bir ürünün detay sayfasını gösteren HTML kodları bir view'dir. Controller ise model ve view arasında köprü görevi görür. Örneğin, bir kullanıcının bir ürünü sepete eklemesi gibi bir isteği controller işler. Bir başka önemli kavram ise Middleware'dir. Middleware bir HTTP isteğinin işlenmesi sırasında gerçekleşen işlemler zinciridir. Örneğin, bir kullanıcının giriş yapması gerektiğini kontrol eden bir middleware yazabilirsiniz. Eğer kullanıcı giriş yapmamışsa giriş sayfasına yönlendirilir.


#### 6. Dosya Hiyerarşisi
ASP.NET Core projelerinde dosya hiyerarşisi oldukça önemlidir. Proje oluşturulduğunda aşağıdaki gibi bir yapı görürsünüz: `wwwroot` klasörü statik dosyaların (örneğin CSS, JavaScript, resimler) bulunduğu yerdir. `Controllers` klasörü controller sınıflarının bulunduğu yerdir. `Views` klasörü view dosyalarının (HTML sayfaları) bulunduğu yerdir. `Models` klasörü model sınıflarının bulunduğu yerdir. `Program.cs` ise uygulamanın başlangıç noktasıdır. Burada middleware'lar ve servisler yapılandırılır. Örneğin, bir blog sitesi geliştiriyorsanız `Models` klasöründe `Post.cs` adında bir sınıf oluşturabilirsiniz. Bu sınıf blog yazılarının verilerini (başlık, içerik, tarih gibi) tutar. `Views` klasöründe ise bu yazıları görüntülemek için bir HTML sayfası oluşturabilirsiniz.

```
MyWebApp/                  <-- Proje kök dizini
│
├── wwwroot/               <-- Statik dosyalar (CSS, JavaScript, resimler vb.)
│   ├── css/
│   │   └── site.css       <-- Özel CSS dosyaları
│   ├── js/
│   │   └── site.js        <-- Özel JavaScript dosyaları
│   └── images/            <-- Resim dosyaları
│       └── logo.png       <-- Örnek bir resim
│
├── Controllers/           <-- Controller sınıfları
│   └── HomeController.cs  <-- Ana sayfayı kontrol eden controller
│
├── Models/                <-- Model sınıfları
│   └── Product.cs         <-- Örnek bir model sınıfı (ürün bilgileri)
│
├── Views/                 <-- View dosyaları (HTML sayfaları)
│   ├── Home/              <-- HomeController ile ilişkili view'lar
│   │   └── Index.cshtml   <-- Ana sayfa içeriği
│   └── Shared/            <-- Tüm sayfalarda paylaşılan view'lar
│       └── _Layout.cshtml <-- Genel layout (üstbilgi, altbilgi vb.)
│
├── appsettings.json       <-- Uygulama ayarları (veritabanı bağlantıları vb.)
├── Program.cs             <-- Uygulamanın başlangıç noktası
└── MyWebApp.csproj        <-- Proje dosyası (bağımlılıklar ve yapılandırma)
```

#### Açıklamalar:
1. **`wwwroot/` Klasörü:**
   - Bu klasör, statik dosyaların bulunduğu yerdir. Örneğin, CSS dosyaları, JavaScript dosyaları veya resimler bu klasörde saklanır.
   - Tarayıcıdan doğrudan erişilebilen tüm dosyalar burada bulunur.

2. **`Controllers/` Klasörü:**
   - Controller sınıfları bu klasörde bulunur. Controller, gelen HTTP isteklerini işler ve uygun view'ları döndürür.
   - Örneğin, `HomeController.cs`, ana sayfayı (`Index`) kontrol eder.

3. **`Models/` Klasörü:**
   - Model sınıfları bu klasörde bulunur. Model, veri ve iş mantığını temsil eder.
   - Örneğin, `Product.cs` adlı bir model sınıfı ürün bilgilerini (ad, fiyat, stok miktarı) tutabilir.

4. **`Views/` Klasörü:**
   - View dosyaları bu klasörde bulunur. View, kullanıcı arayüzünü temsil eder.
   - Örneğin, `Index.cshtml`, ana sayfanın HTML içeriğini içerir.
   - `Shared/` klasörü ise tüm sayfalarda paylaşılan view'ları içerir. Örneğin, `_Layout.cshtml`, sitenin genel düzenini (üstbilgi, altbilgi, menü) tanımlar.

5. **`appsettings.json`:**
   - Bu dosya, uygulama ayarlarını içerir. Örneğin, veritabanı bağlantı dizeleri veya loglama ayarları burada tanımlanır.

6. **`Program.cs`:**
   - Bu dosya, uygulamanın başlangıç noktasıdır. Middleware'lar ve servisler burada yapılandırılır.

7. **`MyWebApp.csproj`:**
   - Bu dosya, projenin bağımlılıklarını ve yapılandırma bilgilerini içerir. Örneğin, hangi NuGet paketlerinin yüklendiği burada belirtilir.


#### 7. Proje Oluşturma
ASP.NET Core projesi oluşturmak için Visual Studio veya .NET CLI kullanabilirsiniz. Örneğin, .NET CLI ile bir proje oluşturmak için terminalde `dotnet new webapp -o MyWebApp` komutunu çalıştırabilirsiniz. Bu komut `MyWebApp` adında bir ASP.NET Core projesi oluşturur. Proje oluşturulduktan sonra `dotnet run` komutuyla projeyi çalıştırabilirsiniz. Bu komut uygulamayı başlatır ve tarayıcıda `https://localhost:5001` adresinden erişebilirsiniz. İşte bu kadar basit! Eğer projenizi daha sonra yayınlamak isterseniz, bir hosting sağlayıcısına yükleyebilir veya Azure gibi bir bulut platformunda barındırabilirsiniz.


---


### 8.2. ASP.NET Core Giriş

#### 1. MVC (Model-View-Controller) Mimarisi
ASP.NET Core'un temel yapı taşlarından biri olan **MVC (Model-View-Controller)** mimarisi, web uygulamalarını daha düzenli ve yönetilebilir hale getirmek için tasarlanmıştır. Bu mimariyi anlamak, ASP.NET Core ile geliştirme yaparken büyük bir avantaj sağlar çünkü her bileşenin kendine özgü bir görevi vardır ve bu sayede kod karmaşasından kurtulursunuz.


**Model, View, Controller Kavramları:**

- **Model:** Model, uygulamanızın veri ve iş mantığını temsil eder. Örneğin, bir e-ticaret sitesinde ürün bilgilerini (ad, fiyat, stok miktarı) tutan bir sınıf bir modeldir. Model, veritabanıyla etkileşim kurar ve iş kurallarını uygular. Örneğin, bir `Product` modeli şöyle olabilir:

  ```csharp
  public class Product
  {
      public int Id { get; set; }          // Ürün ID'si
      public string Name { get; set; }     // Ürün adı
      public decimal Price { get; set; }   // Ürün fiyatı
      public int Stock { get; set; }       // Stok miktarı
  }
  ```

  Bu model, veritabanından ürün bilgilerini çekmek veya güncellemek için kullanılır. Model, veri tabanı işlemlerini gerçekleştiren Entity Framework Core gibi araçlarla entegre edilir.

- **View:** View, kullanıcıya gösterilen arayüzü temsil eder. Yani, HTML, CSS ve JavaScript gibi teknolojilerle oluşturulan içerikler burada yer alır. Örneğin, bir ürün detay sayfası düşünelim. Bu sayfada ürünün adı, fiyatı ve resmi gösterilir. İşte bu içeriği oluşturan dosya bir view'dir. Bir view örneği şu şekilde olabilir:

  ```html
  @model MyWebApp.Models.Product  <!-- Model'i belirtiyoruz -->

  <h1>@Model.Name</h1>            <!-- Ürün adını gösteriyoruz -->
  <p>Fiyat: @Model.Price TL</p>   <!-- Ürün fiyatını gösteriyoruz -->
  <p>Stok: @Model.Stock adet</p>  <!-- Stok miktarını gösteriyoruz -->
  ```

  Burada, `@model` ifadesi ile hangi modelin kullanılacağını belirtiyoruz. Ardından, modeldeki verileri (`Name`, `Price`, `Stock`) HTML içinde gösteriyoruz.

- **Controller:** Controller, model ve view arasında köprü görevi görür. Kullanıcıdan gelen istekleri işler, modelden veri çeker ve uygun view'ı döndürür. Örneğin, bir kullanıcının bir ürünü sepete eklemesi gibi bir isteği controller işler. Bir controller örneği şu şekilde olabilir:

  ```csharp
  public class ProductController : Controller
  {
      // Ana sayfayı görüntüleyen action metodu
      public IActionResult Index()
      {
          var product = new Product
          {
              Id = 1,
              Name = "Laptop",
              Price = 9999.99m,
              Stock = 10
          };

          return View(product);  // View'a modeli gönderiyoruz
      }

      // Ürün detay sayfasını görüntüleyen action metodu
      public IActionResult Details(int id)
      {
          // Veritabanından ürün bilgilerini çekiyoruz
          var product = GetProductById(id);
          return View(product);
      }

      private Product GetProductById(int id)
      {
          // Basit bir örnek için sabit bir ürün döndürüyoruz
          return new Product
          {
              Id = id,
              Name = "Tablet",
              Price = 4999.99m,
              Stock = 5
          };
      }
  }
  ```

  Burada, `Index` ve `Details` gibi metotlar **action metodlarıdır**. Bu metotlar, kullanıcının yaptığı isteğe göre çalışır ve uygun view'ı döndürür.


**Routing ve Action Metodları:**
Routing, bir URL'nin hangi controller ve action metoduna yönlendirileceğini belirler. Örneğin, `/Product/Details/1` gibi bir URL, `ProductController` sınıfındaki `Details` action metodunu çağırır ve `id` parametresi olarak `1` değerini geçirir. Routing, `Program.cs` veya `Startup.cs` dosyasında yapılandırılır. Örnek bir routing tanımı şu şekilde olabilir:

```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

Bu yapılandırma, URL'lerin nasıl çözümleneceğini belirler. Örneğin:
- `/Home/Index` → `HomeController`'ın `Index` action'ını çağırır.
- `/Product/Details/1` → `ProductController`'ın `Details` action'ını çağırır ve `id` parametresi olarak `1` geçirir.


#### 2. Razor Pages
Razor Pages, ASP.NET Core'un MVC mimarisine alternatif olarak sunulan bir yapıdır. Özellikle küçük veya orta ölçekli projeler için idealdir çünkü kullanımı daha basittir. Razor Pages, her bir sayfa için ayrı bir model ve view içerir.


**Razor Syntax ve Sayfa Yapısı:**

Razor syntax, C# kodlarını HTML ile birleştirmenize olanak tanır. Örneğin, bir Razor Pages sayfası şu şekilde görünebilir:

```html
@page  <!-- Bu bir Razor Pages sayfasıdır -->
@model MyWebApp.Pages.Products.IndexModel  <!-- Sayfanın modelini belirtiyoruz -->

<h1>Ürün Listesi</h1>

<ul>
    @foreach (var product in Model.Products)
    {
        <li>@product.Name - @product.Price TL</li>
    }
</ul>
```

Burada, `@page` direktifi bu dosyanın bir Razor Pages sayfası olduğunu belirtir. `@model` ifadesi ise sayfanın modelini tanımlar. Modeldeki verileri (`Products` listesi) HTML içinde kullanıyoruz.


**PageModel ve Handler Metotları:**

Her Razor Pages sayfası, bir PageModel sınıfı içerir. Bu sınıf, sayfanın iş mantığını ve handler metotlarını tanımlar. Örneğin:

```csharp
public class IndexModel : PageModel
{
    public List<Product> Products { get; set; }  // Ürün listesi

    // Sayfa yüklendiğinde çalışacak handler metodu
    public void OnGet()
    {
        // Veritabanından ürünleri çekiyoruz
        Products = GetProducts();
    }

    private List<Product> GetProducts()
    {
        // Basit bir örnek için sabit bir liste döndürüyoruz
        return new List<Product>
        {
            new Product { Id = 1, Name = "Laptop", Price = 9999.99m },
            new Product { Id = 2, Name = "Tablet", Price = 4999.99m }
        };
    }
}
```

Burada, `OnGet` metodu sayfa ilk yüklendiğinde çalışır ve ürün listesini çeker. Eğer bir form gönderimi gibi bir işlem yapmak isterseniz, `OnPost` gibi başka handler metotları da tanımlayabilirsiniz.


---


### 8.3. Web API

#### 1. Web API Nedir?
Web API, **Application Programming Interface** (Uygulama Programlama Arayüzü) anlamına gelir ve bir yazılımın başka bir yazılımla iletişim kurmasını sağlayan bir yapıdır. ASP.NET Core ile geliştirilen Web API'ler, özellikle veri paylaşımı ve entegrasyon işlemlerinde kullanılır. Örneğin, bir mobil uygulamanın bir sunucudan veri alması veya bir web sitesinin farklı bir servisle iletişim kurması gibi senaryolarda Web API'lerden yararlanılır.


**Ne İçin ve Nasıl Kullanılır?**

Web API'ler, genellikle aşağıdaki amaçlar için kullanılır:

1. **Veri Paylaşımı:**  
   Bir Web API, verileri farklı platformlara (örneğin, mobil uygulamalar, web siteleri, masaüstü uygulamaları) sunmak için kullanılır. Örneğin, bir hava durumu uygulaması düşünelim. Bu uygulama, bir Web API üzerinden hava durumu bilgilerini alır ve kullanıcıya gösterir. İşte bu tür bir sistemde Web API, veri sağlayıcısı olarak görev yapar.

2. **Farklı Sistemler Arasında Entegrasyon:**  
   Örneğin, bir e-ticaret sitesi düşünelim. Bu site, bir kargo şirketiyle entegre olmak istiyor. Kargo şirketinin Web API'sini kullanarak, siparişlerin kargo durumunu takip edebilirsiniz. Böylece iki farklı sistem arasında sorunsuz bir iletişim sağlanır.

3. **Mikro Servis Mimarisi:**  
   Modern yazılım projelerinde, tek bir büyük uygulama yerine küçük, bağımsız servisler (mikro servisler) kullanılır. Bu servisler birbirleriyle iletişim kurmak için Web API'lerini kullanır. Örneğin, bir banka uygulamasında müşteri bilgilerini yöneten bir servis, hesap bilgilerini yöneten başka bir servisle iletişim kurabilir.

---

**Nasıl Çalışır?**

Web API'ler, HTTP protokolü üzerinden çalışır. Yani, bir istemci (örneğin, bir mobil uygulama) bir HTTP isteği gönderir ve sunucu (API), bu isteğe cevap olarak veri döndürür. Bu veri genellikle JSON veya XML formatında olur. Örneğin:

- İstemci, `/api/products` adresine bir GET isteği gönderir.
- API, bu isteği alır, veritabanından ürün listesini çeker ve JSON formatında bir yanıt döndürür:
  ```json
  [
      { "id": 1, "name": "Laptop", "price": 9999.99 },
      { "id": 2, "name": "Tablet", "price": 4999.99 }
  ]
  ```

Bu süreçte, API'nin temel işlevi, gelen istekleri işlemek ve uygun yanıtı döndürmektedir.


**ASP.NET Core ile Web API Geliştirme:**

ASP.NET Core, Web API geliştirmek için güçlü araçlar sunar. Örneğin, bir ürün listesi döndüren basit bir API şu şekilde oluşturulabilir:

```csharp
[ApiController]  // Bu sınıfın bir API controller olduğunu belirtir
[Route("api/[controller]")]  // URL yolunu tanımlar (örneğin, /api/products)
public class ProductsController : ControllerBase
{
    private static List<Product> products = new List<Product>
    {
        new Product { Id = 1, Name = "Laptop", Price = 9999.99m },
        new Product { Id = 2, Name = "Tablet", Price = 4999.99m }
    };

    // GET: api/products
    [HttpGet]  // Bu metot, GET isteklerini işler
    public IActionResult Get()
    {
        return Ok(products);  // Ürün listesini JSON formatında döndürür
    }

    // GET: api/products/1
    [HttpGet("{id}")]  // URL'deki id parametresini alır
    public IActionResult GetById(int id)
    {
        var product = products.FirstOrDefault(p => p.Id == id);
        if (product == null)
        {
            return NotFound();  // Ürün bulunamazsa 404 hatası döner
        }
        return Ok(product);  // Ürünü JSON formatında döndürür
    }

    // POST: api/products
    [HttpPost]  // Bu metot, POST isteklerini işler
    public IActionResult Post([FromBody] Product newProduct)
    {
        products.Add(newProduct);  // Yeni ürünü listeye ekler
        return CreatedAtAction(nameof(GetById), new { id = newProduct.Id }, newProduct);  // 201 Created yanıtı döner
    }
}

// Ürün modeli
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}
```

Bu örnekte:
- `Get` metodu, tüm ürünleri döndürür.
- `GetById` metodu, belirli bir ürünü döndürür.
- `Post` metodu, yeni bir ürün ekler.

---


#### 2. RESTful API Kavramı

**RESTful API Nedir?**

REST (**REpresentational State Transfer**) bir mimari tarzdır ve modern web uygulamalarında yaygın olarak kullanılan bir API tasarım yaklaşımıdır. **RESTful API**, bu mimariyi takip eden API'ler için kullanılan bir terimdir. REST, HTTP protokolünün temel özelliklerini kullanarak veri alışverişi yapmayı sağlar. Bu nedenle, RESTful API'ler genellikle basit, ölçeklenebilir ve platform bağımsızdır.

RESTful API'nin temel prensipleri şunlardır:
1. **Durumsuz (Stateless):** Her istek, sunucuda herhangi bir durum (state) tutulmadan işlenir. Örneğin, bir kullanıcı giriş yaptıktan sonra bile, her yeni istekte kimlik bilgileri tekrar gönderilir.
2. **Kaynak Odaklı (Resource-Based):** API, verileri "kaynaklar" olarak ele alır. Örneğin, bir e-ticaret sitesinde ürünler, müşteriler veya siparişler birer kaynaktır.
3. **HTTP Metodlarını Kullanma:** HTTP metotları (GET, POST, PUT, DELETE), kaynaklar üzerindeki işlemleri tanımlar.
4. **Yanıtları Standart Formatlarda Döndürme:** API yanıtları genellikle JSON veya XML formatında döner.

Örnek bir senaryo düşünelim: Bir kütüphane uygulaması geliştirdiğinizi hayal edin. Bu uygulama, kitapların listesini göstermek, yeni kitap eklemek, mevcut bir kitabı güncellemek veya silmek gibi işlemleri gerçekleştirebilir. Bu işlemlerin tamamı, RESTful API ile kolayca yönetilebilir.


**HTTP Metotları (GET, POST, PUT, DELETE):**

RESTful API'lerde, HTTP metotları kaynaklar üzerinde yapılacak işlemleri belirtir. İşte bu metotların ne işe yaradığına dair detaylı açıklama:

1. **GET:**  
   - **Kullanım Amacı:** Kaynakları (verileri) almak için kullanılır.
   - **Örnek Senaryo:** Bir e-ticaret sitesinde ürün listesini görüntülemek isteyen bir kullanıcı, `/api/products` adresine bir GET isteği gönderir.
   - **Örnek Kod:**
     ```csharp
     [HttpGet]
     public IActionResult Get()
     {
         return Ok(products);  // Ürün listesini JSON formatında döndürür
     }
     ```

2. **POST:**  
   - **Kullanım Amacı:** Yeni bir kaynak oluşturmak için kullanılır.
   - **Örnek Senaryo:** Bir yönetici, yeni bir ürün eklemek için `/api/products` adresine bir POST isteği gönderir ve ürün bilgilerini JSON formatında iletir.
   - **Örnek Kod:**
     ```csharp
     [HttpPost]
     public IActionResult Post([FromBody] Product newProduct)
     {
         products.Add(newProduct);  // Yeni ürünü listeye ekler
         return CreatedAtAction(nameof(GetById), new { id = newProduct.Id }, newProduct);
     }
     ```

3. **PUT:**  
   - **Kullanım Amacı:** Mevcut bir kaynağı güncellemek için kullanılır.
   - **Örnek Senaryo:** Bir yönetici, bir ürünün fiyatını güncellemek için `/api/products/1` adresine bir PUT isteği gönderir ve güncellenmiş ürün bilgilerini JSON formatında iletir.
   - **Örnek Kod:**
     ```csharp
     [HttpPut("{id}")]
     public IActionResult Put(int id, [FromBody] Product updatedProduct)
     {
         var product = products.FirstOrDefault(p => p.Id == id);
         if (product == null)
         {
             return NotFound();  // Ürün bulunamazsa 404 hatası döner
         }

         product.Name = updatedProduct.Name;
         product.Price = updatedProduct.Price;

         return NoContent();  // Güncellenen ürünü döndürmez (204 No Content)
     }
     ```

4. **DELETE:**  
   - **Kullanım Amacı:** Bir kaynağı silmek için kullanılır.
   - **Örnek Senaryo:** Bir yönetici, bir ürünü silmek için `/api/products/1` adresine bir DELETE isteği gönderir.
   - **Örnek Kod:**
     ```csharp
     [HttpDelete("{id}")]
     public IActionResult Delete(int id)
     {
         var product = products.FirstOrDefault(p => p.Id == id);
         if (product == null)
         {
             return NotFound();  // Ürün bulunamazsa 404 hatası döner
         }

         products.Remove(product);
         return NoContent();  // Silinen ürünü döndürmez (204 No Content)
     }
     ```

---


#### 3. Controller ve Action Metodları

**Controller Oluşturma ve Routing:**

ASP.NET Core'da **Controller**, bir API'nin ana bileşenidir. Controller, gelen HTTP isteklerini işler ve uygun yanıtı döndürür. Bir controller sınıfı, genellikle `ControllerBase` sınıfından türetilir ve `[ApiController]` attribute'ü ile işaretlenir. Bu attribute, sınıfın bir API controller olduğunu belirtir.

**Controller Oluşturma:**
Bir controller oluşturmak için aşağıdaki adımları izleyebilirsiniz:
1. Sınıfı `ControllerBase` sınıfından türetin.
2. `[ApiController]` attribute'ünü ekleyin.
3. `[Route]` attribute'ü ile routing yapısını tanımlayın.

Örneğin, bir ürün yönetimi API'si için aşağıdaki gibi bir controller oluşturabiliriz:

```csharp
[ApiController]  // Bu sınıfın bir API controller olduğunu belirtir
[Route("api/[controller]")]  // URL yolunu tanımlar (örneğin, /api/products)
public class ProductsController : ControllerBase
{
    private static List<Product> products = new List<Product>
    {
        new Product { Id = 1, Name = "Laptop", Price = 9999.99m },
        new Product { Id = 2, Name = "Tablet", Price = 4999.99m }
    };

    // Ürün modeli
    public class Product
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public decimal Price { get; set; }
    }
}
```

Bu örnekte:
- `[ApiController]`, bu sınıfın bir API controller olduğunu belirtir.
- `[Route("api/[controller]")]`, bu controller için temel URL yolunu tanımlar. `[controller]` ifadesi, sınıfın adının sonundaki "Controller" kelimesi olmadan alınmasını sağlar. Örneğin, `ProductsController` için `/api/products` yolunu oluşturur.


**Action Metodları ve HTTP Metotları ile Eşleme:**

Controller içindeki metotlara **action metodları** denir. Her action metodu, belirli bir HTTP isteğini işler. Örneğin, bir GET isteği için bir action metodu, bir POST isteği için başka bir action metodu yazabilirsiniz. HTTP metotlarını action metotlarına eşlemek için `[HttpGet]`, `[HttpPost]`, `[HttpPut]`, `[HttpDelete]` gibi attribute'ler kullanılır.

**Action Metotları:**
Her action metodu, bir HTTP isteğine yanıt verir. İşte bir örnek:

```csharp
// GET: api/products
[HttpGet]
public IActionResult Get()
{
    return Ok(products);  // Tüm ürünleri JSON formatında döndürür
}

// GET: api/products/1
[HttpGet("{id}")]  // URL'deki id parametresini alır
public IActionResult GetById(int id)
{
    var product = products.FirstOrDefault(p => p.Id == id);
    if (product == null)
    {
        return NotFound();  // Ürün bulunamazsa 404 hatası döner
    }
    return Ok(product);  // Ürünü JSON formatında döndürür
}

// POST: api/products
[HttpPost]
public IActionResult Post([FromBody] Product newProduct)
{
    products.Add(newProduct);  // Yeni ürünü listeye ekler
    return CreatedAtAction(nameof(GetById), new { id = newProduct.Id }, newProduct);  // 201 Created yanıtı döner
}

// PUT: api/products/1
[HttpPut("{id}")]
public IActionResult Put(int id, [FromBody] Product updatedProduct)
{
    var product = products.FirstOrDefault(p => p.Id == id);
    if (product == null)
    {
        return NotFound();  // Ürün bulunamazsa 404 hatası döner
    }

    product.Name = updatedProduct.Name;
    product.Price = updatedProduct.Price;

    return NoContent();  // Güncellenen ürünü döndürmez (204 No Content)
}

// DELETE: api/products/1
[HttpDelete("{id}")]
public IActionResult Delete(int id)
{
    var product = products.FirstOrDefault(p => p.Id == id);
    if (product == null)
    {
        return NotFound();  // Ürün bulunamazsa 404 hatası döner
    }

    products.Remove(product);
    return NoContent();  // Silinen ürünü döndürmez (204 No Content)
}
```

Bu örnekte:
- `Get`: Tüm ürünleri döndürür.
- `GetById`: Belirli bir ürünü döndürür.
- `Post`: Yeni bir ürün ekler.
- `Put`: Mevcut bir ürünü günceller.
- `Delete`: Bir ürünü siler.


**Routing Nedir?**

Routing, bir URL'nin hangi controller ve action metoduna yönlendirileceğini belirler. ASP.NET Core'da routing, `[Route]` attribute'ü ile tanımlanır. Örneğin:
- `/api/products` → `ProductsController`'ın `Get` action'ını çağırır.
- `/api/products/1` → `ProductsController`'ın `GetById` action'ını çağırır ve `id` parametresi olarak `1` geçirir.

Routing yapılandırması, `Program.cs` dosyasında da tanımlanabilir. Örnek bir yapılandırma şu şekilde olabilir:

```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "api/{controller}/{action}/{id?}");
```

Bu yapılandırma, URL'lerin nasıl çözümleneceğini belirler. Örneğin:
- `/api/products/get` → `ProductsController`'ın `Get` action'ını çağırır.
- `/api/products/getbyid/1` → `ProductsController`'ın `GetById` action'ını çağırır ve `id` parametresi olarak `1` geçirir.

---


#### 4. Veri Doğrulama ve Hata Yönetimi

**Model Validation ve Hata Mesajları:**

Web API'lerde, gelen verilerin doğruluğunu kontrol etmek (örneğin, bir alanın boş olup olmadığını veya belirli bir formatta olup olmadığını) büyük önem taşır. Bu işlem, **model validation** adı verilen bir süreçle gerçekleştirilir. ASP.NET Core, bu doğrulamaları kolaylaştırmak için hazır attribute'ler sunar.

**Model Validation Nasıl Çalışır?**
1. Gelen veriler, model sınıfına bağlanır.
2. Model sınıfındaki attribute'ler, verilerin doğruluğunu kontrol eder.
3. Eğer doğrulama başarısız olursa, API hata mesajları döndürür.

Örneğin, bir ürün eklemek için aşağıdaki modeli düşünelim:

```csharp
public class Product
{
    public int Id { get; set; }

    [Required(ErrorMessage = "Ürün adı zorunludur.")]
    [StringLength(100, ErrorMessage = "Ürün adı en fazla 100 karakter olabilir.")]
    public string Name { get; set; }

    [Range(0, 100000, ErrorMessage = "Fiyat 0 ile 100.000 arasında olmalıdır.")]
    public decimal Price { get; set; }
}
```

Bu modelde:
- `[Required]`: Alanın boş olmaması gerektiğini belirtir.
- `[StringLength]`: Metin uzunluğunu sınırlar.
- `[Range]`: Sayısal değerler için minimum ve maksimum sınırları belirler.

Bir POST isteğiyle yeni bir ürün eklemek istediğimizde, API bu doğrulamaları otomatik olarak gerçekleştirir. Eğer doğrulama başarısız olursa, API hata mesajları döndürür:

```json
{
    "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
    "title": "One or more validation errors occurred.",
    "status": 400,
    "errors": {
        "Name": ["Ürün adı zorunludur.", "Ürün adı en fazla 100 karakter olabilir."],
        "Price": ["Fiyat 0 ile 100.000 arasında olmalıdır."]
    }
}
```

**Controller'da Doğrulama Kontrolü:**
Controller'da, doğrulama sonucunu kontrol etmek için `ModelState.IsValid` özelliği kullanılır. Örnek:

```csharp
[HttpPost]
public IActionResult Post([FromBody] Product newProduct)
{
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);  // Doğrulama başarısızsa hata mesajlarını döndür
    }

    products.Add(newProduct);
    return CreatedAtAction(nameof(GetById), new { id = newProduct.Id }, newProduct);
}
```

Burada, `ModelState.IsValid` false ise, `BadRequest` ile hata mesajları döndürülür.


**Global Hata Yönetimi ve Middleware:**

API'lerde beklenmedik hatalar (örneğin, null referans hatası veya veritabanı bağlantı sorunları) oluşabilir. Bu tür hataları ele almak için **global hata yönetimi** ve **middleware** kullanılır.

**Global Hata Yönetimi:**
ASP.NET Core, tüm hataları tek bir yerden yönetmek için özel bir middleware oluşturmanıza olanak tanır. Örneğin, aşağıdaki gibi bir global hata yönetimi middleware'i yazabilirsiniz:

```csharp
public class GlobalExceptionHandlerMiddleware
{
    private readonly RequestDelegate _next;

    public GlobalExceptionHandlerMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);  // İsteği işleme devam et
        }
        catch (Exception ex)
        {
            // Hata olduğunda özel bir yanıt döndür
            context.Response.ContentType = "application/json";
            context.Response.StatusCode = StatusCodes.Status500InternalServerError;

            await context.Response.WriteAsync(new
            {
                StatusCode = context.Response.StatusCode,
                Message = "Bir hata oluştu. Lütfen daha sonra tekrar deneyin.",
                DetailedMessage = ex.Message  // Geliştirme ortamında detaylı hata mesajı gösterebilirsiniz
            }.ToString());
        }
    }
}
```

Bu middleware'i `Program.cs` dosyasında kaydedebilirsiniz:

```csharp
app.UseMiddleware<GlobalExceptionHandlerMiddleware>();
```

Artık API'nizde herhangi bir hata oluştuğunda, bu middleware çalışır ve kullanıcıya standart bir hata yanıtı döner.

---


### 8.4. Entity Framework Core ile Veritabanı İşlemleri

#### 1. Code First Yaklaşımı

**Code First** (Kod Öncesi), veritabanını kod tabanlı olarak oluşturmayı ve yönetmeyi hedefleyen bir yaklaşımdır. Bu yöntemde, önce C# sınıflarını (entity'leri) yazarız ve bu sınıflara dayalı olarak EF Core otomatik olarak veritabanını oluşturur veya günceller. Bu yaklaşım, özellikle geliştirme sürecinde hızlıca değişiklik yapmanızı sağlar.

---

##### 1. Entity Sınıfları ve DbContext

**Entity Sınıfları Nedir?**
Entity sınıfları, veritabanındaki tabloları temsil eder. Her bir entity sınıfı, bir tabloya karşılık gelir ve sınıfın özellikleri ise tablodaki sütunları temsil eder. Örneğin, bir e-ticaret sistemi için aşağıdaki gibi iki temel entity sınıfı tanımlayabiliriz:

```csharp
public class Product
{
    // Ürün ID'si (primary key)
    public int Id { get; set; }

    // Ürün adı
    [Required]  // Bu alan boş olamaz
    [StringLength(100)]  // En fazla 100 karakter olabilir
    public string Name { get; set; }

    // Ürün fiyatı
    [Range(0, 100000)]  // Fiyat 0 ile 100.000 arasında olmalıdır
    public decimal Price { get; set; }

    // Kategori ID'si (foreign key)
    public int CategoryId { get; set; }

    // İlişkili kategori (navigation property)
    public Category Category { get; set; }
}

public class Category
{
    // Kategori ID'si (primary key)
    public int Id { get; set; }

    // Kategori adı
    [Required]
    [StringLength(50)]
    public string Name { get; set; }

    // İlişkili ürünler (navigation property)
    public ICollection<Product> Products { get; set; }
}
```

Bu örnekte:
- `Product` sınıfı, `Products` tablosunu temsil eder.
- `Category` sınıfı, `Categories` tablosunu temsil eder.
- `CategoryId` ve `Category`, `Products` tablosu ile `Categories` tablosu arasındaki ilişkiyi tanımlar.

**Navigation Property Nedir?**
Navigation property, ilişkili tablolar arasında gezinmeyi sağlar. Örneğin, bir ürünün hangi kategoriye ait olduğunu görmek için `Product.Category` özelliğini kullanabilirsiniz. Benzer şekilde, bir kategorinin tüm ürünleri için `Category.Products` özelliğini kullanabilirsiniz.

---

**DbContext Nedir ve Nasıl Çalışır?**
`DbContext`, EF Core'un kalbinde yer alan bir sınıftır ve veritabanı ile etkileşim kurmak için kullanılır. `DbContext`, aşağıdaki görevleri üstlenir:
1. **Entity Sınıflarını Yönetir:** `DbSet<T>` özellikleri aracılığıyla entity sınıflarını (tabloları) tanımlar.
2. **Veritabanı İşlemlerini Gerçekleştirir:** Ekleme, silme, güncelleme ve sorgulama gibi işlemleri gerçekleştirir.
3. **Change Tracking Yapar:** Hangi verilerin değiştirildiğini takip eder ve gerekli SQL komutlarını otomatik olarak oluşturur.

Örnek bir `DbContext` sınıfı şu şekilde tanımlanabilir:

```csharp
using Microsoft.EntityFrameworkCore;

public class AppDbContext : DbContext
{
    // DbSet özellikleri, veritabanındaki tabloları temsil eder
    public DbSet<Product> Products { get; set; }
    public DbSet<Category> Categories { get; set; }

    // Veritabanı bağlantı ayarlarını yapılandırır
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        // LocalDB kullanarak bir SQL Server veritabanına bağlanıyoruz
        optionsBuilder.UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=MyWebAppDb;Trusted_Connection=True;");
    }

    // Model yapılandırmasını özelleştirmek için kullanılır
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Örneğin, Product tablosundaki Name sütununu unique yapabiliriz
        modelBuilder.Entity<Product>()
            .HasIndex(p => p.Name)
            .IsUnique();
    }
}
```

Bu örnekte:
- `DbSet<Product>` ve `DbSet<Category>`, `Products` ve `Categories` tablolarını temsil eder.
- `OnConfiguring` metodu, veritabanı bağlantı dizesini yapılandırır.
- `OnModelCreating` metodu, model yapılandırmasını özelleştirmek için kullanılır. Örneğin, bir sütunu unique yapabilir veya ilişkileri daha ayrıntılı tanımlayabilirsiniz.

---

##### 2. Migration İşlemleri ve Veritabanı Güncellemeleri

**Migration Nedir?**
Migration, veritabanı şemasını güncellemek için kullanılan bir araçtır. Migration dosyaları, veritabanının nasıl oluşturulacağını veya güncelleneceğini tanımlar. Örneğin, yeni bir tablo eklediğinizde veya bir sütun eklediğinizde, migration ile bu değişiklikleri veritabanına yansıtabilirsiniz.

**Migration Adımları:**

1. **Migration Oluşturma:**
   İlk adım, migration oluşturmak için aşağıdaki komutu çalıştırmanızdır:
   ```bash
   dotnet ef migrations add InitialCreate
   ```
   Bu komut, `Migrations` adında bir klasör oluşturur ve bu klasör altında iki dosya ekler:
   - **Snapshot Dosyası:** Mevcut veritabanı şemasının bir "fotografını" tutar.
   - **Migration Dosyası:** Veritabanını nasıl güncelleyeceğinizi tanımlar.

   Örnek bir migration dosyası şu şekilde görünebilir:
   ```csharp
   public partial class InitialCreate : Migration
   {
       protected override void Up(MigrationBuilder migrationBuilder)
       {
           migrationBuilder.CreateTable(
               name: "Categories",
               columns: table => new
               {
                   Id = table.Column<int>(nullable: false)
                       .Annotation("SqlServer:Identity", "1, 1"),
                   Name = table.Column<string>(maxLength: 50, nullable: false)
               },
               constraints: table =>
               {
                   table.PrimaryKey("PK_Categories", x => x.Id);
               });

           migrationBuilder.CreateTable(
               name: "Products",
               columns: table => new
               {
                   Id = table.Column<int>(nullable: false)
                       .Annotation("SqlServer:Identity", "1, 1"),
                   Name = table.Column<string>(maxLength: 100, nullable: false),
                   Price = table.Column<decimal>(nullable: false),
                   CategoryId = table.Column<int>(nullable: false)
               },
               constraints: table =>
               {
                   table.PrimaryKey("PK_Products", x => x.Id);
                   table.ForeignKey(
                       name: "FK_Products_Categories_CategoryId",
                       column: x => x.CategoryId,
                       principalTable: "Categories",
                       principalColumn: "Id",
                       onDelete: ReferentialAction.Cascade);
               });
       }

       protected override void Down(MigrationBuilder migrationBuilder)
       {
           migrationBuilder.DropTable(
               name: "Products");

           migrationBuilder.DropTable(
               name: "Categories");
       }
   }
   ```

   Bu dosyada:
   - `Up` metodu, veritabanını güncellemek için gereken SQL komutlarını içerir.
   - `Down` metodu, migration'ı geri almaya yarar (örneğin, tabloları silmek).

2. **Migration Uygulama:**
   Migration'ı veritabanına uygulamak için aşağıdaki komutu çalıştırabilirsiniz:
   ```bash
   dotnet ef database update
   ```
   Bu komut, tanımlanan entity sınıflarına göre veritabanını oluşturur veya günceller.

3. **Değişiklikleri Yansıtma:**
   Eğer entity sınıflarında bir değişiklik yaparsanız (örneğin, yeni bir property eklerseniz), tekrar bir migration oluşturup uygulayabilirsiniz:
   ```bash
   dotnet ef migrations add AddDescriptionToProduct
   dotnet ef database update
   ```

---


#### 2. Database First Yaklaşımı

##### 1. Database First Nedir?

**Database First**, var olan bir veritabanını temel alarak EF Core'un entity sınıflarını ve `DbContext` sınıfını otomatik olarak oluşturmasını sağlar. Bu yaklaşım, özellikle:
- Mevcut bir veritabanınız olduğunda,
- Veritabanı şemasının geliştiricilerden bağımsız olarak tasarlandığında,
- Veritabanı yapısının sık sık değişmediği durumlarda kullanışlıdır.

Örneğin, bir şirketin eski bir SQL Server veritabanı olduğunu ve bu veritabanını yeni bir .NET uygulamasıyla entegre etmek istediğini düşünelim. Bu durumda, Database First yaklaşımıyla veritabanını temel alarak C# sınıfları oluşturabilirsiniz.


##### 2. Mevcut Bir Veritabanından Model Oluşturma

Database First yaklaşımında, mevcut bir veritabanından model oluşturmak için aşağıdaki adımları izlersiniz:

1. **Scaffolding Komutu:**
   EF Core'un `dotnet ef dbcontext scaffold` komutunu kullanarak veritabanından entity sınıfları ve `DbContext` oluşturabilirsiniz. Örnek bir komut şu şekilde olabilir:

   ```bash
   dotnet ef dbcontext scaffold "Server=(localdb)\mssqllocaldb;Database=MyExistingDb;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer --output-dir Models
   ```

   Bu komutun parametreleri:
   - `"Server=...":` Veritabanı bağlantı dizesi.
   - `Microsoft.EntityFrameworkCore.SqlServer:` Kullanılacak veritabanı sağlayıcısı.
   - `--output-dir Models:` Oluşturulan sınıfların kaydedileceği klasör.

2. **Oluşturulan Dosyalar:**
   Komut çalıştırıldığında, veritabanındaki her bir tablo için bir entity sınıfı ve bir `DbContext` sınıfı oluşturulur. Örneğin:
   - `Products` tablosu için bir `Product` sınıfı,
   - `Categories` tablosu için bir `Category` sınıfı,
   - Veritabanı için bir `AppDbContext` sınıfı.

   Örnek bir `Product` sınıfı şu şekilde görünebilir:

   ```csharp
   public partial class Product
   {
       public int Id { get; set; }
       public string Name { get; set; }
       public decimal Price { get; set; }
       public int CategoryId { get; set; }

       public virtual Category Category { get; set; }
   }
   ```

   Ve `AppDbContext` sınıfı şu şekilde görünebilir:

   ```csharp
   public partial class AppDbContext : DbContext
   {
       public AppDbContext(DbContextOptions<AppDbContext> options)
           : base(options)
       {
       }

       public virtual DbSet<Product> Products { get; set; }
       public virtual DbSet<Category> Categories { get; set; }

       protected override void OnModelCreating(ModelBuilder modelBuilder)
       {
           // Veritabanı şemasını tanımlayan yapılandırma kodları
       }
   }
   ```

---

##### 3. DbContext ve Entity Sınıflarının Üretilmesi

EF Core, veritabanındaki tabloları analiz ederek:
- Her bir tabloyu temsil eden entity sınıfları oluşturur.
- Tablolar arasındaki ilişkileri navigation property'ler aracılığıyla tanımlar.
- `DbContext` sınıfını, veritabanı işlemlerini yönetmek için yapılandırır.

**Örnek Senaryo:**
Bir e-ticaret sistemi için aşağıdaki tabloların olduğunu düşünelim:
- `Products`: Ürün bilgilerini içerir.
- `Categories`: Kategori bilgilerini içerir.

Bu tablolar arasında bir ilişki olduğunu varsayalım (`Products.CategoryId` → `Categories.Id`). EF Core, bu ilişkiyi analiz ederek `Product` sınıfında bir `Category` navigation property'si oluşturur.

---

##### 4. Veritabanı Değişikliklerini Yönetme

Database First yaklaşımında, veritabanı şeması geliştiricilerden bağımsız olarak yönetilir. Eğer veritabanında bir değişiklik yapılırsa (örneğin, yeni bir tablo eklenirse veya bir sütun değiştirilirse), bu değişiklikleri yansıtmanız gerekir. Bunun için aşağıdaki adımları izleyebilirsiniz:

1. **Yeni Scaffolding Yapma:**
   Veritabanındaki değişiklikleri yansıtmak için aynı `dotnet ef dbcontext scaffold` komutunu tekrar çalıştırabilirsiniz. Ancak, bu işlem sırasında mevcut sınıfların üzerine yazılacağı için dikkatli olmanız gerekir.

2. **Elle Güncelleme:**
   Eğer küçük bir değişiklik yapıldıysa (örneğin, bir sütun eklendi), sınıfları elle güncelleyebilirsiniz. Örneğin, `Product` sınıfına yeni bir `Description` özelliği ekleyebilirsiniz:

   ```csharp
   public partial class Product
   {
       public string Description { get; set; }  // Yeni eklenen özellik
   }
   ```


##### 5. Avantajlar ve Dezavantajlar

**Avantajları:**
- **Var Olan Veritabanlarını Kullanabilirsiniz:** Zaten bir veritabanınız varsa, bu yaklaşım hızlıca başlamayı sağlar.
- **Veritabanı Şeması Kontrolü:** Veritabanı şemasını DBA'lar (Database Administrators) yönetebilir.
- **Geliştirme Süresini Kısaltır:** Kod yazmadan entity sınıflarını ve `DbContext` oluşturabilirsiniz.

**Dezavantajları:**
- **Esneklik Azlığı:** Veritabanı şeması değiştiğinde, sınıfları yeniden oluşturmanız veya elle güncellemeniz gerekebilir.
- **Code First Gibi Kolay Değil:** Code First'de olduğu gibi migration kullanamazsınız.
- **Otomatik Olmayan Güncellemeler:** Veritabanındaki değişiklikleri sürekli olarak takip etmeniz gerekir.

---



#### 3. LINQ to Entities

**LINQ to Entities**, Entity Framework Core'da veritabanı sorgularını yazmak için kullanılan bir araçtır. **LINQ (Language Integrated Query)**, C# diline entegre bir sorgulama dilidir ve veritabanı işlemlerini SQL yerine C# kodu ile gerçekleştirmenizi sağlar. Bu sayede, SQL öğrenmeden veya yazmadan veritabanı işlemlerini kolayca yapabilirsiniz.


##### 1. LINQ Sorguları ile Veritabanı İşlemleri

**LINQ Nedir?**
LINQ, C# dilinde veri kümeleri üzerinde sorgulama yapmanızı sağlayan bir yapıdır. LINQ, veritabanı tabloları, koleksiyonlar veya XML gibi farklı veri kaynakları üzerinde çalışabilir. LINQ to Entities ise, özellikle Entity Framework Core ile kullanılır ve veritabanı işlemleri için tasarlanmıştır.

**Temel LINQ Sorguları:**

1. **Veri Çekme (SELECT):**
   Veritabanından veri çekmek için `Where`, `Select` gibi LINQ operatörlerini kullanabilirsiniz. Örneğin, fiyatı 5000 TL'den düşük olan ürünleri çekmek için aşağıdaki sorguyu yazabilirsiniz:

   ```csharp
   using (var context = new AppDbContext())
   {
       var cheapProducts = context.Products
           .Where(p => p.Price < 5000)  // Fiyatı 5000'den küçük olan ürünleri filtrele
           .ToList();  // Sonuçları liste olarak al

       foreach (var product in cheapProducts)
       {
           Console.WriteLine($"{product.Name} - {product.Price} TL");
       }
   }
   ```

   Bu örnekte:
   - `Where`, verileri filtrelemek için kullanılır.
   - `ToList`, sonuçları bir liste olarak döndürür.

2. **Sıralama (ORDER BY):**
   Verileri sıralamak için `OrderBy` veya `OrderByDescending` kullanabilirsiniz. Örneğin, ürünleri fiyata göre artan şekilde sıralamak için:

   ```csharp
   var sortedProducts = context.Products
       .OrderBy(p => p.Price)  // Fiyata göre artan şekilde sırala
       .ToList();
   ```

3. **İlişkili Verileri Çekme (JOIN):**
   İlişkili tablolardan veri çekmek için navigation property'leri kullanabilirsiniz. Örneğin, her bir ürünün kategori adını da çekmek için:

   ```csharp
   var productsWithCategories = context.Products
       .Include(p => p.Category)  // Kategori bilgilerini de çek
       .ToList();

   foreach (var product in productsWithCategories)
   {
       Console.WriteLine($"{product.Name} - {product.Category.Name}");
   }
   ```

   Burada, `Include` metodu, ilişkili kategori bilgilerini de yükler.

4. **Tek Bir Kayıt Çekme (FIRST OR DEFAULT):**
   Tek bir kayıt çekmek için `FirstOrDefault` veya `SingleOrDefault` kullanabilirsiniz. Örneğin, ID'si 1 olan ürünü çekmek için:

   ```csharp
   var product = context.Products
       .FirstOrDefault(p => p.Id == 1);  // ID'si 1 olan ürünü bul
   ```

5. **Agregasyon İşlemleri (COUNT, SUM, AVERAGE):**
   Toplam kayıt sayısı, toplam fiyat veya ortalama fiyat gibi hesaplamalar için `Count`, `Sum`, `Average` gibi metodları kullanabilirsiniz. Örneğin, ürünlerin ortalama fiyatını hesaplamak için:

   ```csharp
   var averagePrice = context.Products
       .Average(p => p.Price);  // Ürünlerin ortalama fiyatını hesapla
   ```


##### 2. Performans Optimizasyonu ve Best Practices

**1. Gereksiz Veri Yüklemeyi Önleyin:**
Veritabanından yalnızca ihtiyacınız olan verileri çekin. Örneğin, tüm ürün bilgilerine ihtiyacınız yoksa yalnızca gerekli alanları seçin:

```csharp
var productNames = context.Products
    .Where(p => p.Price > 5000)
    .Select(p => p.Name)  // Sadece ürün adlarını çek
    .ToList();
```

Bu şekilde, gereksiz veri yüklemesi önlenir ve performans artırılır.

---

**2. Eager Loading vs Lazy Loading:**
- **Eager Loading:** İlişkili verileri başlangıçta yükler. `Include` metodu ile yapılır. Örnek:
  ```csharp
  var products = context.Products
      .Include(p => p.Category)
      .ToList();
  ```
  Eager loading, ilişkili verilere erişim hızını artırır ancak fazladan veri yükleme riski taşır.

- **Lazy Loading:** İlişkili veriler, yalnızca erişildiğinde yüklenir. Ancak bu, birden fazla veritabanı sorgusu tetikleyebilir ve performansı düşürebilir. Örnek:
  ```csharp
  foreach (var product in context.Products)
  {
      Console.WriteLine(product.Category.Name);  // Kategori bilgisi burada yüklenir
  }
  ```

---

**3. AsNoTracking ile Performans Artırma:**
Eğer verileri yalnızca okumak istiyorsanız, `AsNoTracking` kullanarak performansı artırabilirsiniz. Bu yöntem, EF Core'un değişiklikleri takip etmesini engeller:

```csharp
var products = context.Products
    .AsNoTracking()  // Değişiklikleri takip etme
    .ToList();
```

---

**4. Batch İşlemler:**
Birden fazla işlemi tek seferde yaparak performansı artırabilirsiniz. Örneğin, birden fazla ürünü aynı anda eklemek için:

```csharp
var newProducts = new List<Product>
{
    new Product { Name = "Laptop", Price = 9999 },
    new Product { Name = "Tablet", Price = 4999 }
};

context.Products.AddRange(newProducts);  // Tüm ürünleri bir seferde ekle
context.SaveChanges();
```

---

**5. Index Kullanımı:**
Sıkça sorgulanan alanlarda indeks tanımlayarak performansı artırabilirsiniz. Örneğin, `Name` alanına bir indeks eklemek için:

```csharp
modelBuilder.Entity<Product>()
    .HasIndex(p => p.Name);
```

---

**6. Logging ve Debugging:**
EF Core'un hangi SQL sorgularını oluşturduğunu görmek için logging özelliğini etkinleştirebilirsiniz. Örneğin:

```csharp
optionsBuilder.LogTo(Console.WriteLine, LogLevel.Information);
```

Bu sayede, üretilen SQL sorgularını kontrol edebilir ve optimize edebilirsiniz.

---


### Püf Noktalar

1. Model, View, Controller kavramlarını iyi anlamak için: Model veriyi temsil eder, View kullanıcı arayüzüdür ve Controller bu ikisi arasında köprü görevi görür. Her birinin sorumluluğunu açıkça belirleyin.
2. Routing yapılandırırken URL'lerin anlaşılır ve tutarlı olmasını sağlayın. Örneğin, `/api/products` gibi standart bir yapı kullanın.
3. Action metodlarını HTTP metotlarıyla doğru şekilde eşleyin. Örneğin, GET sadece veri almak için, POST yeni veri eklemek için kullanılmalıdır.
4. Razor Pages'te sayfa odaklı bir yapı olduğundan, her sayfanın kendi modeli ve view'i olduğunu unutmayın. PageModel sınıfını her zaman düzenli ve temiz tutun.
5. Handler metotlarının isimlendirmesinde `OnGet`, `OnPost` gibi standartları takip edin ve işlevleri net bir şekilde belirtin.
6. RESTful API tasarımı yaparken kaynak odaklı (resource-based) bir yaklaşım benimseyin. Kaynaklar için çoğul isimler kullanın (örneğin, `/products`).
7. HTTP metotlarını doğru amaçlar için kullanın: GET veri almak, POST yeni veri eklemek, PUT güncellemek ve DELETE silmek için.
8. Model validation için `[Required]`, `[StringLength]`, `[Range]` gibi attribute'leri kullanın ve hata mesajlarını kullanıcı dostu bir dilde yazın.
9. Global hata yönetimi için middleware oluşturun ve hata mesajlarını üretim ortamında genel tutun (detaylı hata mesajları geliştirme ortamında gösterilebilir).
10. Entity sınıflarını tanımlarken, property isimlerini ve tiplerini veritabanı şemasına uygun seçin. İlişkileri navigation property'lerle net bir şekilde tanımlayın.
11. Migration işlemleri sırasında her değişiklikten önce veritabanının yedeğini alın ve migration dosyalarını düzenli bir şekilde sürüm kontrolü altına alın.
12. LINQ sorgularında yalnızca ihtiyacınız olan verileri çekmek için `Select` kullanın ve gereksiz veri yüklemeyi önleyin.
13. Performans optimizasyonu için `AsNoTracking` kullanarak read-only işlemlerde EF Core'un değişiklikleri takip etmesini engelleyin.
14. Batch işlemlerle birden fazla işlemi tek seferde gerçekleştirerek veritabanı trafiğini azaltın.
15. Index kullanarak sıkça sorgulanan alanların performansını artırın.
16. Logging özelliğini etkinleştirerek üretilen SQL sorgularını izleyin ve optimize edin.
17. Veritabanı şeması değiştiğinde, Database First yaklaşımında sınıfları yeniden oluştururken mevcut kodlarınızı korumak için dikkatli olun.
18. Code First ile çalışırken migration adımlarını düzenli bir şekilde takip edin ve her değişikliği küçük adımlar halinde uygulayın.
19. Razor syntax kullanırken HTML ile C# kodlarını birleştirmek için `@` işaretini kullanın ve kod bloklarını `{}` içinde düzenli bir şekilde yazın.
20. Middleware'leri sıralamaya dikkat edin çünkü sıralama, isteklerin nasıl işleneceğini etkiler. Özellikle global hata yönetimi middleware'ini en başa yerleştirin.


### Akla Gelebilecek Sorular ve Cevapları

#### MVC (Model-View-Controller) Mimarisi
1. **Soru:** Model, View ve Controller tam olarak ne işe yarar?  
   - Model, uygulamanın veri ve iş mantığını temsil eder. View, kullanıcı arayüzünü oluşturur ve kullanıcıya gösterilen içeriği tanımlar. Controller ise model ve view arasında köprü görevi görür, gelen istekleri işler ve uygun yanıtı döndürür.

2. **Soru:** Routing nedir ve neden önemlidir?  
   - Routing, bir URL'nin hangi controller ve action metoduna yönlendirileceğini belirler. İyi tasarlanmış bir routing yapısı, API'nin kullanımı daha anlaşılır ve düzenli hale getirir.

3. **Soru:** Action metotlarının amacı nedir?  
   - Action metotları, gelen HTTP isteklerini işler ve uygun yanıtı döndürür. Örneğin, bir ürün listesi döndürmek için `Get` action'ı, yeni bir ürün eklemek için `Post` action'ı kullanılır.

---

#### Razor Pages
4. **Soru:** Razor Pages ile MVC arasındaki fark nedir?  
   - Razor Pages sayfa odaklıdır ve her sayfa için bir model (PageModel) ve view içerir. MVC ise daha modüler bir yapıdadır ve büyük projeler için daha uygundur.

5. **Soru:** Razor syntax nedir ve nasıl çalışır?  
   - Razor syntax, HTML ile C# kodlarını birleştirmenizi sağlar. Örneğin, `@model` ifadesi ile bir model belirtirken, `@foreach` gibi C# kod bloklarıyla verileri HTML içinde kullanabilirsiniz.

6. **Soru:** Handler metotları ne işe yarar?  
   - Handler metotları, Razor Pages'te gelen istekleri işler. Örneğin, `OnGet` bir GET isteğini, `OnPost` bir POST isteğini işler.

---

#### RESTful API Kavramı
7. **Soru:** RESTful API nedir ve neden önemlidir?  
   - RESTful API, HTTP protokolünün temel özelliklerini kullanarak veri alışverişi yapmayı sağlayan bir mimaridir. Standartlaştırılmış ve platform bağımsız olması nedeniyle yaygın olarak kullanılır.

8. **Soru:** HTTP metotlarının kullanım amacı nedir?  
   - GET veri almak, POST yeni veri eklemek, PUT mevcut veriyi güncellemek ve DELETE veriyi silmek için kullanılır.

9. **Soru:** JSON formatı neden tercih edilir?  
   - JSON, hafif, insan tarafından okunabilir ve birçok programlama dili tarafından desteklenir. Bu nedenle API'lerde yaygın olarak kullanılır.

---

#### Controller ve Action Metodları
10. **Soru:** Controller oluşturma adımları nelerdir?  
    - Controller oluşturmak için sınıfı `ControllerBase` sınıfından türetin, `[ApiController]` attribute'ünü ekleyin ve `[Route]` ile URL yolunu tanımlayın.

11. **Soru:** Action metotlarını HTTP metotlarıyla nasıl eşlersiniz?  
    - Action metotlarına `[HttpGet]`, `[HttpPost]`, `[HttpPut]`, `[HttpDelete]` gibi attribute'ler ekleyerek HTTP metotlarıyla eşlersiniz.

12. **Soru:** `[FromBody]` attribute'ü ne işe yarar?  
    - `[FromBody]`, gelen HTTP isteğinin gövdesindeki veriyi bir modele bağlamak için kullanılır. Örneğin, bir POST isteğiyle gönderilen JSON verisini bir nesneye dönüştürür.

---

#### Veri Doğrulama ve Hata Yönetimi
13. **Soru:** Model validation nasıl yapılır?  
    - Model validation için `[Required]`, `[StringLength]`, `[Range]` gibi attribute'ler kullanılır. Eğer doğrulama başarısız olursa, API hata mesajları döndürür.

14. **Soru:** Global hata yönetimi neden gereklidir?  
    - Global hata yönetimi, tüm hataları tek bir yerden ele almanızı sağlar. Bu, hata yönetiminin daha düzenli ve tutarlı olmasını sağlar.

15. **Soru:** Middleware nedir ve nasıl kullanılır?  
    - Middleware, bir HTTP isteğinin işlenmesi sırasında gerçekleşen işlemler zinciridir. Örneğin, global hata yönetimi veya logging işlemleri için middleware kullanılır.

---

#### Code First Yaklaşımı
16. **Soru:** Code First yaklaşımının avantajları nelerdir?  
    - Code First, veritabanını kod üzerinden yönetmenizi sağlar. Bu sayede, veritabanı şemasını kaynak kodunuzla birlikte sürüm kontrolü altına alabilirsiniz.

17. **Soru:** Migration nedir ve ne zaman kullanılır?  
    - Migration, veritabanını güncellemek için kullanılan bir araçtır. Örneğin, yeni bir tablo eklediğinizde veya bir sütun değiştirdiğinizde migration ile bu değişiklikleri veritabanına yansıtabilirsiniz.

18. **Soru:** DbContext'in amacı nedir?  
    - `DbContext`, veritabanı ile etkileşim kurmak için kullanılır. Entity sınıflarınızı `DbContext` içinde tanımlayarak, bu sınıfların veritabanındaki tablolarla eşleşmesini sağlarsınız.

---

#### LINQ to Entities
19. **Soru:** LINQ ile SQL arasındaki fark nedir?  
    - LINQ, C# diline entegre bir sorgulama dilidir ve SQL yerine C# kodu ile veritabanı işlemlerini yapmanızı sağlar. Bu sayede, SQL öğrenmeden veya yazmadan veritabanı işlemlerini kolayca yapabilirsiniz.

20. **Soru:** `Include` metodu ne işe yarar?  
    - `Include`, ilişkili tablolardaki verileri de yüklemenizi sağlar. Örneğin, bir ürünün kategori bilgilerini çekmek için kullanılır.

21. **Soru:** LINQ sorgularında performans nasıl artırılır?  
    - Gereksiz veri yüklemeyi önlemek için `Select` kullanın, read-only işlemlerde `AsNoTracking` kullanın ve sıkça sorgulanan alanlar için index tanımlayın.

---

#### Database First Yaklaşımı
22. **Soru:** Database First ile Code First arasındaki fark nedir?  
    - Database First, var olan bir veritabanını temel alırken, Code First kod üzerinden veritabanı oluşturur. Code First, daha esnek ve geliştirici dostudur.

23. **Soru:** Scaffolding ne demektir?  
    - Scaffolding, mevcut bir veritabanından entity sınıfları ve `DbContext` oluşturmak için kullanılan bir işlemdir.

24. **Soru:** Veritabanı şeması değişirse ne olur?  
    - Veritabanı şeması değiştiğinde, sınıfları yeniden oluşturmanız veya elle güncellemeniz gerekebilir. Küçük değişiklikler için elle düzenleme, büyük değişiklikler için scaffolding tekrar yapılabilir.
